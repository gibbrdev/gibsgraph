{"name": "Modeling designs", "description": "This page features examples of graph data modeling patterns and designs that are commonly used with Neo4j.", "when_to_use": "Linked list\n\nLinked lists are commonly used in computer science and they are particularly useful whenever the sequence of objects matters.\nA *simple-linked list* is where each node links to the next node only:\n\nimage::simple-linked-list.svg[Episodes of Dr Who linked in sequence with next relationships,width=500,role=popup]\n\nIn a *double-linked list*, each node links both to the next and the previous node:\n\nimage::double-linked-list.svg[Episodes of Dr Who doubly linked with next and previous rela", "anti_pattern": "Intermediate nodes\n\nIntermediary nodes are nodes that contain data that need to be in the graph but don't seem to fit neatly into the initial model.\n\nSometimes you need to convey a lot of information in a relationship.\nIn a mathematical graph, this can be solved with a *hyperedge*, i.e. a relationship that connects more than two nodes.\nThis is not supported in Neo4j but can be solved by using an intermediary node.\n\nFor example, consider a person who works at a company and you need to convey info", "cypher_examples": [], "node_labels": ["Company", "Person", "WORKED"], "relationship_types": [], "source_file": "modules\\ROOT\\pages\\data-modeling\\modeling-designs.adoc", "authority_level": 1}
{"name": "Modeling: relational to graph", "description": "For those with a background in relational data modeling, this guide helps transfer your existing knowledge of the processes and components used for relational data modeling into graph data modeling.", "when_to_use": "Relational and graph architecture\n\nAs a quick overview, remember that relational databases rely upon index lookups and table joins to connect different entities.\nThis quickly becomes a problem for performance, especially when there are several tables joined, millions of rows on tables, or complex queries that traverse various levels through subqueries.\n\nIn our example from the concepts page, to find which departments Alice works for, you would need to query the `Person` table to find the row rep", "anti_pattern": "", "cypher_examples": [], "node_labels": [], "relationship_types": [], "source_file": "modules\\ROOT\\pages\\data-modeling\\relational-to-graph-modeling.adoc", "authority_level": 1}
{"name": "Tutorial: Create a graph data model", "description": "This tutorial is designed to help you understand how data modeling works through an example use case.", "when_to_use": "Test the model\n\nAfter populating the graph to implement the data model with a small set of test data, you should now test it to ensure that it satisfies every xref:#_define_the_use_case[use case].\n\nFor example, if you want to test the use case \"Which people acted in a movie?\", you can run the following query:\n\n[source,cypher]\n--\nMATCH (p:Person)-[:ACTED_IN]-(m:Movie)\nWHERE m.title = 'Sleepless in Seattle'\nRETURN p.name\n--\n\nThis is just a simple example of testing.\nAs you go through the use cases", "anti_pattern": "", "cypher_examples": [], "node_labels": ["ACTED", "DIRECTED", "Movie", "Person", "RATED", "User"], "relationship_types": ["ACTED_IN", "DIRECTED", "RATED"], "source_file": "modules\\ROOT\\pages\\data-modeling\\tutorial-data-modeling.adoc", "authority_level": 1}
{"name": "Tutorial: Refactor a graph data model", "description": "This tutorial teaches you how to refactor your graph data model.", "when_to_use": "Retest the graph\n\nAfter you have refactored the graph, you should revisit all queries for your xref:data-modeling/tutorial-data-modeling.adoc#_define_the_use_case[use cases] and determine whether any of them can be rewritten to take advantage of the refactoring.\nHere is a list:\n\n[options=header,cols=\"1,1a\"]\n|===\n\n| Use case\n| Query example\n\n| Which people acted in a movie?\n| [source,cypher]\n--\nMATCH (p:Person)-[:ACTED_IN]->(m:Movie {title:'Hoffa'})\nRETURN p\n--\n\n| Which person directed a movie?\n|", "anti_pattern": "Using specific relationships\n\nSpecific relationships are a refactor strategy that you can use when your project has a recurrent use case that needs a certain piece of information to be constantly retrieved.\nThe benefits of using them include:\n\n* Reducing the number of nodes that need to be retrieved.\n* Improving query performance.\n\nSuppose that you frequently need to retrieve information about actors in reference to the year 1995.\nThe query for that could be:\n\n[source,cypher]\n--\nMATCH (p:Person)", "cypher_examples": [], "node_labels": ["ACTED", "DIRECTED", "IN", "Language", "Movie", "PRODUCED", "Person", "ProductionCompany", "RATED", "User"], "relationship_types": ["ACTED_IN", "ACTED_IN_", "DIRECTED", "IN_LANGUAGE", "PRODUCED", "RATED"], "source_file": "modules\\ROOT\\pages\\data-modeling\\tutorial-refactoring.adoc", "authority_level": 1}
{"name": "Versioning", "description": "See what options of graph data model versioning are commonly used in combination with Neo4j.", "when_to_use": "Timeline tree\n\nAs mentioned in xref:data-modeling/modeling-designs.adoc[Modeling designs], the timeline tree is a common modeling design.\nIt can be a useful strategy when you want to track change.\nIn this example, the timeline structure spans from years to days, and the rest of the non-time data nodes are the nodes that contain the important pieces of data in the graph:\n\nimage::timeline-tree.svg[Graph with two different timeslines divided in years, months, and days and what purchases are connect", "anti_pattern": "Time-based versioning of entities\n\nA variation of the entity versioning is a time-based approach.\nIt is useful when you are interested in:\n\n* *Graph snapshot* by retrieving all valid elements (nodes and relationships) of the graph to a specific point in time (e.g. which products are available on Monday the 12.06.23).\n* *Graph difference* by comparing two graph snashots of different time stamps (e.g. which nodes are added, which are deleted, and which remain the same).\n* *Temporal traversal* by t", "cypher_examples": [], "node_labels": ["HAS", "IN", "LAST", "LATEST", "Month", "NEXT", "OCCURRED", "ON", "Product", "Purchase", "State", "Timeline", "Year"], "relationship_types": ["IN_MONTH", "IN_YEAR", "LAST", "LATEST", "NEXT", "OCCURRED", "ON_DAY", "V"], "source_file": "modules\\ROOT\\pages\\data-modeling\\versioning.adoc", "authority_level": 1}
{"name": "Tutorial: Build a Cypher Recommendation Engine", "description": "Gather insights and generate recommendations with simple cypher queries, by navigating the graph", "when_to_use": "Resources\n* link:https://www.youtube.com/channel/UCvze3hU6OZBkB1vkhH2lH9Q/search?query=recommendation[Neo4j Videos: Building Recommendation Engines^]\n* link:https://neo4j.com/use-cases/real-time-recommendation-engine/[Recommendation Use Cases^]\n* link:/graphacademy/online-training/online-training/introduction-to-neo4j-40/[Online Training: Learn Cypher with Intro to Neo4j^]\n* https://www.slideshare.net/bachmanm/recommendations-with-neo4j[Michal Bachman Slides: Recommendation Engines with Neo4j^]", "anti_pattern": "", "cypher_examples": ["MATCH (tom:Person {name: 'Tom Hanks'})\nRETURN tom", "MATCH (tom:Person {name: 'Tom Hanks'})-[r:ACTED_IN]->(movie:Movie)\nRETURN tom, r, movie", "MATCH (tom:Person {name: 'Tom Hanks'})-[:ACTED_IN]->(:Movie)<-[:ACTED_IN]-(coActor:Person)\nRETURN coActor.name", "MATCH (tom:Person {name: 'Tom Hanks'})-[:ACTED_IN]->(movie1:Movie)<-[:ACTED_IN]-(coActor:Person)-[:ACTED_IN]->(movie2:Movie)<-[:ACTED_IN]-(coCoActor:Person)\nWHERE tom <> coCoActor\nAND NOT (tom)-[:ACTED_IN]->(:Movie)<-[:ACTED_IN]-(coCoActor)\nRETURN coCoActor.name", "MATCH (tom:Person {name: 'Tom Hanks'})-[:ACTED_IN]->(movie1:Movie)<-[:ACTED_IN]-(coActor:Person)-[:ACTED_IN]->(movie2:Movie)<-[:ACTED_IN]-(coCoActor:Person)\nWHERE tom <> coCoActor\nAND NOT (tom)-[:ACTED_IN]->(:Movie)<-[:ACTED_IN]-(coCoActor)\nRETURN coCoActor.name, count(coCoActor) as frequency\nORDER BY frequency DESC\nLIMIT 5", "MATCH (tom:Person {name: 'Tom Hanks'})-[:ACTED_IN]->(movie1:Movie)<-[:ACTED_IN]-(coActor:Person)-[:ACTED_IN]->(movie2:Movie)<-[:ACTED_IN]-(cruise:Person {name: 'Tom Cruise'})\nWHERE NOT (tom)-[:ACTED_IN]->(:Movie)<-[:ACTED_IN]-(cruise)\nRETURN tom, movie1, coActor, movie2, cruise", "MATCH (person:Person {name: 'Philip'})-[:IS_FRIEND_OF]->(friend)-[:LIKES]->(restaurant:Restaurant)-[:LOCATED_IN]->(loc:Location {location: 'New York'}),\n      (restaurant)-[:SERVES]->(type:Cuisine {type: 'Sushi'})\nRETURN restaurant.name, count(*) AS occurrence\nORDER BY occurrence DESC\nLIMIT 5"], "node_labels": ["ACTED", "Cuisine", "IS", "LIKES", "LOCATED", "Location", "Movie", "Person", "Restaurant", "SERVES"], "relationship_types": ["ACTED_IN", "IS_FRIEND_OF", "LIKES", "LOCATED_IN", "SERVES"], "source_file": "modules\\ROOT\\pages\\appendix\\tutorials\\guide-build-a-recommendation-engine.adoc", "authority_level": 1}
{"name": "Comparing Cypher with SQL", "description": "Learn how to write equivalent SQL statements using Cypher.", "when_to_use": "Query examples\n\n=== Select and return records\n\n[options=header,cols='1,1']\n|===\n\n| SQL\n| Cypher\n\na| To select and return records in SQL, select everything from the `products` table:\n[source, plsql]\n--\nSELECT p.*\nFROM products as p;\n--\n\na| In Cypher, you `MATCH` a simple pattern: all nodes with the *label* `:Product`, and `RETURN` them:\n[source, cypher]\n----\nMATCH (p:Product)\nRETURN p;\n----\n|===\n\n=== Field access, ordering, and paging\n\nRather than returning all attributes, you can filter out the", "anti_pattern": "Query examples\n\n=== Select and return records\n\n[options=header,cols='1,1']\n|===\n\n| SQL\n| Cypher\n\na| To select and return records in SQL, select everything from the `products` table:\n[source, plsql]\n--\nSELECT p.*\nFROM products as p;\n--\n\na| In Cypher, you `MATCH` a simple pattern: all nodes with the *label* `:Product`, and `RETURN` them:\n[source, cypher]\n----\nMATCH (p:Product)\nRETURN p;\n----\n|===\n\n=== Field access, ordering, and paging\n\nRather than returning all attributes, you can filter out the", "cypher_examples": ["MATCH (p:Product)\nRETURN p;", "MATCH (p:Product)\nRETURN p.productName, p.unitPrice\nORDER BY p.unitPrice DESC\nLIMIT 10;", "MATCH (p:Product)\nWHERE p.productName = 'Chocolade'\nRETURN p.productName, p.unitPrice;", "MATCH (p:Product {productName:'Chocolade'})\nRETURN p.productName, p.unitPrice;", "MATCH (p:Product)\nWHERE p.productName IN ['Chocolade','Chai']\nRETURN p.productName, p.unitPrice;", "MATCH (p:Product)\nWHERE p.productName STARTS WITH 'C' AND p.unitPrice > 100\nRETURN p.productName, p.unitPrice;", "MATCH (p:Product)\nWHERE p.productName =~ '^C.*'\nRETURN p.productName, p.unitPrice", "MATCH (p:Product {productName:'Chocolade'})<-[:ORDERS]-(:Order)<-[:PURCHASED]-(c:Customer)\nRETURN DISTINCT c.companyName;", "MATCH (s:Supplier)<-[:SUPPLIED_BY]-(p:Product)\nRETURN s.companyName AS Supplier, COUNT(p) AS NumberOfProducts\nORDER BY NumberOfProducts DESC\nLIMIT 5", "MATCH (s:Supplier)-[:SUPPLIES]->(p:Product)\nRETURN s.companyName AS Supplier, COLLECT(p.productName) AS ProductsSupplied\nORDER BY Supplier\nLIMIT 5"], "node_labels": ["Customer", "ORDERS", "Order", "PURCHASED", "Product", "SUPPLIED", "SUPPLIES", "Supplier"], "relationship_types": ["ORDERS", "PURCHASED", "SUPPLIED_BY", "SUPPLIES"], "source_file": "modules\\ROOT\\pages\\cypher\\cypher-sql.adoc", "authority_level": 1}
{"name": "Get started with Cypher", "description": "This tutorial shows the basic concepts of Cypher, Neo4j's query language, including how to create and query graphs.", "when_to_use": "Clean up\n\nWhen you're done experimenting, you can remove the movie data set and clean up your Aura instance.\nYou can delete everything with one single query:\n\n[source, cypher]\n--\nMATCH (n)\nDETACH DELETE n\n--\n\nThe result is the following message: \"Deleted 171 nodes, deleted 253 relationships\".\n\n=== Verify if the graph is gone\n\nIf you perform this query to retrieve all nodes in the graph and return the count, you should see a value of 0 returned:\n\n[source, cypher]\n--\nMATCH (n)\nRETURN count(*)\n--", "anti_pattern": "Find patterns\n\nIn the previous step, you queried the graph for nodes.\nNow you are going to retrieve related nodes by finding the link:https://neo4j.com/docs/cypher-manual/current/patterns/[patterns] within the graph, that is, how these nodes are related to each other.\n\n=== All Tom Hanks movies\n\nTo list the movies Tom Hanks have been part of, you need to query his `Person` node and how it is connected to the `Movie` nodes through a relationship.\n\n[source, cypher]\n--\nMATCH (tom:Person {name: \"Tom", "cypher_examples": [], "node_labels": ["ACTED", "DIRECTED", "FOLLOWS", "Movie", "PRODUCED", "Person", "REVIEWED", "WROTE"], "relationship_types": ["ACTED_IN", "DIRECTED", "FOLLOWS", "PRODUCED", "REVIEWED", "WROTE"], "source_file": "modules\\ROOT\\pages\\cypher\\intro-tutorial.adoc", "authority_level": 1}
{"name": "Refining results", "description": "This guide describes how to refine the results from Cypher queries.", "when_to_use": "Keep learning\n\nCypher has many other resources for refining query results.\nIf you want to keep learning, see the following pages:\n\n. link:https://neo4j.com/docs/cypher-manual/current/queries/composed-queries/[Composed queries] -> See how to use `UNION`, `WHEN`, and `NEXT` to combine queries, create linear compositions and different query branches.\n. link:https://neo4j.com/docs/cypher-manual/current/clauses/skip/[`SKIP`] -> Defines from which row to start including the rows in the output.\n. link:", "anti_pattern": "Order\n\nIf you want to have the results ordered, you can use the clause link:https://neo4j.com/docs/cypher-manual/current/clauses/order-by/[`ORDER BY`] after the `RETURN` clause.\nFor example, to list how many years of experience each person has in descending order:\n\n[source, cypher]\n--\nMATCH (p:Person)\nRETURN p.yearsExperience AS yearsExperience\nORDER BY yearsExperience DESC\n--\n\nThis is the result:\n\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n\n| yearsExperience\n\n| null | null |", "cypher_examples": ["MATCH (p:Person)\nWHERE p.name =~ 'Jo.*'\nRETURN p.name"], "node_labels": ["ACTED", "Company", "DIRECTED", "IS", "LIKES", "Movie", "Person", "Technology", "WORKS"], "relationship_types": ["ACTED_IN", "DIRECTED", "IS_FRIENDS_WITH", "LIKES", "WORKS_FOR"], "source_file": "modules\\ROOT\\pages\\cypher\\results.adoc", "authority_level": 1}
{"name": "Defining a schema", "description": "This guide explains how to define a schema by using indexes and constraints.", "when_to_use": "Using constraints\n\nlink:https://neo4j.com/docs/cypher-manual/current/constraints/[Constraints] are used to make sure that the data adheres to the rules of the domain.\nThey can be property uniqueness, property existence, property type, or key constraints.\n\n[options=header,cols=\"1,4\"]\n|===\n\n| Constraint type\n| Description\n\n| link:https://neo4j.com/docs/cypher-manual/current/constraints/managing-constraints/#create-property-uniqueness-constraints[Property uniqueness]\n| Ensure that the combined prop", "anti_pattern": "Keep learning\n\nRefer to the Cypher documentation for more information on indexes and constraints:\n\n* link:https://neo4j.com/docs/cypher-manual/current/indexes/search-performance-indexes/[Search-performance indexes] -> See how to get quicker retrievals of exact matches between an index and the primary data storage.\n* link:https://neo4j.com/docs/cypher-manual/current/indexes/semantic-indexes/[Semantic indexes] -> Read more on how semantic indexes capture the semantic meaning or context of the data", "cypher_examples": [], "node_labels": ["ACTED", "Actor", "DIRECTED", "Director", "Movie", "Person"], "relationship_types": ["ACTED_IN", "DIRECTED"], "source_file": "modules\\ROOT\\pages\\cypher\\schema.adoc", "authority_level": 1}
{"name": "Subqueries in Cypher", "description": "Building on the previous Cypher guides, this guide shows how to write subqueries.", "when_to_use": "", "anti_pattern": "", "cypher_examples": ["CREATE (diana:Person {name: \"Diana\"})-[:LIKES]->(query:Technology {type: \"Query Languages\"})\nCREATE (melissa:Person {name: \"Melissa\", twitter: \"@melissa\"})-[:LIKES]->(query)\nCREATE (dan:Person {name: \"Dan\", twitter: \"@dan\", yearsExperience: 6})-[:LIKES]->(etl:Technology {type: \"Data ETL\"})<-[:LIKES]-(melissa)\nCREATE (xyz:Company {name: \"XYZ\"})<-[:WORKS_FOR]-(sally:Person {name: \"Sally\", yearsExperience: 4})-[:LIKES]->(integrations:Technology {type: \"Integrations\"})<-[:LIKES]-(dan)\nCREATE (sally)<-[:IS_FRIENDS_WITH]-(john:Person {name: \"John\", yearsExperience: 5, birthdate: \"1985-04-04\"})-[:LIKES]->(java:Technology {type: \"Java\"})\nCREATE (john)<-[:IS_FRIENDS_WITH]-(jennifer:Person {name: \"Jennifer\", twitter: \"@jennifer\", yearsExperience: 5, birthdate: \"1988-01-01\"})-[:LIKES]->(java)\nCREATE (john)-[:WORKS_FOR]->(xyz)\nCREATE (sally)<-[:IS_FRIENDS_WITH]-(jennifer)-[:IS_FRIENDS_WITH]->(melissa)\nCREATE (joe:Person {name: \"Joe\", birthdate: \"1988-08-08\"})-[:LIKES]->(query)\nCREATE (mark:Person {name: \"Mark\", twitter: \"@mark\"})\nCREATE (ann:Person {name: \"Ann\"})\nCREATE (x:Company {name: \"Company X\"})<-[:WORKS_FOR]-(diana)<-[:IS_FRIENDS_WITH]-(joe)-[:IS_FRIENDS_WITH]->(mark)-[:LIKES]->(graphs:Technology {type: \"Graphs\"})<-[:LIKES]-(jennifer)-[:WORKS_FOR]->(:Company {name: \"Neo4j\"})\nCREATE (ann)<-[:IS_FRIENDS_WITH]-(jennifer)-[:IS_FRIENDS_WITH]->(mark)\nCREATE (john)-[:LIKES]->(:Technology {type: \"Application Development\"})<-[:LIKES]-(ann)-[:IS_FRIENDS_WITH]->(dan)-[:WORKS_FOR]->(abc:Company {name: \"ABC\"})\nCREATE (ann)-[:WORKS_FOR]->(abc)\nCREATE (a:Company {name: \"Company A\"})<-[:WORKS_FOR]-(melissa)-[:LIKES]->(graphs)<-[:LIKES]-(diana)\nCREATE (:Technology {type: \"Python\"})<-[:LIKES]-(:Person {name: \"Ryan\"})-[:WORKS_FOR]->(:Company {name: \"Company Z\"})", "MATCH (p:Person)-[r:IS_FRIENDS_WITH]->(friend:Person)\nWHERE exists((p)-[:WORKS_FOR]->(:Company {name: 'Neo4j'}))\nRETURN p, r, friend", "MATCH (p:Person)-[r:IS_FRIENDS_WITH]->(friend:Person)\nWHERE EXISTS {\n  MATCH (p)-[:WORKS_FOR]->(:Company {name: 'Neo4j'})\n}\nRETURN p, r, friend", "MATCH (person:Person)-[:WORKS_FOR]->(company)\nWHERE company.name STARTS WITH \"Company\"\nAND (person)-[:LIKES]->(t:Technology)\nAND COUNT { (t)<-[:LIKES]-() } >= 3\nRETURN person.name as person, company.name AS company;", "MATCH (person:Person)-[:WORKS_FOR]->(company)\nWHERE company.name STARTS WITH \"Company\"\nAND EXISTS {\n  MATCH (person)-[:LIKES]->(t:Technology)\n  WHERE COUNT { (t)<-[:LIKES]-() } >= 3\n}\nRETURN person.name as person, company.name AS company;", "MATCH (p:Person)-[:LIKES]->(:Technology {type: \"Java\"})\nRETURN p.name AS person, p.birthdate AS dob\nORDER BY dob DESC\n\nUNION\n\nMATCH (p:Person)\nWHERE COUNT { (p)-[:IS_FRIENDS_WITH]->() } > 1\nRETURN p.name AS person, p.birthdate AS dob\nORDER BY dob DESC;", "// Find people who like Java\nMATCH (p:Person)-[:LIKES]->(:Technology {type: \"Java\"})\nWITH collect(p) AS peopleWhoLikeJava\n\n// Find people with more than one friend\nMATCH (p:Person)\nWHERE COUNT { (p)-[:IS_FRIENDS_WITH]->() } > 1\nWITH collect(p) AS popularPeople, peopleWhoLikeJava\nWITH popularPeople + peopleWhoLikeJava AS people\n\n// Unpack the collection of people and order by birthdate\nUNWIND people AS p\nRETURN DISTINCT p.name AS person, p.birthdate AS dob\nORDER BY dob DESC", "CALL {\n\tMATCH (p:Person)-[:LIKES]->(:Technology {type: \"Java\"})\n\tRETURN p\n\n\tUNION\n\n\tMATCH (p:Person)\n\tWHERE COUNT { (p)-[:IS_FRIENDS_WITH]->() } > 1\n\tRETURN p\n}\nRETURN p.name AS person, p.birthdate AS dob\nORDER BY dob DESC;", "CALL {\n\tMATCH (p:Person)-[:LIKES]->(:Technology {type: \"Java\"})\n\tRETURN p\n\n\tUNION\n\n\tMATCH (p:Person)\n\tWHERE COUNT { (p)-[:IS_FRIENDS_WITH]->() } > 1\n\tRETURN p\n}\nWITH p,\n     [(p)-[:LIKES]->(t) | t.type] AS technologies,\n     [(p)-[:IS_FRIENDS_WITH]->(f) | f.name] AS friends\n\nRETURN p.name AS person, p.birthdate AS dob, technologies, friends\nORDER BY dob DESC;", "CALL {\n\tMATCH (p:Person)-[:LIKES]->(:Technology {type: \"Java\"})\n\tRETURN p\n\n\tUNION\n\n\tMATCH (p:Person)\n\tWHERE COUNT { (p)-[:IS_FRIENDS_WITH]->() } > 1\n\tRETURN p\n}\nRETURN min(p.birthdate) AS oldest, max(p.birthdate) AS youngest"], "node_labels": ["Company", "IS", "LIKES", "Person", "Technology", "WORKS"], "relationship_types": ["IS_FRIENDS_WITH", "LIKES", "WORKS_FOR"], "source_file": "modules\\ROOT\\pages\\cypher\\subqueries.adoc", "authority_level": 1}
{"name": "Updating the graph", "description": "This guide explains how to update data that already exists in a graph, using Cypher.", "when_to_use": "Conclusion\n\nIn this tutorial, you have seen how to update nodes, relationships, and properties. \nYou have also seen how to delete data from the graph as well as how to avoid duplication when adding new data.", "anti_pattern": "Conclusion\n\nIn this tutorial, you have seen how to update nodes, relationships, and properties. \nYou have also seen how to delete data from the graph as well as how to avoid duplication when adding new data.", "cypher_examples": ["MATCH (:Person {name: 'Jennifer'})-[rel:WORKS_FOR]-(:Company {name: 'Neo4j'})\nSET rel.startYear = date({year: 2018})\nRETURN rel", "MATCH (a:Person {name: 'Ann'})\nMATCH (m:Person {name: 'Mark'})\nMERGE (a)-[r:IS_FRIENDS_WITH]->(m)\nRETURN a, r, m"], "node_labels": ["Company", "IS", "LIKES", "Person", "Technology", "WORKS"], "relationship_types": ["IS_FRIENDS_WITH", "LIKES", "WORKS_FOR"], "source_file": "modules\\ROOT\\pages\\cypher\\updating.adoc", "authority_level": 1}
{"name": "Working with CSV files", "description": "This page gives an overview of what is a dataset in CSV format and how to work with it when importing it into Neo4j.", "when_to_use": "Optimization\n\nPerformance can be a problem when working with large amounts of data or complex loading.\nSome strategies can, however, improve the processing of large amounts of information.\n\nFor example, if you want to create a graph using xref:#_null_values[the preceding *companies.csv* file] and the following one:\n\n.people.csv\n[source]\n----\nemployeeId,Name,companyId\n1,Bob Smith,1\n2,Joe Jones,3\n3,Susan Scott,2\n4,Karen White,1\n----\n\nIn this case, you should separate node and relationship creation", "anti_pattern": "File preparation\n\nBefore you import CSV data you should consider the *source* of the data.\nIt can come from:\n\n* Relational databases\n* Web APIs\n* Public data directories\n* BI tools\n* Speadsheets (e.g. Excel or Google Sheets)\n\nMost data systems have an option for exporting data as CSV files as it is a common format for data exchange.\nHowever, real-world data is often messy, which means some values need to be cleaned up or transformed before imported to another system.\n\nThese are some common issue", "cypher_examples": [], "node_labels": ["Company", "Employee", "HAS", "Java", "JavaScript", "Skill", "WORKS"], "relationship_types": ["WORKS_FOR"], "source_file": "modules\\ROOT\\pages\\data-import\\csv-files.adoc", "authority_level": 1}
{"name": "Tutorial: Import data from a relational database into Neo4j", "description": "This tutorial shows the process for exporting data from a relational database (PostgreSQL) and importing into a graph database (Neo4j). You will learn how to take data from the relational system and to the graph by translating the schema and using import tools.", "when_to_use": "Creating the indexes and constraints for the data in the graph\n\nAfter the nodes are created, you need to create the relationships between them.\nImporting the relationships will mean looking up the nodes you just created and adding a relationship between those existing entities.\nTo ensure the lookup of nodes is optimized, you will create indexes for any node properties used in the lookups (often the ID or another unique value).\n\nWe also want to create a constraint (also creates an index with it)", "anti_pattern": "Creating the relationships between the nodes\n\nNext you have to create relationships:\n\n. Between Orders and Employees.\n. Between Products and Suppliers and between Products and Categories.\n. Between Employees.\n\n=== Creating relationships between Orders and Employees\n\nWith the initial nodes and indexes in place, you can now create the relationships for orders to products and orders to employees.\n\nExecute this code block:\n\n[source, cypher]\n----\n// Create relationships between orders and products\nLO", "cypher_examples": ["// Create orders\nLOAD CSV WITH HEADERS FROM 'https://gist.githubusercontent.com/jexp/054bc6baf36604061bf407aa8cd08608/raw/8bdd36dfc88381995e6823ff3f419b5a0cb8ac4f/orders.csv' AS row\nMERGE (order:Order {orderID: row.OrderID})\n  ON CREATE SET order.shipName = row.ShipName;", "MATCH (o:Order) return o LIMIT 5;", "// Create products\nLOAD CSV WITH HEADERS FROM 'https://gist.githubusercontent.com/jexp/054bc6baf36604061bf407aa8cd08608/raw/8bdd36dfc88381995e6823ff3f419b5a0cb8ac4f/products.csv' AS row\nMERGE (product:Product {productID: row.ProductID})\n  ON CREATE SET product.productName = row.ProductName, product.unitPrice = toFloat(row.UnitPrice);", "MATCH (p:Product) return p LIMIT 5;", "// Create suppliers\nLOAD CSV WITH HEADERS FROM 'https://gist.githubusercontent.com/jexp/054bc6baf36604061bf407aa8cd08608/raw/8bdd36dfc88381995e6823ff3f419b5a0cb8ac4f/suppliers.csv' AS row\nMERGE (supplier:Supplier {supplierID: row.SupplierID})\n  ON CREATE SET supplier.companyName = row.CompanyName;", "MATCH (s:Supplier) return s LIMIT 5;", "// Create employees\nLOAD CSV WITH HEADERS FROM 'https://gist.githubusercontent.com/jexp/054bc6baf36604061bf407aa8cd08608/raw/8bdd36dfc88381995e6823ff3f419b5a0cb8ac4f/employees.csv' AS row\nMERGE (e:Employee {employeeID:row.EmployeeID})\n  ON CREATE SET e.firstName = row.FirstName, e.lastName = row.LastName, e.title = row.Title;", "MATCH (e:Employee) return e LIMIT 5;", "// Create categories\nLOAD CSV WITH HEADERS FROM 'https://gist.githubusercontent.com/jexp/054bc6baf36604061bf407aa8cd08608/raw/8bdd36dfc88381995e6823ff3f419b5a0cb8ac4f/categories.csv' AS row\nMERGE (c:Category {categoryID: row.CategoryID})\n  ON CREATE SET c.categoryName = row.CategoryName, c.description = row.Description;", "MATCH (c:Category) return c LIMIT 5;"], "node_labels": ["Andrew", "Aniseed", "Beverages", "Breads", "Buchanan", "CONTAINS", "Category", "Chai", "Chang", "Cheeses", "Chef", "Condiments", "Confections", "Cooperativa", "Dairy", "Davolio", "Desserts", "Employee", "Exotic", "Fuller", "Grains", "Grandma", "Hanari", "Janet", "Leverling", "Margaret", "Nancy", "New", "Northwind", "Order", "PART", "Peacock", "Product", "REPORTS", "SOLD", "SUPPLIES", "Sales", "Soft", "Steven", "Supplier", "Supr", "Sweet", "Tokyo", "Toms", "Vice", "Victuailles", "Vins"], "relationship_types": ["CONTAINS", "PART_OF", "REPORTS_TO", "SOLD", "SUPPLIES"], "source_file": "modules\\ROOT\\pages\\data-import\\import-relational-and-etl.adoc", "authority_level": 1}
{"name": "Import: RDBMS to graph", "description": "This article shows the different ways you can import data from a relational database to Neo4j. Completing this guide will give you the tools to choose how to import your relational data and transform it to the graph.", "when_to_use": "ETL Tool\n\nNeo4j's ETL tool provides a simple GUI that allows you to load data from nearly any type of relational database to a Neo4j instance.\nThe process has you set up a JDBC connection to nearly any type of relational database, then does some auto-mapping to a graph data model rendered as a visualization that you can edit to your use case.\nFinally, you can choose whether the load occurs on a running or shutdown Neo4j instance and import the data.\n\nThis tool provides a simple, straightforward", "anti_pattern": "", "cypher_examples": [], "node_labels": [], "relationship_types": [], "source_file": "modules\\ROOT\\pages\\data-import\\relational-to-graph-import.adoc", "authority_level": 1}
{"name": "Modeling designs", "description": "This page features examples of graph data modeling patterns and designs that are commonly used with Neo4j.", "when_to_use": "Linked list\n\nLinked lists are commonly used in computer science and they are particularly useful whenever the sequence of objects matters.\nA *simple-linked list* is where each node links to the next node only:\n\nimage::simple-linked-list.svg[Episodes of Dr Who linked in sequence with next relationships,width=500,role=popup]\n\nIn a *double-linked list*, each node links both to the next and the previous node:\n\nimage::double-linked-list.svg[Episodes of Dr Who doubly linked with next and previous rela", "anti_pattern": "Intermediate nodes\n\nIntermediary nodes are nodes that contain data that need to be in the graph but don't seem to fit neatly into the initial model.\n\nSometimes you need to convey a lot of information in a relationship.\nIn a mathematical graph, this can be solved with a *hyperedge*, i.e. a relationship that connects more than two nodes.\nThis is not supported in Neo4j but can be solved by using an intermediary node.\n\nFor example, consider a person who works at a company and you need to convey info", "cypher_examples": [], "node_labels": ["Company", "Person", "WORKED"], "relationship_types": [], "source_file": "modules\\ROOT\\pages\\data-modeling\\modeling-designs.adoc", "authority_level": 1}
{"name": "Modeling: relational to graph", "description": "For those with a background in relational data modeling, this guide helps transfer your existing knowledge of the processes and components used for relational data modeling into graph data modeling.", "when_to_use": "Relational and graph architecture\n\nAs a quick overview, remember that relational databases rely upon index lookups and table joins to connect different entities.\nThis quickly becomes a problem for performance, especially when there are several tables joined, millions of rows on tables, or complex queries that traverse various levels through subqueries.\n\nIn our example from the concepts page, to find which departments Alice works for, you would need to query the `Person` table to find the row rep", "anti_pattern": "", "cypher_examples": [], "node_labels": [], "relationship_types": [], "source_file": "modules\\ROOT\\pages\\data-modeling\\relational-to-graph-modeling.adoc", "authority_level": 1}
{"name": "Tutorial: Create a graph data model", "description": "This tutorial is designed to help you understand how data modeling works through an example use case.", "when_to_use": "Test the model\n\nAfter populating the graph to implement the data model with a small set of test data, you should now test it to ensure that it satisfies every xref:#_define_the_use_case[use case].\n\nFor example, if you want to test the use case \"Which people acted in a movie?\", you can run the following query:\n\n[source,cypher]\n--\nMATCH (p:Person)-[:ACTED_IN]-(m:Movie)\nWHERE m.title = 'Sleepless in Seattle'\nRETURN p.name\n--\n\nThis is just a simple example of testing.\nAs you go through the use cases", "anti_pattern": "", "cypher_examples": [], "node_labels": ["ACTED", "DIRECTED", "Movie", "Person", "RATED", "User"], "relationship_types": ["ACTED_IN", "DIRECTED", "RATED"], "source_file": "modules\\ROOT\\pages\\data-modeling\\tutorial-data-modeling.adoc", "authority_level": 1}
{"name": "Tutorial: Refactor a graph data model", "description": "This tutorial teaches you how to refactor your graph data model.", "when_to_use": "Retest the graph\n\nAfter you have refactored the graph, you should revisit all queries for your xref:data-modeling/tutorial-data-modeling.adoc#_define_the_use_case[use cases] and determine whether any of them can be rewritten to take advantage of the refactoring.\nHere is a list:\n\n[options=header,cols=\"1,1a\"]\n|===\n\n| Use case\n| Query example\n\n| Which people acted in a movie?\n| [source,cypher]\n--\nMATCH (p:Person)-[:ACTED_IN]->(m:Movie {title:'Hoffa'})\nRETURN p\n--\n\n| Which person directed a movie?\n|", "anti_pattern": "Using specific relationships\n\nSpecific relationships are a refactor strategy that you can use when your project has a recurrent use case that needs a certain piece of information to be constantly retrieved.\nThe benefits of using them include:\n\n* Reducing the number of nodes that need to be retrieved.\n* Improving query performance.\n\nSuppose that you frequently need to retrieve information about actors in reference to the year 1995.\nThe query for that could be:\n\n[source,cypher]\n--\nMATCH (p:Person)", "cypher_examples": [], "node_labels": ["ACTED", "DIRECTED", "IN", "Language", "Movie", "PRODUCED", "Person", "ProductionCompany", "RATED", "User"], "relationship_types": ["ACTED_IN", "ACTED_IN_", "DIRECTED", "IN_LANGUAGE", "PRODUCED", "RATED"], "source_file": "modules\\ROOT\\pages\\data-modeling\\tutorial-refactoring.adoc", "authority_level": 1}
{"name": "Versioning", "description": "See what options of graph data model versioning are commonly used in combination with Neo4j.", "when_to_use": "Timeline tree\n\nAs mentioned in xref:data-modeling/modeling-designs.adoc[Modeling designs], the timeline tree is a common modeling design.\nIt can be a useful strategy when you want to track change.\nIn this example, the timeline structure spans from years to days, and the rest of the non-time data nodes are the nodes that contain the important pieces of data in the graph:\n\nimage::timeline-tree.svg[Graph with two different timeslines divided in years, months, and days and what purchases are connect", "anti_pattern": "Time-based versioning of entities\n\nA variation of the entity versioning is a time-based approach.\nIt is useful when you are interested in:\n\n* *Graph snapshot* by retrieving all valid elements (nodes and relationships) of the graph to a specific point in time (e.g. which products are available on Monday the 12.06.23).\n* *Graph difference* by comparing two graph snashots of different time stamps (e.g. which nodes are added, which are deleted, and which remain the same).\n* *Temporal traversal* by t", "cypher_examples": [], "node_labels": ["HAS", "IN", "LAST", "LATEST", "Month", "NEXT", "OCCURRED", "ON", "Product", "Purchase", "State", "Timeline", "Year"], "relationship_types": ["IN_MONTH", "IN_YEAR", "LAST", "LATEST", "NEXT", "OCCURRED", "ON_DAY", "V"], "source_file": "modules\\ROOT\\pages\\data-modeling\\versioning.adoc", "authority_level": 1}
