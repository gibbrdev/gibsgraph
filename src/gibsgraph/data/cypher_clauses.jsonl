{"name": "CALL procedure", "description": "The `CALL` clause is used to call a procedure deployed in the database.", "syntax_examples": ["CREATE (andy:Developer {name: 'Andy', born: 1991}),\n       (beatrice:Developer {name: 'Beatrice', born: 1985}),\n       (charlotte:Administrator {name: 'Charlotte', born: 1990}),\n       (david:Administrator {name: 'David', born: 1994, nationality: 'Swedish'}),\n       (andy)-[:KNOWS]->(beatrice),\n       (beatrice)-[:KNOWS]->(charlotte),\n       (andy)-[:KNOWS]->(david)", "CALL db.labels()", "CALL dbms.checkConfigValue('server.bolt.enabled', 'true')", "CALL dbms.checkConfigValue($setting, $value)", "CALL dbms.checkConfigValue($setting, 'true')", "CALL db.labels() YIELD *", "CALL db.labels() YIELD *\nRETURN count(*) AS results", "SHOW PROCEDURES YIELD name, signature\nWHERE name = 'db.propertyKeys'\nRETURN signature", "CALL db.propertyKeys() YIELD propertyKey AS prop\nMATCH (n)\nWHERE n[prop] IS NOT NULL\nRETURN prop, count(n) AS numNodes", "MATCH (n)\nCALL apoc.neighbors.tohop(n, \"KNOWS>\", 1)\nYIELD node\nRETURN n.name AS name, collect(node.name) AS connections"], "sections": [{"heading": "Example graph", "content": "The following graph is used for the examples below:\n\nimage::call-procedure.svg[Example graph connecting people in the roles of developer and administrator,role=popup,width=400]\n\nTo recreate it, run the following query against an empty Neo4j database:\n\n[source, cypher, role=test-setup]\n----\nCREATE (andy:Developer {name: 'Andy', born: 1991}),\n       (beatrice:Developer {name: 'Beatrice', born: 1985}),\n       (charlotte:Administrator {name: 'Charlotte', born: 1990}),\n       (david:Administrator {name: 'David', born: 1994, nationality: 'Swedish'}),\n       (andy)-[:KNOWS]->(beatrice),\n       (beatrice)-[:KNOWS]->(charlotte),\n       (andy)-[:KNOWS]->(david)\n----\n\n[[call-procedure-examples]]"}, {"heading": "Examples", "content": ".`CALL` a procedure without arguments\n====\n\nThis example calls the built-in procedure link:{neo4j-docs-base-uri}/operations-manual/current/procedures/#procedure_db_labels[`db.labels()`], which lists all labels used in the database.\n\n.Query\n[source, cypher]\n----\nCALL db.labels()\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| label\n\n| \"Developer\"\n| \"Administrator\"\n\n1+d|Rows: 2\n|===\n\n====\n\n[NOTE]\nIt is best practice to use parentheses when calling procedures, although Cypher allows for their omission when calling procedures of arity-0 (no arguments).\nOmission of parentheses is available only in a so-called standalone procedure call, when the whole query consists of a single `CALL` clause.\n\n\n.`CALL` a procedure without arguments\n====\n\n\nThis example calls the procedure link:{neo4j-docs-base-uri}/operations-manual/current/procedures/#procedure_dbms_checkConfigValue[`dbms.checkConfigValue()`], which checks the validity of a configuration setting value, using literal arguments.\n\n.Query\n[source, cypher]\n----\nCALL dbms.checkConfigValue('server.bolt.enabled', 'true')\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| \"valid\" | \"message\"\n| true | \"requires restart\"\n\n2+d|Rows: 1\n|===\n\n====\n\n.`CALL` a procedure using parameters\n====\n\nThis calls the example procedure `dbms.checkConfigValue()` using parameters as arguments.\nEach procedure argument is taken to be the value of a corresponding statement parameter with the same name (or null if no such parameter has been given).\n\n.Parameters\n[source, parameters]\n----\n{\n  \"setting\": \"server.bolt.enabled\",\n  \"value\": \"true\"\n}\n----\n\n.Query\n[source, cypher]\n----\nCALL dbms.checkConfigValue($setting, $value)\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| \"valid\" | \"message\"\n| true | \"requires restart\"\n\n2+d|Rows: 1\n|===\n\n[NOTE]\nExamples that use parameter arguments shows the given parameters in JSON format; the exact manner in which they are to be submitted depends upon the driver being used.\nSee xref::syntax/parameters.adoc[] for more about querying with parameters.\n\n====\n\n\n.`CALL` a procedure using both literal and parameter arguments\n====\n\nThis calls the example procedure `dbms.checkConfigValue()` using both literal and parameter arguments.\n\n.Parameters\n[source, parameters]\n----\n{\n  \"setting\": \"server.bolt.enabled\"\n}\n----\n\n.Query\n[source, cypher]\n----\nCALL dbms.checkConfigValue($setting, 'true')\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| \"valid\" | \"message\"\n| true | \"requires restart\"\n\n2+d|Rows: 1\n|===\n\n====\n\n\n[[call-procedure-yield]]"}, {"heading": "Using `YIELD`", "content": "The `YIELD` keyword is used to specify which columns of procedure metadata to return, allowing for the selection and filtering of the displayed information.\n\n.`YIELD *`\n====\n\nUsing `YIELD *` will return all available return columns for a procedure.\n\n.Query\n[source, cypher]\n----\nCALL db.labels() YIELD *\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| label\n\n| \"Administrator\"\n| \"Developer\"\n\n1+d|Rows: 2\n|===\n\nIf the procedure has deprecated return columns, those columns are also returned.\n\nNote that `YIELD *` is only valid in standalone procedure calls.\nVariables must be explicitly named in a `YIELD` clause if other clauses than a single procedure `CALL` are present.\nThis restriction simplifies query logic and protects against output variables from the procedure accidentally clashing with other query variables.\nFor example, the following is not valid:\n\n.Not allowed\n[source, cypher, role=test-fail]\n----\nCALL db.labels() YIELD *\nRETURN count(*) AS results\n----\n\n====\n\n.`YIELD` specific procedure results and filter on them\n====\n\n`YIELD` can be used to filter for specific results.\nThis requires knowing the names of the arguments within a procedure's signature, which can either be found in the link:{neo4j-docs-base-uri}/operations-manual/current/procedures/[Operations Manual -> Procedures] or in the `signature` column returned by a `SHOW PROCEDURES` command (see example below).\n\n.Find the argument names of `db.propertyKeys()`\n[source, cypher]\n----\nSHOW PROCEDURES YIELD name, signature\nWHERE name = 'db.propertyKeys'\nRETURN signature\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1m\"]\n|===\n| signature\n\n| \"db.propertyKeys() :: (propertyKey :: STRING)\"\n\n1+d|Rows: 1\n|===\n\nIt is then possible to use these argument names for further query filtering.\nNote that if the procedure call is part of a larger query, its output must be named explicitly.\nIn the below example, `propertyKey` is aliased as `prop` and then used later in the query to xref:functions/aggregating.adoc#functions-count[count] the occurrence of each property in the graph.\n\n.Filter on specific argument returned by `YIELD`\n[source, cypher]\n----\nCALL db.propertyKeys() YIELD propertyKey AS prop\nMATCH (n)\nWHERE n[prop] IS NOT NULL\nRETURN prop, count(n) AS numNodes\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| prop | numNodes\n\n| \"name\" | 4\n| \"born\" | 4\n| \"nationality\" | 1\n\n2+d|Rows: 3\n|===\n\n===="}, {"heading": "Note on VOID procedures", "content": "Neo4j supports the notion of `VOID` procedures.\nA `VOID` procedure is a procedure that does not declare any result fields and returns no result records.\n`VOID` procedure only produces side-effects and does not allow for the use of `YIELD`.\nCalling a `VOID` procedure in the middle of a larger query will simply pass on each input record (i.e., it acts like xref:clauses/with.adoc[`WITH *`] in terms of the record stream).\n\n\n[[optional-call]]"}, {"heading": "Optional procedure calls", "content": "`OPTIONAL CALL` allows for an optional procedure call.\nSimilar to xref:clauses/optional-match.adoc[`OPTIONAL MATCH`] any empty rows produced by the `OPTIONAL CALL` will return `null`.\n\n.Difference between using `CALL` and `OPTIONAL CALL`\n====\n\nThis query uses the link:{neo4j-docs-base-uri}/apoc/current/overview/apoc.neighbors/apoc.neighbors.tohop[`apoc.neighbors.tohop()`] procedure (part of Neo4j's link:{neo4j-docs-base-uri}/apoc/current/[APOC Core library]), which returns all nodes connected by the given relationship type within the specified distance (1 hop, in this case) and direction.\n\n.Regular procedure `CALL`\n[source, cypher]\n----\nMATCH (n)\nCALL apoc.neighbors.tohop(n, \"KNOWS>\", 1)\nYIELD node\nRETURN n.name AS name, collect(node.name) AS connections\n----\n\nNote that the result does not include the nodes in the graph without any outgoing `KNOWS` relationships connected to them.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| name | connections\n\n| \"Andy\"\n| [\"Beatrice\", \"David\"]\n\n| \"Beatrice\"\n| [\"Charlotte\"]\n\n2+d|Rows: 2\n|===\n\nThe same query is used below, but `CALL` is replaced with `OPTIONAL CALL`.\n\n.Optional procedure `CALL`\n[source, cypher]\n----\nMATCH (n)\nOPTIONAL CALL apoc.neighbors.tohop(n, \"KNOWS>\", 1)\nYIELD node\nRETURN n.name AS name, collect(node.name) AS connections\n----\n\nThe result now includes the two nodes without any outgoing `KNOWS` relationships connected to them.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| name | connections\n\n| \"Andy\"\n| [\"Beatrice\", \"David\"]\n\n| \"Beatrice\"\n| [\"Charlotte\"]\n\n| \"Charlotte\"\n| []\n\n| \"David\"\n| []\n\n2+d|Rows: 4\n|===\n\n===="}], "source_file": "modules\\ROOT\\pages\\clauses\\call.adoc", "authority_level": 1}
{"name": "Clause composition", "description": "This section describes the semantics of Cypher when composing different read and write clauses.", "syntax_examples": ["MATCH (john:Person {name: 'John'})\nMATCH (john)-[:FRIEND]->(friend)\nRETURN friend.name AS friendName", "MATCH (j:Person {name: 'John'})-[:FRIEND]->(f)\nSET f.degreesFromJohn = 1\nMATCH (f)-[:FRIEND]->(f2)\nSET f2.degreesFromJohn = f.degreesFromJohn + 1\nRETURN f.name AS friendName, \n       f.degreesFromJohn AS friendDegree, \n       f2.name AS friendOfFriendName, \n       f2.degreesFromJohn AS friendOfFriendDegree", "MATCH (j:Person) WHERE j.name STARTS WITH \"J\"\nCREATE (j)-[:FRIEND]->(jj:Person {name: \"Jay-jay\"})", "UNWIND [\"Max\", \"Lune\"] AS dogName\nCREATE (n:Dog {name: dogName})\nWITH n\nMATCH (d:Dog)\nRETURN COUNT(*)", "CREATE (jj:Person {name: \"Jay-jay\"})\nRETURN count(*) AS count\n  UNION\nMATCH (j:Person) WHERE j.name STARTS WITH \"J\"\nRETURN count(*) AS count", "MATCH (john:Person {name: 'John'})\nSET john.friends = []\nWITH john\nMATCH (john)-[:FRIEND]->(friend)\nWITH john, friend\nCALL (john, friend) {\n  WITH john.friends AS friends\n  SET john.friends = friends + friend.name\n}"], "sections": [{"heading": "Read-write queries", "content": "In a Cypher query, read and write clauses can take turns.\nThe most important aspect of read-write queries is that the state of the graph also changes between clauses.\n\n[NOTE]\nA clause can never observe writes made by a later clause, and will observe all writes done by the previous clauses.\n\nAs of Cypher 25, read and write clauses can be combined in any order.\nThat is, a write clause followed by a read clause no longer requires a separating xref:clauses/with.adoc[`WITH`] clause in order for the read clause to observe the changes made by a preceding write clause.\nFor example, the following query, in which the changes made by a write clause (xref:clauses/set.adoc[`SET`]) are observed by a subsequent `MATCH` clause without an intermediate `WITH` clause, is valid using Cypher 25 but not link:https://neo4j.com/docs/cypher-manual/current/clauses/with[Cypher 5].\n\n\n.Combine write and read clauses without a separating `WITH` clause\n[source, cypher]\n----\nMATCH (j:Person {name: 'John'})-[:FRIEND]->(f)\nSET f.degreesFromJohn = 1\nMATCH (f)-[:FRIEND]->(f2)\nSET f2.degreesFromJohn = f.degreesFromJohn + 1\nRETURN f.name AS friendName, \n       f.degreesFromJohn AS friendDegree, \n       f2.name AS friendOfFriendName, \n       f2.degreesFromJohn AS friendOfFriendDegree\n----\n\n.Table of intermediate results and state of the graph between read and write clauses\n======\n\nUsing the same example graph as above, this example shows the table of intermediate results and the state of the graph after each clause for a query with a read clause before a write clause:\n\n[source,cypher, indent=0]\n----\nMATCH (j:Person) WHERE j.name STARTS WITH \"J\"\nCREATE (j)-[:FRIEND]->(jj:Person {name: \"Jay-jay\"})\n----\nThe query finds all nodes where the `name` property starts with \"J\"\nand for each such node it creates another node with  the `name` property set to \"Jay-jay\".\n\n\n.Read-write: The table of intermediate results and the state of the graph after each clause+\n[options=\"header\", width=\"100%\", cols=\"3a, 4a, 4a\"]\n|===\n\n| Clause\n| Table of intermediate results after the clause\n| State of the graph after the clause, changes in red\n\n| ----\nMATCH (j:Person) WHERE j.name STARTS WITH \"J\"\n----\n|\n[options=\"header\",cols=\"1m\"]\n!===\n! j\n! (:Person {name: 'John'})\n! (:Person {name: 'Joe'})\n!===\n|\n[graphviz]\n----\ndigraph L { node [shape=record style=rounded];\nN0 [\nlabel = \"{Person\\|name = \\'John\\'\\l}\"\n]\nN0 -> N3 [\ncolor = \"grey\"\nfontcolor = \"grey\"\nlabel = \"FRIEND\\n\"\n]\nN0 -> N1 [\ncolor = \"#2e3436\"\nfontcolor = \"#2e3436\"\nlabel = \"FRIEND\\n\"\n]\nN1 [\nlabel = \"{Person\\|name = \\'Joe\\'\\l}\"\n]\nN1 -> N2 [\ncolor = \"grey\"\nfontcolor = \"grey\"\nlabel = \"FRIEND\\n\"\n]\nN2 [\ncolor = \"grey\"\nfontcolor = \"grey\"\nlabel = \"{Person\\|name = \\'Steve\\'\\l}\"\n]\nN3 [\ncolor = \"grey\"\nfontcolor = \"grey\"\nlabel = \"{Person\\|name = \\'Sara\\'\\l}\"\n]\nN3 -> N4 [\ncolor = \"grey\"\nfontcolor = \"grey\"\nlabel = \"FRIEND\\n\"\n]\nN4 [\ncolor = \"grey\"\nfontcolor = \"grey\"\nlabel = \"{Person\\|name = \\'Maria\\'\\l}\"\n]\n}\n----\n\n| ----\nCREATE (j)-[:FRIEND]->(jj:Person {name: \"Jay-jay\"})\n----\n|\n[options=\"header\",cols=\"1m, 1m\"]\n!===\n! j                ! jj\n! (:Person {name: 'John'}) ! (:Person {name: 'Jay-jay'})\n! (:Person {name: 'Joe'})  ! (:Person {name: 'Jay-jay'})\n!===\n|\n\n[graphviz]\n----\ndigraph L { node [shape=record style=rounded];\nN0 [\nlabel = \"{Person\\|name = \\'John\\'\\l}\"\n]\nN0 -> N3 [\ncolor = \"#2e3436\"\nfontcolor = \"#2e3436\"\nlabel = \"FRIEND\\n\"\n]\nN0 -> N1 [\ncolor = \"#2e3436\"\nfontcolor = \"#2e3436\"\nlabel = \"FRIEND\\n\"\n]\nN1 [\nlabel = \"{Person\\|name = \\'Joe\\'\\l}\"\n]\nN1 -> N2 [\ncolor = \"#2e3436\"\nfontcolor = \"#2e3436\"\nlabel = \"FRIEND\\n\"\n]\nN2 [\nlabel = \"{Person\\|name = \\'Steve\\'\\l}\"\n]\nN3 [\nlabel = \"{Person\\|name = \\'Sara\\'\\l}\"\n]\nN3 -> N4 [\ncolor = \"#2e3436\"\nfontcolor = \"#2e3436\"\nlabel = \"FRIEND\\n\"\n]\nN4 [\nlabel = \"{Person\\|name = \\'Maria\\'\\l}\"\n]\nN0 -> N5 [\ncolor = \"red\"\nfontcolor = \"red\"\nlabel = \"FRIEND\\n\"\n]\nN5 [\ncolor = \"red\"\nfontcolor = \"red\"\nlabel = \"{Person\\|name = \\'Jay-jay\\'\\l}\"\n]\nN1 -> N6 [\ncolor = \"red\"\nfontcolor = \"red\"\nlabel = \"FRIEND\\n\"\n]\nN6 [\ncolor = \"red\"\nfontcolor = \"red\"\nlabel = \"{Person\\|name = \\'Jay-jay\\'\\l}\"\n]\n}\n----\n|===\n\nIt is important to note that the `MATCH` clause does not find the `Person` nodes that are created by the `CREATE` clause,\neven though the name \"Jay-jay\" starts with \"J\".\nThis is because the `CREATE` clause comes after the `MATCH` clause and thus the `MATCH` can not observe any changes to\nthe graph made by the `CREATE`.\n\n======\n\n.Table of intermediate results and state of the graph between write and read clauses\n======\nOn an empty graph, this example shows the table of intermediate results and the state of the graph after each clause for a query with a write clause before a read clause:\n\n[source,cypher, indent=0]\n----\nUNWIND [\"Max\", \"Lune\"] AS dogName\nCREATE (n:Dog {name: dogName})\nWITH n\nMATCH (d:Dog)\nRETURN COUNT(*)\n----\nThis query creates two `Dog` nodes and returns the value `4`.\n\n.+Write-read: The table of intermediate results and the state of the graph after each clause+\n[options=\"header\", width=\"100%\", cols=\"3a, 4a, 4a\"]\n|===\n\n| Clause\n| Table of intermediate results after the clause\n| State of the graph after the clause, changes in red\n\n| ----\nUNWIND [\"Max\", \"Luna\"] AS dogName\n----\n|\n[options=\"header\",cols=\"1m\"]\n!===\n! dogName\n! \"Max\"\n! \"Luna\"\n!===\n|\n\n| ----\nCREATE (n:Dog {name: dogName})\n----\n|\n[options=\"header\",cols=\"1m, 1m\"]\n!===\n! dogName         ! n\n! \"Max\"           ! (:Dog {name: 'Max'})\n! \"Luna\"          ! (:Dog {name: 'Luna'})\n!===\n|\n\n[graphviz]\n----\ndigraph L { node [shape=record style=rounded];\nN5 [\ncolor = \"red\"\nfontcolor = \"red\"\nlabel = \"{Dog\\|name = \\'Max\\'\\l}\"\n]\nN6 [\ncolor = \"red\"\nfontcolor = \"red\"\nlabel = \"{Dog\\|name = \\'Luna\\'\\l}\"\n]\n}\n----\n\n| ----\nMATCH (d:Dog)\n----\n|\n[options=\"header\",cols=\"1m, 1m, 1m\"]\n!===\n! dogName  ! n                     ! d\n! \"Max\"    ! (:Dog {name: 'Max'})  ! (:Dog {name: 'Max'})\n! \"Max\"    ! (:Dog {name: 'Max'})  ! (:Dog {name: 'Luna'})\n! \"Luna\"   ! (:Dog {name: 'Luna'}) ! (:Dog {name: 'Max'})\n! \"Luna\"   ! (:Dog {name: 'Luna'}) ! (:Dog {name: 'Luna'})\n!===\n|\n\n[graphviz]\n----\ndigraph L { node [shape=record style=rounded];\nN5 [\nlabel = \"{Dog\\|name = \\'Max\\'\\l}\"\n]\nN6 [\nlabel = \"{Dog\\|name = \\'Luna\\'\\l}\"\n]\n}\n----\n|===\n\nIt is important to note that the `MATCH` clause reads all the `Dog` nodes that are created by the `CREATE` clause.\nThis is because the `CREATE` clause comes before the `MATCH` clause and thus the `MATCH` observes all changes to\nthe graph made by the `CREATE`.\nThe `MATCH` clause is performed for every intermediate result, this leads to finding two nodes for both intermediate results.\n\n======\n\n[[cypher-clause-composition-union-queries]]"}, {"heading": "Queries with `UNION`", "content": "xref::queries/composed-queries/combined-queries.adoc[`UNION`] queries are slightly different because the results of two or more queries are put together,\nbut each query starts with an empty table of intermediate results.\n\nIn a query with a `UNION` clause, any clause _before_ the `UNION` cannot observe writes made by a clause _after_ the `UNION`.\nAny clause _after_ `UNION` can observe all writes made by a clause _before_ the `UNION`.\nThis means that the rule that a clause can never observe writes made by a later clause still applies in queries using `UNION`.\n\n.Table of intermediate results and state of the graph in a query with `UNION`\n======\nUsing the same example graph as above, this example shows the table of intermediate results and the state of the graph after each clause for the following query:\n\n[source,cypher, indent=0]\n----\nCREATE (jj:Person {name: \"Jay-jay\"})\nRETURN count(*) AS count\n  UNION\nMATCH (j:Person) WHERE j.name STARTS WITH \"J\"\nRETURN count(*) AS count\n----\n\n.+The table of intermediate results and the state of the graph after each clause+\n[options=\"header\", width=\"100%\", cols=\"3a, 4a, 4a\"]\n|===\n\n| Clause\n| Table of intermediate results after the clause\n| State of the graph after the clause, changes in red\n\n| ----\nCREATE (jj:Person {name: \"Jay-jay\"})\n----\n|\n[options=\"header\",cols=\"1m\"]\n!===\n! jj\n! (:Person {name: 'Jay-jay'})\n!===\n|\n\n[graphviz]\n----\ndigraph L { node [shape=record style=rounded];\nN0 [\nlabel = \"{Person\\|name = \\'John\\'\\l}\"\n]\nN0 -> N3 [\ncolor = \"#2e3436\"\nfontcolor = \"#2e3436\"\nlabel = \"FRIEND\\n\"\n]\nN0 -> N1 [\ncolor = \"#2e3436\"\nfontcolor = \"#2e3436\"\nlabel = \"FRIEND\\n\"\n]\nN1 [\nlabel = \"{Person\\|name = \\'Joe\\'\\l}\"\n]\nN1 -> N2 [\ncolor = \"#2e3436\"\nfontcolor = \"#2e3436\"\nlabel = \"FRIEND\\n\"\n]\nN2 [\nlabel = \"{Person\\|name = \\'Steve\\'\\l}\"\n]\nN3 [\nlabel = \"{Person\\|name = \\'Sara\\'\\l}\"\n]\nN3 -> N4 [\ncolor = \"#2e3436\"\nfontcolor = \"#2e3436\"\nlabel = \"FRIEND\\n\"\n]\nN4 [\nlabel = \"{Person\\|name = \\'Maria\\'\\l}\"\n]\nN5 [\ncolor = \"red\"\nfontcolor = \"red\"\nlabel = \"{Person\\|name = \\'Jay-jay\\'\\l}\"\n]\n}\n----\n| ----\nRETURN count(*) AS count\n----\n|\n[options=\"header\",cols=\"1m\"]\n!===\n! count\n! 1\n!===\n|\n\n[graphviz]\n----\ndigraph L { node [shape=record style=rounded];\nN0 [\nlabel = \"{Person\\|name = \\'John\\'\\l}\"\n]\nN0 -> N3 [\ncolor = \"#2e3436\"\nfontcolor = \"#2e3436\"\nlabel = \"FRIEND\\n\"\n]\nN0 -> N1 [\ncolor = \"#2e3436\"\nfontcolor = \"#2e3436\"\nlabel = \"FRIEND\\n\"\n]\nN1 [\nlabel = \"{Person\\|name = \\'Joe\\'\\l}\"\n]\nN1 -> N2 [\ncolor = \"#2e3436\"\nfontcolor = \"#2e3436\"\nlabel = \"FRIEND\\n\"\n]\nN2 [\nlabel = \"{Person\\|name = \\'Steve\\'\\l}\"\n]\nN3 [\nlabel = \"{Person\\|name = \\'Sara\\'\\l}\"\n]\nN3 -> N4 [\ncolor = \"#2e3436\"\nfontcolor = \"#2e3436\"\nlabel = \"FRIEND\\n\"\n]\nN4 [\nlabel = \"{Person\\|name = \\'Maria\\'\\l}\"\n]\nN5 [\nlabel = \"{Person\\|name = \\'Jay-jay\\'\\l}\"\n]\n}\n----\n| ----\nMATCH (j:Person) WHERE j.name STARTS WITH \"J\"\n----\n|\n[options=\"header\",cols=\"1m\"]\n!===\n! j\n! (:Person {name: 'John'})\n! (:Person {name: 'Joe'})\n! (:Person {name: 'Jay-jay'})\n!===\n|\n[graphviz]\n----\ndigraph L { node [shape=record style=rounded];\nN0 [\nlabel = \"{Person\\|name = \\'John\\'\\l}\"\n]\nN0 -> N3 [\ncolor = \"grey\"\nfontcolor = \"grey\"\nlabel = \"FRIEND\\n\"\n]\nN0 -> N1 [\ncolor = \"#2e3436\"\nfontcolor = \"#2e3436\"\nlabel = \"FRIEND\\n\"\n]\nN1 [\nlabel = \"{Person\\|name = \\'Joe\\'\\l}\"\n]\nN1 -> N2 [\ncolor = \"grey\"\nfontcolor = \"grey\"\nlabel = \"FRIEND\\n\"\n]\nN2 [\ncolor = \"grey\"\nfontcolor = \"grey\"\nlabel = \"{Person\\|name = \\'Steve\\'\\l}\"\n]\nN3 [\ncolor = \"grey\"\nfontcolor = \"grey\"\nlabel = \"{Person\\|name = \\'Sara\\'\\l}\"\n]\nN3 -> N4 [\ncolor = \"grey\"\nfontcolor = \"grey\"\nlabel = \"FRIEND\\n\"\n]\nN4 [\ncolor = \"grey\"\nfontcolor = \"grey\"\nlabel = \"{Person\\|name = \\'Maria\\'\\l}\"\n]\nN5 [\nlabel = \"{Person\\|name = \\'Jay-jay\\'\\l}\"\n]\n}\n----\n| ----\nRETURN count(*) AS count\n----\n|\n[options=\"header\",cols=\"1m\"]\n!===\n! count\n! 3\n!===\n|\n\n[graphviz]\n----\ndigraph L { node [shape=record style=rounded];\nN0 [\nlabel = \"{Person\\|name = \\'John\\'\\l}\"\n]\nN0 -> N3 [\ncolor = \"#2e3436\"\nfontcolor = \"#2e3436\"\nlabel = \"FRIEND\\n\"\n]\nN0 -> N1 [\ncolor = \"#2e3436\"\nfontcolor = \"#2e3436\"\nlabel = \"FRIEND\\n\"\n]\nN1 [\nlabel = \"{Person\\|name = \\'Joe\\'\\l}\"\n]\nN1 -> N2 [\ncolor = \"#2e3436\"\nfontcolor = \"#2e3436\"\nlabel = \"FRIEND\\n\"\n]\nN2 [\nlabel = \"{Person\\|name = \\'Steve\\'\\l}\"\n]\nN3 [\nlabel = \"{Person\\|name = \\'Sara\\'\\l}\"\n]\nN3 -> N4 [\ncolor = \"#2e3436\"\nfontcolor = \"#2e3436\"\nlabel = \"FRIEND\\n\"\n]\nN4 [\nlabel = \"{Person\\|name = \\'Maria\\'\\l}\"\n]\nN5 [\nlabel = \"{Person\\|name = \\'Jay-jay\\'\\l}\"\n]\n}\n----\n\n|===\n\nIt is important to note that the `MATCH` clause finds the `Person` node that is created by the `CREATE` clause.\nThis is because the `CREATE` clause comes before the `MATCH` clause and thus the `MATCH` can observe any changes to\nthe graph made by the `CREATE`.\n\n======\n\n[[cypher-clause-composition-call-queries]]"}, {"heading": "Queries with `CALL {}` subqueries", "content": "Subqueries inside a xref::subqueries/call-subquery.adoc[`CALL {}`] clause are evaluated for each incoming input row.\nThis means that write clauses inside a subquery can get executed more than once.\nThe different invocations of the subquery are executed in turn, in the order of the incoming input rows.\n\nLater invocations of the subquery can observe writes made by earlier invocations of the subquery.\n\n.Table of intermediate results and state of the graph in a query with `CALL {}`\n======\nUsing the same example graph as above, this example shows the table of intermediate results and the state of the graph after each clause for the following query:\n\n[NOTE]\nThe below query uses a xref:subqueries/call-subquery.adoc#variable-scope-clause[variable scope clause] to import variables into the `CALL` subquery.\n\n[source,cypher]\n----\nMATCH (john:Person {name: 'John'})\nSET john.friends = []\nWITH john\nMATCH (john)-[:FRIEND]->(friend)\nWITH john, friend\nCALL (john, friend) {\n  WITH john.friends AS friends\n  SET john.friends = friends + friend.name\n}\n----\n\n.+The table of intermediate results and the state of the graph after each clause+\n[options=\"header\", width=\"100%\", cols=\"3a, 4a, 4a\"]\n|===\n\n| Clause\n| Table of intermediate results after the clause\n| State of the graph after the clause, changes in red\n|----\nMATCH (john:Person {name: 'John'})\n----\n|\n[options=\"header\",cols=\"1m\"]\n!===\n! john\n! (:Person {name: 'John'})\n!===\n|\n[graphviz]\n----\ndigraph L { node [shape=record style=rounded];\nN0 [\nlabel = \"{Person\\|name = \\'John\\'\\l}\"\n]\nN0 -> N3 [\ncolor = \"grey\"\nfontcolor = \"grey\"\nlabel = \"FRIEND\\n\"\n]\nN0 -> N1 [\ncolor = \"grey\"\nfontcolor = \"grey\"\nlabel = \"FRIEND\\n\"\n]\nN1 [\n\ncolor = \"grey\"\nfontcolor = \"grey\"\nlabel = \"{Person\\|name = \\'Joe\\'\\l}\"\n]\nN1 -> N2 [\ncolor = \"grey\"\nfontcolor = \"grey\"\nlabel = \"FRIEND\\n\"\n]\nN2 [\ncolor = \"grey\"\nfontcolor = \"grey\"\nlabel = \"{Person\\|name = \\'Steve\\'\\l}\"\n]\nN3 [\ncolor = \"grey\"\nfontcolor = \"grey\"\nlabel = \"{Person\\|name = \\'Sara\\'\\l}\"\n]\nN3 -> N4 [\ncolor = \"grey\"\nfontcolor = \"grey\"\nlabel = \"FRIEND\\n\"\n]\nN4 [\ncolor = \"grey\"\nfontcolor = \"grey\"\nlabel = \"{Person\\|name = \\'Maria\\'\\l}\"\n]\n}\n----\n|----\nSET john.friends = []\n----\n|\n[options=\"header\",cols=\"1m\"]\n!===\n! john\n! (:Person {name: 'John', friends: []})\n!===\n|\n[graphviz]\n----\ndigraph L { node [shape=record style=rounded];\nN0 [\ncolor = \"red\"\nfontcolor = \"red\"\nlabel = \"{Person\\|name = \\'John\\'\\l\\|friends = []\\l}\"\n]\nN0 -> N3 [\nlabel = \"FRIEND\\n\"\n]\nN0 -> N1 [\ncolor = \"#2e3436\"\nfontcolor = \"#2e3436\"\nlabel = \"FRIEND\\n\"\n]\nN1 [\nlabel = \"{Person\\|name = \\'Joe\\'\\l}\"\n]\nN1 -> N2 [\nlabel = \"FRIEND\\n\"\n]\nN2 [\nlabel = \"{Person\\|name = \\'Steve\\'\\l}\"\n]\nN3 [\nlabel = \"{Person\\|name = \\'Sara\\'\\l}\"\n]\nN3 -> N4 [\nlabel = \"FRIEND\\n\"\n]\nN4 [\nlabel = \"{Person\\|name = \\'Maria\\'\\l}\"\n]\n}\n----\n\n\n|----\nMATCH (john)-[:FRIEND]->(friend)\n----\n|\n[options=\"header\",cols=\"1m, 1m\"]\n!===\n! john             ! friend\n! (:Person {name: 'John', friends: []}) ! (:Person {name: 'Sara'})\n! (:Person {name: 'John', friends: []}) ! (:Person {name: 'Joe'})\n!===\n|\n[graphviz]\n----\ndigraph L { node [shape=record style=rounded];\nN0 [\nlabel = \"{Person\\|name = \\'John\\'\\l\\|friends = []\\l}\"\n]\nN0 -> N3 [\nlabel = \"FRIEND\\n\"\n]\nN0 -> N1 [\ncolor = \"#2e3436\"\nfontcolor = \"#2e3436\"\nlabel = \"FRIEND\\n\"\n]\nN1 [\nlabel = \"{Person\\|name = \\'Joe\\'\\l}\"\n]\nN1 -> N2 [\ncolor = \"grey\"\nfontcolor = \"grey\"\nlabel = \"FRIEND\\n\"\n]\nN2 [\ncolor = \"grey\"\nfontcolor = \"grey\"\nlabel = \"{Person\\|name = \\'Steve\\'\\l}\"\n]\nN3 [\nlabel = \"{Person\\|name = \\'Sara\\'\\l}\"\n]\nN3 -> N4 [\ncolor = \"grey\"\nfontcolor = \"grey\"\nlabel = \"FRIEND\\n\"\n]\nN4 [\ncolor = \"grey\"\nfontcolor = \"grey\"\nlabel = \"{Person\\|name = \\'Maria\\'\\l}\"\n]\n}\n----\n\n| First invocation of\n----\nWITH john.friends AS friends\n----\n|\n[options=\"header\",cols=\"2m, 1m, 1m\"]\n!===\n! john                          ! friend           ! friends\n! (:Person {name: 'John', friends: []}) ! (:Person {name: 'Sara'}) ! []\n!===\n|\n[graphviz]\n----\ndigraph L { node [shape=record style=rounded];\nN0 [\nlabel = \"{Person\\|name = \\'John\\'\\l\\|friends = []\\l}\"\n]\nN0 -> N3 [\nlabel = \"FRIEND\\n\"\n]\nN0 -> N1 [\ncolor = \"#2e3436\"\nfontcolor = \"#2e3436\"\nlabel = \"FRIEND\\n\"\n]\nN1 [\nlabel = \"{Person\\|name = \\'Joe\\'\\l}\"\n]\nN1 -> N2 [\nlabel = \"FRIEND\\n\"\n]\nN2 [\nlabel = \"{Person\\|name = \\'Steve\\'\\l}\"\n]\nN3 [\nlabel = \"{Person\\|name = \\'Sara\\'\\l}\"\n]\nN3 -> N4 [\nlabel = \"FRIEND\\n\"\n]\nN4 [\nlabel = \"{Person\\|name = \\'Maria\\'\\l}\"\n]\n}\n----\n\n| First invocation of\n----\nSET john.friends = friends + friend.name\n----\n\n|[options=\"header\",cols=\"2m, 1m, 1m\"]\n!===\n! john                                ! friend           ! friends\n! (:Person {name: 'John', friends: ['Sara']}) ! (:Person {name: 'Sara'}) ! []\n!===\n|\n[graphviz]\n----\ndigraph L { node [shape=record style=rounded];\nN0 [\ncolor = \"red\"\nfontcolor = \"red\"\nlabel = \"{Person\\|name = \\'John\\'\\l\\|friends = ['Sara']\\l}\"\n]\nN0 -> N3 [\nlabel = \"FRIEND\\n\"\n]\nN0 -> N1 [\ncolor = \"#2e3436\"\nfontcolor = \"#2e3436\"\nlabel = \"FRIEND\\n\"\n]\nN1 [\nlabel = \"{Person\\|name = \\'Joe\\'\\l}\"\n]\nN1 -> N2 [\nlabel = \"FRIEND\\n\"\n]\nN2 [\nlabel = \"{Person\\|name = \\'Steve\\'\\l}\"\n]\nN3 [\nlabel = \"{Person\\|name = \\'Sara\\'\\l}\"\n]\nN3 -> N4 [\nlabel = \"FRIEND\\n\"\n]\nN4 [\nlabel = \"{Person\\|name = \\'Maria\\'\\l}\"\n]\n}\n----\n\n| Second invocation of\n----\nWITH john.friends AS friends\n----\n|\n[options=\"header\",cols=\"2m, 1m, 1m\"]\n!===\n! john                                ! friend           ! friends\n! (:Person {name: 'John', friends: ['Sara']}) ! (:Person {name: 'Joe'}) ! ['Sara']\n!===\n|\n[graphviz]\n----\ndigraph L { node [shape=record style=rounded];\nN0 [\nlabel = \"{Person\\|name = \\'John\\'\\l\\|friends = ['Sara']\\l}\"\n]\nN0 -> N3 [\nlabel = \"FRIEND\\n\"\n]\nN0 -> N1 [\ncolor = \"#2e3436\"\nfontcolor = \"#2e3436\"\nlabel = \"FRIEND\\n\"\n]\nN1 [\nlabel = \"{Person\\|name = \\'Joe\\'\\l}\"\n]\nN1 -> N2 [\nlabel = \"FRIEND\\n\"\n]\nN2 [\nlabel = \"{Person\\|name = \\'Steve\\'\\l}\"\n]\nN3 [\nlabel = \"{Person\\|name = \\'Sara\\'\\l}\"\n]\nN3 -> N4 [\nlabel = \"FRIEND\\n\"\n]\nN4 [\nlabel = \"{Person\\|name = \\'Maria\\'\\l}\"\n]\n}\n----\n\n| Second invocation of\n----\nSET john.friends = friends + friend.name\n----\n\n|[options=\"header\",cols=\"2m, 1m, 1m\"]\n!===\n! john                                       ! friend           ! friends\n! (:Person {name: 'John', friends: ['Sara', 'Joe']}) ! (:Person {name: 'Joe'}) ! ['Sara']\n!===\n|\n[graphviz]\n----\ndigraph L { node [shape=record style=rounded];\nN0 [\ncolor = \"red\"\nfontcolor = \"red\"\nlabel = \"{Person\\|name = \\'John\\'\\l\\|friends = ['Sara', 'Joe']\\l}\"\n]\nN0 -> N3 [\nlabel = \"FRIEND\\n\"\n]\nN0 -> N1 [\ncolor = \"#2e3436\"\nfontcolor = \"#2e3436\"\nlabel = \"FRIEND\\n\"\n]\nN1 [\nlabel = \"{Person\\|name = \\'Joe\\'\\l}\"\n]\nN1 -> N2 [\nlabel = \"FRIEND\\n\"\n]\nN2 [\nlabel = \"{Person\\|name = \\'Steve\\'\\l}\"\n]\nN3 [\nlabel = \"{Person\\|name = \\'Sara\\'\\l}\"\n]\nN3 -> N4 [\nlabel = \"FRIEND\\n\"\n]\nN4 [\nlabel = \"{Person\\|name = \\'Maria\\'\\l}\"\n]\n}\n----\n|===\n\nIt is important to note that, in the subquery, the second invocation of the `WITH` clause could observe\nthe writes made by the first invocation of the `SET` clause.\n\n======\n\n[[cypher-clause-composition-implementation]]"}, {"heading": "Notes on the implementation", "content": "An easy way to implement the semantics outlined above is to fully execute each clause and\nmaterialize the table of intermediate results before executing the next clause.\nThis approach would consume a lot of memory for materializing the tables of intermediate results and would generally not perform well.\n\nInstead, Cypher will in general try to interleave the execution of clauses.\nThis is called xref::planning-and-tuning/execution-plans.adoc#lazy-eager-evaluation[lazy evaluation].\nIt only materializes intermediate results when needed.\nIn many read-write queries it is unproblematic to execute clauses interleaved, but when it is not,\nCypher must ensure that the table of intermediate results gets materialized at the right time(s).\nThis is done by inserting an xref::planning-and-tuning/operators/operators-detail.adoc#query-plan-eager[`Eager`] operator into the execution plan."}], "source_file": "modules\\ROOT\\pages\\clauses\\clause-composition.adoc", "authority_level": 1}
{"name": "CREATE", "description": "The `CREATE` clause is used to create nodes and relationships.", "syntax_examples": ["CREATE (charlie:Person:Actor {name: 'Charlie Sheen'}), (oliver:Person:Director {name: 'Oliver Stone'})", "CREATE (charlie:Person&Actor {name: 'Charlie Sheen'}), (oliver:Person&Director {name: 'Oliver Stone'})", "CREATE (charlie:Person:Actor {name: 'Charlie Sheen'})-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet:Movie {title: 'Wall Street'})<-[:DIRECTED]-(oliver:Person:Director {name: 'Oliver Stone'})", "MATCH (charlie:Person {name: 'Charlie Sheen'}), (oliver:Person {name: 'Oliver Stone'})\nCREATE (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet:Movie {title: 'Wall Street'})<-[:DIRECTED]-(oliver)", "CREATE p = (charlie:Person:Actor {name: 'Charlie Sheen'})-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet:Movie {title: 'Wall Street'})<-[:DIRECTED]-(oliver:Person:Director {name: 'Oliver Stone'}), (wallStreet)<-[:ACTED_IN {role: 'Gordon Gekko'}]-(michael:Person:Actor {name: 'Michael Douglas'})\nRETURN length(p)", "MATCH (charlie:Person {name: 'Charlie Sheen'})\nCREATE (charlie:Actor)", "MATCH (person:Person)\n  WHERE person.name IS NOT NULL\nCREATE (anotherPerson:Person {name: person.name, age: $age})", "CREATE (charlie {score: oliver.score + 1}), (oliver {score: charlie.score + 1})", "CREATE (n:Person $props)\nRETURN n", "UNWIND $props AS map\nCREATE (n)\nSET n = map"], "sections": [{"heading": "Introduction", "content": "The `CREATE` clause allows you to create nodes and relationships.\nTo define these entities, `CREATE` uses a syntax similar to that of xref::clauses/match.adoc[`MATCH`].\nHowever, while xref::patterns/index.adoc[patterns] only need to evaluate to either true or false, the syntax for `CREATE` needs to specify exactly what nodes and relationships to create.\n\n[[create-nodes]]"}, {"heading": "Syntax for nodes", "content": "The `CREATE` clause allows you to create one or more nodes.\nEach node can be assigned labels and properties.\nYou can bind each node to a variable that you can refer to later in the query.\nMultiple labels are separated by colons.\n\n.Query\n[source, cypher]\n----\nCREATE (charlie:Person:Actor {name: 'Charlie Sheen'}), (oliver:Person:Director {name: 'Oliver Stone'})\n----\n\nMultiple labels can also be separated by an ampersand `&`, in the same manner as it is used in xref:patterns/reference.adoc#label-expressions[label expressions].\nSeparation by colon `:` and ampersand `&` cannot be mixed in the same clause.\n\n.Query\n[source, cypher, indent=0]\n----\nCREATE (charlie:Person&Actor {name: 'Charlie Sheen'}), (oliver:Person&Director {name: 'Oliver Stone'})\n----\n\nBoth of the above queries create two nodes, bound to the variables `charlie` and `oliver`, each with a `Person` label and a `name` property.\nThe node representing Charlie Sheen also has the label `Actor` while the node representing Oliver Stone is assigned the label `Director`.\n\n[[create-relationships]]"}, {"heading": "Syntax for relationships", "content": "Relationships can also be created using the `CREATE` clause.\nUnlike nodes, relationships always need exactly one relationship type and a direction.\nSimilar to nodes, relationships can be assigned properties and relationship types and be bound to variables.\n\n.Query\n[source, cypher]\n----\nCREATE (charlie:Person:Actor {name: 'Charlie Sheen'})-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet:Movie {title: 'Wall Street'})<-[:DIRECTED]-(oliver:Person:Director {name: 'Oliver Stone'})\n----\n\nThis query creates the `Person` nodes for Charlie Sheen and Oliver Stone and the `Movie` node for Wall Street.\nIt also created the relationships of the types `ACTED_IN` and `DIRECTED` between them.\n\n[[reusing-variables]]"}, {"heading": "Reusing variables", "content": "The previous example created a path between the specified nodes.\nNote, that these newly created nodes and relationships are not connected to what was previously in the graph.\nTo connect them to already existing data, bind the desired nodes and relationships to variables.\nThese variables can then be passed along to subsequent clauses in a query that target pre-existing elements in the graph.\n\n.Query\n[source, cypher]\n----\nMATCH (charlie:Person {name: 'Charlie Sheen'}), (oliver:Person {name: 'Oliver Stone'})\nCREATE (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet:Movie {title: 'Wall Street'})<-[:DIRECTED]-(oliver)\n----\n\nIn this example, the `MATCH` clause finds the nodes Charlie Sheen and Oliver Stone and binds them to the `charlie` and `oliver` variables respectively.\nThese variables are then passed along to the subsequent `CREATE` clause, which creates new relationships from the bound nodes.\n\nYou can also reuse variables from the same `CREATE`, both in the same or a later clause.\nThis way, you can, for example, define constructs that are more complex than just a linear path.\n\n.Query\n[source, cypher]\n----\nCREATE p = (charlie:Person:Actor {name: 'Charlie Sheen'})-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet:Movie {title: 'Wall Street'})<-[:DIRECTED]-(oliver:Person:Director {name: 'Oliver Stone'}), (wallStreet)<-[:ACTED_IN {role: 'Gordon Gekko'}]-(michael:Person:Actor {name: 'Michael Douglas'})\nRETURN length(p)\n----\n\nCreates all three nodes for Charlie Sheen, Oliver Stone and Michael Douglas and connects them all to the node representing the Wall Street movie.\nIt then returns the length of the path from Charlie Sheen to Oliver Stone.\n\nNote that when repeating a node's variable, you may not add labels or properties to the repetition.\n\n.Query\n[source, cypher, role=test-fail]\n----\nMATCH (charlie:Person {name: 'Charlie Sheen'})\nCREATE (charlie:Actor)\n----\n\nThis query will fail because the variable `charlie` has already been bound to a pre-existing node, and therefore it cannot be reused to create a new node.\nIf you intend to add a label, use the xref:clauses/set.adoc#set-set-a-label-on-a-node[`SET` clause] instead.\n\n[[reusing-variables-properties]]"}, {"heading": "Reusing variables in properties", "content": "The value that can be assigned to a node's or a relationship's property can be defined by an xref::syntax/expressions.adoc[expression].\n\n////\n.Parameters\n[source, json, role=test-setup]\n----\n{\n  \"age\": 23\n}\n----\n////\n\n.Query\n[source, cypher]\n----\nMATCH (person:Person)\n  WHERE person.name IS NOT NULL\nCREATE (anotherPerson:Person {name: person.name, age: $age})\n----\n\nThis example created a `Person` node with the same name as another person and the age from a xref:syntax/parameters.adoc[parameter] called `age`.\n\nSuch an expression may not contain a reference to a variable that is defined in the same `CREATE` statement.\nThis is to ensure that the value of a property is always clear.\n\n.Query\n[source, cypher, role=test-fail]\n----\nCREATE (charlie {score: oliver.score + 1}), (oliver {score: charlie.score + 1})\n----\n\nThis query tries to create nodes such that Charlie's score is higher than Oliver's and vice versa, which is a contradiction.\nThe query therefore fails.\n\n[[use-parameters-with-create]]"}, {"heading": "Use parameters with `CREATE`", "content": "[[create-create-node-with-a-parameter-for-the-properties]]"}, {"heading": "Create node with a parameter for the properties", "content": "You can also create a graph entity from a map.\nAll the key/value pairs in the map will be set as properties on the created relationship or node.\nIn this case we add a `Person` label to the node as well.\n\n.Parameters\n[source, parameters]\n----\n{\n  \"props\": {\n    \"name\": \"Andy\",\n    \"position\": \"Developer\"\n  }\n}\n----\n\n.Query\n[source, cypher]\n----\nCREATE (n:Person $props)\nRETURN n\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| +n+\n| +Node[2]{name:\"Andy\",position:\"Developer\"}+\n1+d|Rows: 1 +\nNodes created: 1 +\nProperties set: 2 +\nLabels added: 1\n|===\n\n\n[[create-create-multiple-nodes-with-a-parameter-for-their-properties]]"}, {"heading": "Create multiple nodes with a parameter for their properties", "content": "By providing Cypher an array of maps, it will create a node for each map.\n\n.Parameters\n[source, parameters]\n----\n{\n  \"props\": [ {\n    \"name\": \"Andy\",\n    \"position\": \"Developer\"\n  }, {\n    \"name\": \"Michael\",\n    \"position\": \"Developer\"\n  } ]\n}\n----\n\n.Query\n[source, cypher]\n----\nUNWIND $props AS map\nCREATE (n)\nSET n = map\n----\n\n.Result\n[role=\"queryresult\",options=\"footer\",cols=\"1*<m\"]\n|===\n1+|(empty result)\n1+d|Rows: 0 +\nNodes created: 2 +\nProperties set: 4\n|===\n\n[[dynamic-create]]"}, {"heading": "CREATE using dynamic node labels and relationship types", "content": "Node labels and relationship types can be referenced dynamically in expressions, parameters, and variables when creating nodes and relationships.\nThis allows for more flexible queries and mitigates the risk of Cypher injection.\n(For more information about Cypher injection, see link:https://neo4j.com/developer/kb/protecting-against-cypher-injection/[Neo4j Knowledge Base -> Protecting against Cypher injection]).\n\n.Syntax for creating nodes and relationships dynamically\n[source, syntax]\n----\nCREATE (n:$(<expr>))\nCREATE ()-[r:$(<expr>)]->()\n----\n\nThe expression must evaluate to a `STRING NOT NULL | LIST<STRING NOT NULL> NOT NULL` value.\nUsing a `LIST<STRING>` with more than one item when creating a relationship using dynamic relationship types will fail.\nThis is because a relationship can only have exactly one type.\n\n.Parameters\n[source, parameters]\n----\n{\n  \"nodeLabels\": [\"Person\", \"Director\"],\n  \"relType\": \"DIRECTED\",\n  \"movies\": [\"Ladybird\", \"Little Women\", \"Barbie\"]\n}\n----\n\n.Create nodes and relationships using dynamic node labels and relationship types\n// tag::clauses_create_dynamic_create[]\n[source, cypher]\n----\nCREATE (greta:$($nodeLabels) {name: 'Greta Gerwig'})\nWITH greta\nUNWIND $movies AS movieTitle\nCREATE (greta)-[rel:$($relType)]->(m:Movie {title: movieTitle})\nRETURN greta.name AS name, labels(greta) AS labels, type(rel) AS relType, collect(m.title) AS movies\n----\n// end::clauses_create_dynamic_create[]\n\n.Result\n[role=\"queryresult\",options=\"footer\",cols=\"4*<m\"]\n|===\n| name | labels | relType | movies\n\n| \"Greta Gerwig\"\n| [\"Person\", \"Director\"]\n| \"DIRECTED\"\n| [\"Ladybird\", \"Little Women\", \"Barbie\"]\n4+d|Rows: 1 +\n|===\n\n[[insert-as-synonym-of-create]]"}, {"heading": "`INSERT` as a synonym of `CREATE`", "content": "`INSERT` can be used as a synonym to `CREATE` for creating nodes and relationships, and was introduced as part of Cypher's xref:appendix/gql-conformance/index.adoc[].\nHowever, `INSERT` requires that multiple labels are separated by an ampersand `&` and not by colon `:`. \nAdditionally, `INSERT` does not support using dynamic node labels and relationship types.\n\n.Query\n[source, cypher, indent=0]\n----\nINSERT (tom:Person&Actor&Director {name: 'Tom Hanks'})\n----\n\nCreates a node, bound to the variable `tom`, with the labels `Person`, `Actor`, and `Director` and a `name` property."}], "source_file": "modules\\ROOT\\pages\\clauses\\create.adoc", "authority_level": 1}
{"name": "DELETE", "description": "The `DELETE` clause is used to delete nodes, relationships or paths.", "syntax_examples": ["CREATE\n  (keanu:Person {name: 'Keanu Reever'}),\n  (laurence:Person {name: 'Laurence Fishburne'}),\n  (carrie:Person {name: 'Carrie-Anne Moss'}),\n  (tom:Person {name: 'Tom Hanks'}),\n  (theMatrix:Movie {title: 'The Matrix'}),\n  (keanu)-[:ACTED_IN]->(theMatrix),\n  (laurence)-[:ACTED_IN]->(theMatrix),\n  (carrie)-[:ACTED_IN]->(theMatrix)", "MATCH (n:Person {name: 'Tom Hanks'})\nDELETE n", "MATCH (n:Person {name: 'Tom Hanks'})\nNODETACH DELETE n", "MATCH (n:Person {name: 'Laurence Fishburne'})-[r:ACTED_IN]->()\nDELETE r", "MATCH (n:Person {name: 'Carrie-Anne Moss'})\nDETACH DELETE n", "MATCH (n)\nDETACH DELETE n", "MATCH (n)\nCALL (n) {\n DETACH DELETE n\n} IN TRANSACTIONS", "CREATE OR REPLACE DATABASE neo4j"], "sections": [{"heading": "Example graph", "content": "The following graph is used for the examples below. \nIt shows four actors, three of whom `ACTED_IN` the `Movie` `The Matrix` (`Keanu Reeves`, `Carrie-Anne Moss`, and `Laurence Fishburne`), and one actor who did not act in it (`Tom Hanks`).\n\nimage::graph-delete-clause.svg[Example graph connecting person nodes to a movie node and an extra person node not connected to the movie node via an acted in relationship,width=400,role=popup]\n\nTo recreate the graph, run the following query in an empty Neo4j database: \n\n[source, cypher, role=test-setup]\n----\nCREATE\n  (keanu:Person {name: 'Keanu Reever'}),\n  (laurence:Person {name: 'Laurence Fishburne'}),\n  (carrie:Person {name: 'Carrie-Anne Moss'}),\n  (tom:Person {name: 'Tom Hanks'}),\n  (theMatrix:Movie {title: 'The Matrix'}),\n  (keanu)-[:ACTED_IN]->(theMatrix),\n  (laurence)-[:ACTED_IN]->(theMatrix),\n  (carrie)-[:ACTED_IN]->(theMatrix)\n----\n\n[[delete-single-node]]"}, {"heading": "Delete single node", "content": "To delete a single node, use the `DELETE` clause:\n\n.Query\n[source, cypher, indent=0]\n----\nMATCH (n:Person {name: 'Tom Hanks'})\nDELETE n\n----\n\nThis deletes the `Person` node `Tom Hanks`.\nThis query is only possible to run on nodes without any relationships connected to them. \n\n.Result\n[role=\"queryresult\",options=\"footer\",cols=\"1*<m\"]\n----\nDeleted 1 node\n----\n\n\n[[delete-nodetach]]"}, {"heading": "NODETACH keyword", "content": "It is also possible to delete the single node using the `NODETACH DELETE` clause.\nUsing the `NODETACH` keyword explicitly defines that relationships will not be detached and deleted from a node.\nThe `NODETACH` keyword is a mirror of the already existing keyword xref:clauses/delete.adoc#delete-a-node-with-all-its-relationships[DETACH], and it was introduced as part of Cypher's xref:appendix/gql-conformance/index.adoc[].\nIncluding it is functionally the same as using simple `DELETE`.\n\n.Query\n[source, cypher]\n----\nMATCH (n:Person {name: 'Tom Hanks'})\nNODETACH DELETE n\n----\n\nThis also deletes the `Person` node `Tom Hanks`.\n\n[[delete-relationships-only]]"}, {"heading": "Delete relationships only", "content": "It is possible to delete a relationship while leaving the node(s) connected to that relationship otherwise unaffected.\n\n.Query\n[source, cypher, indent=0]\n----\nMATCH (n:Person {name: 'Laurence Fishburne'})-[r:ACTED_IN]->()\nDELETE r\n----\n\nThis deletes all outgoing `ACTED_IN` relationships from the `Person` node `Laurence Fishburne`, without deleting the node. \n\n.Result\n[role=\"queryresult\",options=\"footer\",cols=\"1*<m\"]\n----\nDeleted 1 relationship\n----\n\n\n[[delete-a-node-with-all-its-relationships]]"}, {"heading": "Delete a node with all its relationships", "content": "To delete nodes and any relationships connected them, use the `DETACH DELETE` clause.\n\n.Query\n[source, cypher, indent=0]\n----\nMATCH (n:Person {name: 'Carrie-Anne Moss'})\nDETACH DELETE n\n----\n\nThis deletes the `Person` node `Carrie-Anne Moss` and all relationships connected to it. \n\n.Result\n[role=\"queryresult\",options=\"footer\",cols=\"1*<m\"]\n----\nDeleted 1 node, deleted 1 relationship\n----\n\n[NOTE]\n====\nThe `DETACH DELETE` clause may not be permitted to users with restricted security privileges. \nFor more information, see link:{neo4j-docs-base-uri}/operations-manual/current/tutorial/access-control/#detach-delete-restricted-user[Operations Manual -> Fine-grained access control].\n====\n\n\n[[delete-all-nodes-and-relationships]]"}, {"heading": "Delete all nodes and relationships", "content": "It is possible to delete all nodes and relationships in a graph.\n\n.Delete all nodes and relationships\n[source, cypher, indent=0]\n----\nMATCH (n)\nDETACH DELETE n\n----\n\n.Result\n[role=\"queryresult\",options=\"footer\",cols=\"1*<m\"]\n----\nDeleted 3 nodes, deleted 1 relationship\n----\n\n`DETACH DELETE` is useful when experimenting with small example datasets, but it is not suitable for deleting large amounts of data, nor does it delete xref:indexes/search-performance-indexes/index.adoc[indexes] or any xref:schema/index.adoc[schema].\n\nTo delete large amounts of data without deleting indexes and any schema, use xref::subqueries/subqueries-in-transactions.adoc#delete-with-call-in-transactions[CALL subqueries in transactions] instead.\n\n.Delete all nodes and relationships using `CALL` subqueries\n[source, cypher]\n----\nMATCH (n)\nCALL (n) {\n DETACH DELETE n\n} IN TRANSACTIONS\n----\n\nTo remove all data, including indexes and constraints, recreate the database using the following command: `CREATE OR REPLACE DATABASE name`.\n\n.Delete a database and recreate it\n[source, cypher]\n----\nCREATE OR REPLACE DATABASE neo4j\n----\n\nFor more information, see the link:{neo4j-docs-base-uri}/operations-manual/current/database-administration/standard-databases/create-databases/#_create_databases_with_if_not_exists_or_or_replace[Operations Manual -> Create databases with `IF NOT EXISTS` or `OR REPLACE`]."}], "source_file": "modules\\ROOT\\pages\\clauses\\delete.adoc", "authority_level": 1}
{"name": "FILTER", "description": "Information about Cypher's `FILTER` clause.", "syntax_examples": ["CREATE (andy:Swedish:Person {name: 'Andy', age: 36}),\n       (timothy:Person {name: 'Timothy', age: 38}),\n       (peter:Person {name: 'Peter', age: 35}),\n       (lisa:Person {name: 'Lisa', age: 48}),\n       (john:Person {name: 'John', age: 40}),\n       (susan:Person {name: 'Susan', age: 32}),\n       (andy)-[:KNOWS {since: 2012}]->(timothy),\n       (andy)-[:KNOWS {since: 1999}]->(peter),\n       (peter)-[:KNOWS {since: 2005}]->(lisa),\n       (lisa)-[:KNOWS {since: 2010}]->(john),\n       (john)-[:KNOWS {since: 2021}]->(susan)", "MATCH (n)\nFILTER n:Swedish\nRETURN n.name AS name", "MATCH (n:Person)\nFILTER n.age < 35\nRETURN n.name AS name, n.age AS age", "MATCH (p:Person)-[r:KNOWS]->(n:Person)\nFILTER r.since > 2010\nRETURN p.name AS person,\n       r.since AS knowsSince,\n       n.name AS otherPerson", "MATCH (n)\nFILTER n:$($label)\nRETURN labels(n) AS labels", "MATCH (n:Person)\nFILTER n[$propname] > 40\nRETURN n.name AS name, n.age AS age", "UNWIND [32,37,40] AS ageValue\nOPTIONAL MATCH (p:Person) \nWHERE p.age = ageValue\nRETURN p.name AS name, p.age AS age", "UNWIND [32,37,40] AS ageValue\nOPTIONAL MATCH (p:Person) \nFILTER p.age = ageValue\nRETURN p.name AS name, p.age AS age", "WITH 35 AS minAge\nMATCH (a:Person WHERE a.name = 'Andy')-[:KNOWS]->(b:Person WHERE b.age > minAge)\nRETURN b.name AS name", "WITH 35 AS minAge\nMATCH (a:Person FILTER a.name = 'Andy')-[:KNOWS]->(b:Person FILTER b.age > minAge)\nRETURN b.name AS name"], "sections": [{"heading": "Example graph", "content": "The following graph is used for the examples below:\n\nimage::filter-clause.svg[Example graph with Person nodes connecting via knows relationships,width=700,role=popup]\n\nTo recreate the graph, run the following query in an empty Neo4j database:\n\n[source, cypher, role=test-setup]\n----\nCREATE (andy:Swedish:Person {name: 'Andy', age: 36}),\n       (timothy:Person {name: 'Timothy', age: 38}),\n       (peter:Person {name: 'Peter', age: 35}),\n       (lisa:Person {name: 'Lisa', age: 48}),\n       (john:Person {name: 'John', age: 40}),\n       (susan:Person {name: 'Susan', age: 32}),\n       (andy)-[:KNOWS {since: 2012}]->(timothy),\n       (andy)-[:KNOWS {since: 1999}]->(peter),\n       (peter)-[:KNOWS {since: 2005}]->(lisa),\n       (lisa)-[:KNOWS {since: 2010}]->(john),\n       (john)-[:KNOWS {since: 2021}]->(susan)\n----\n\n\n[[basic-filtering]]"}, {"heading": "Basic filtering", "content": ".Filter on a node label\n[source, cypher]\n----\nMATCH (n)\nFILTER n:Swedish\nRETURN n.name AS name\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| name\n\n| \"Andy\"\n\n1+|Rows: 1\n|===\n\n.Filter on a node property\n// tag::clauses_filter_node_property[]\n[source, cypher]\n----\nMATCH (n:Person)\nFILTER n.age < 35\nRETURN n.name AS name, n.age AS age\n----\n// end::clauses_filter_node_property[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| name | age\n\n| \"Susan\" | 32\n\n2+|Rows: 1\n|===\n\n.Filter on a relationship property\n[source, cypher]\n----\nMATCH (p:Person)-[r:KNOWS]->(n:Person)\nFILTER r.since > 2010\nRETURN p.name AS person,\n       r.since AS knowsSince,\n       n.name AS otherPerson\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"3*<m\"]\n|===\n| person | knowsSince | otherPerson\n\n| \"Andy\" | 2012       | \"Timothy\"\n| \"John\" | 2021       | \"Susan\"\n\n3+|Rows: 2\n|===\n\n[[filter-on-dynamic-labels-and-types]]"}, {"heading": "Filter on dynamic labels and types", "content": "To filter on a label or relationship type using a dynamically computed value, use `$(<expr>)` where <expr> is any Cypher expression:\n\n.Parameters\n[source, parameters]\n----\n{\n  \"label\": \"Swedish\"\n}\n----\n\n.Filter on a dynamically computed node label\n// tag::clauses_where_dynamic[]\n[source, cypher]\n----\nMATCH (n)\nFILTER n:$($label)\nRETURN labels(n) AS labels\n----\n// end::clauses_where_dynamic[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| labels\n| [\"Person\", \"Swedish\"]\n1+d|Rows: 1\n|===\n\n\n[[filter-on-dynamic-properties]]"}, {"heading": "Filter on dynamic properties", "content": "To filter on a property using a dynamically computed name, use square brackets `[]`:\n\n.Parameters\n[source, parameters]\n----\n{\n  \"propname\": \"age\"\n}\n----\n\n.Filter on a dynamically computed node property\n// tag::clauses_filter_dynamic[]\n[source, cypher]\n----\nMATCH (n:Person)\nFILTER n[$propname] > 40\nRETURN n.name AS name, n.age AS age\n----\n// end::clauses_filter_dynamic[]\n\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| name | age\n\n| \"Lisa\" | 48\n\n2+d|Rows: 1\n|===\n\n[[filter-where-differeces]]"}, {"heading": "Differences between `FILTER` and `WHERE`", "content": "`FILTER` and `WHERE` are both used to apply filter to queries.\nHowever, there are a number of important differences between them that arise from the fact that `FILTER` is a clause and `WHERE` is a subclause:\n\n* `FILTER` acts on entities _after_ they have been matched, whereas `WHERE` constrains what rows get matched _before_ the match is performed.\n* `FILTER` cannot be used within `MATCH`, `OPTIONAL MATCH`, or `WITH` clauses but only alongside them.\nThis means that, unlike `WHERE`, `FILTER` cannot be used to add filters inside patterns.\n\n.Distinction between `FILTER` and `WHERE`\n=====\n\nThis `OPTIONAL MATCH` example highlights the differences between the `WHERE` subclause and the `FILTER` clause.\n\n.`WHERE` constraining an `OPTIONAL MATCH` pattern\n[source, cypher]\n----\nUNWIND [32,37,40] AS ageValue\nOPTIONAL MATCH (p:Person) \nWHERE p.age = ageValue\nRETURN p.name AS name, p.age AS age\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| name | age\n\n| \"Susan\" | 32\n| NULL | NULL\n| \"John\" | 40\n\n2+d|Rows: 3\n|===\n\nBecause `WHERE` is a subclause belonging to `OPTIONAL MATCH`, it only filters the matches, but does not affect the number of returned rows.\nIn this case, `OPTIONAL MATCH` always keeps all rows from xref:clauses/unwind.adoc[`UNWIND`], and `WHERE` does not remove any rows returning `NULL`.\nThe same is not true if `WHERE` is exchanged for `FILTER`:\n\n.`FILTER` adding post-filtering to `OPTIONAL MATCH`\n[source, cypher]\n----\nUNWIND [32,37,40] AS ageValue\nOPTIONAL MATCH (p:Person) \nFILTER p.age = ageValue\nRETURN p.name AS name, p.age AS age\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| name | age\n\n| \"Susan\" | 32\n| \"John\" | 40\n\n2+d|Rows: 2\n|===\n\nUnlike `WHERE`, `FILTER` is not part of the `OPTIONAL MATCH` and so removes entire rows from the result set based on the condition provided within the expression.\nThat is, when `OPTIONAL MATCH` fails to find a match and `p` is `NULL`, `FILTER p.age = ageValue` cannot be evaluated, causing the entire row to be removed.\n\n=====\n\n.`FILTER` cannot be used within patterns\n=====\n\nBecause `WHERE` is a subclause qualifying a described pattern, it can be used inside patterns.\n\n.`WHERE` inside a node pattern\n[source, cypher]\n----\nWITH 35 AS minAge\nMATCH (a:Person WHERE a.name = 'Andy')-[:KNOWS]->(b:Person WHERE b.age > minAge)\nRETURN b.name AS name\n----\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| name\n\n| \"Timothy\"\n\n1+d|Rows: 1\n|===\n\nThe same is not true for `FILTER` which, as a clause, cannot be placed with a pattern.\n\n.Not allowed -- `FILTER` inside a pattern\n[source, cypher, role=test-fail]\n----\nWITH 35 AS minAge\nMATCH (a:Person FILTER a.name = 'Andy')-[:KNOWS]->(b:Person FILTER b.age > minAge)\nRETURN b.name AS name\n----\n\nFor more information about how to use `WHERE` in fixed-length and variable-length pattern matching, see xref:clauses/where.adoc#filter-patterns[`WHERE` -> Filter patterns].\n\n=====\n\n[[filter-with-where]]"}, {"heading": "`FILTER` as a substitute for `WITH * WHERE`", "content": "Unlike `WHERE`, which relies on `MATCH`, `OPTIONAL MATCH`, or `WITH` to define its scope, `FILTER` can filter queries independently of these clauses.\nThis can make some queries more concise.\n\nFor example, the following two queries are equivalent:\n\n.Filter using `WITH * WHERE`\n[source, cypher]\n----\nUNWIND [1, 2, 3, 4, 5, 6] AS x\nWITH x\nWHERE x > 2\nRETURN x\n----\n\n.Filter using `FILTER`\n[source, cypher]\n----\nUNWIND [1, 2, 3, 4, 5, 6] AS x\nFILTER x > 2\nRETURN x\n----\n\nAs such, `FILTER` can be seen as a substitute for the `WITH * WHERE <predicate>` constructs in Cypher.\n\n.Using `FILTER` instead of `WITH * WHERE` in `LOAD CSV`\n=====\n\nThe following two xref:clauses/load-csv.adoc[`LOAD CSV`] commands are equivalent:\n\n.companies.csv\n[source, csv, filename=\"companies.csv\"]\n----\nId,Name,Location,Email,BusinessType\n1,Neo4j,San Mateo,contact@neo4j.com,P\n2,AAA,,info@aaa.com,\n3,BBB,Chicago, info@ ,G\n,CCC,Michigan,info@ccc.com,G\n----\n\n.`LOAD CSV` using `WITH * WHERE`\n[source, cypher]\n----\nLOAD CSV WITH HEADERS FROM 'file:///companies.csv' AS row\nWITH row\nWHERE row.Id IS NOT NULL\nMERGE (c:Company {id: row.Id})\n----\n\n.`LOAD CSV` using `FILTER`\n// tag::clauses_filter_load_csv[]\n[source, cypher]\n----\nLOAD CSV WITH HEADERS FROM 'file:///companies.csv' AS row\nFILTER row.Id IS NOT NULL\nMERGE (c:Company {id: row.Id})\n----\n// end::clauses_filter_load_csv[]\n\n\n=====\n\nHowever, while `FILTER` can act as a substitute for `WITH * WHERE <predicate>` constructs, it does not include the ability of `WITH` to manipulate the variables in scope for subsequent clauses.\nNor can `FILTER` alias or create new variables.\nIn other words, `FILTER` only has the function of `WITH * WHERE <predicate>` and not `WITH <selectedVariable> AS <newVariableName> WHERE <predicate>`."}], "source_file": "modules\\ROOT\\pages\\clauses\\filter.adoc", "authority_level": 1}
{"name": "FINISH", "description": "The `FINISH` clause defines a query to have no result.", "syntax_examples": ["MATCH (p:Person)\nFINISH", "CREATE (p:Person)\nFINISH", "CREATE (p:Person)"], "sections": [], "source_file": "modules\\ROOT\\pages\\clauses\\finish.adoc", "authority_level": 1}
{"name": "FOREACH", "description": "The `FOREACH` clause is used to update data within a collection whether components of a path, or result of aggregation.", "syntax_examples": ["MATCH p=(start)-[*]->(finish)\nWHERE start.name = 'A' AND finish.name = 'D'\nFOREACH (n IN nodes(p) | SET n.marked = true)", "MATCH p=(start)-[*]->(finish)\nWHERE start.name = 'A' AND finish.name = 'D'\nFOREACH ( r IN relationships(p) | SET r.marked = true )", "WITH ['E', 'F', 'G'] AS names\nFOREACH ( value IN names | CREATE (:Person {name: value}) )"], "sections": [{"heading": "Mark all nodes along a path", "content": "This query sets the property `marked` to `true` on all nodes along a path.\n\n.Query\n// tag::clauses_foreach_node[]\n[source, cypher, indent=0]\n----\nMATCH p=(start)-[*]->(finish)\nWHERE start.name = 'A' AND finish.name = 'D'\nFOREACH (n IN nodes(p) | SET n.marked = true)\n----\n// end::clauses_foreach_node[]\n\n.Result\n[role=\"queryresult\",options=\"footer\",cols=\"1*<m\"]\n|===\n|(empty result)\nd|Rows: 0 +\nProperties set: 4\n|===\n\n\n[[foreach-mark-all-relationships-along-a-path]]"}, {"heading": "Mark all relationships along a path", "content": "This query sets the property `marked` to `true` on all relationships along a path.\n\n// tag::clauses_foreach_relationship[]\n[source, cypher, indent=0]\n----\nMATCH p=(start)-[*]->(finish)\nWHERE start.name = 'A' AND finish.name = 'D'\nFOREACH ( r IN relationships(p) | SET r.marked = true )\n----\n// end::clauses_foreach_relationship[]\n\n.Result\n[role=\"queryresult\",options=\"footer\",cols=\"1*<m\"]\n|===\n|(empty result)\nd|Rows: 0 +\nProperties set: 3\n|===\n\n[[foreach-create-new-nodes-form-a-list]]"}, {"heading": "Create new nodes from a list of name labels", "content": "This query creates a new node for each label in a list.\n\n.Query\n// tag::clauses_foreach_create[]\n[source, cypher, indent=0]\n----\nWITH ['E', 'F', 'G'] AS names\nFOREACH ( value IN names | CREATE (:Person {name: value}) )\n----\n// end::clauses_foreach_create[]\n\n.Result\n[role=\"queryresult\",options=\"footer\",cols=\"1*<m\"]\n|===\n1+|(empty result)\n1+d|Rows: 0 +\nNodes created: 3\n|==="}], "source_file": "modules\\ROOT\\pages\\clauses\\foreach.adoc", "authority_level": 1}
{"name": "LET", "description": "Information about Cypher's `LET` clause.", "syntax_examples": ["CREATE (techCorp:Supplier {name: 'TechCorp', email: 'contact@techcorp.com'}),\n       (foodies:Supplier {name: 'Foodies Inc.', email: 'info@foodies.com'}),\n             \n       (laptop:Product {name: 'Laptop', price: 1000}),\n       (phone:Product {name: 'Phone', price: 500}),\n       (headphones:Product {name: 'Headphones', price: 250}),\n       (chocolate:Product {name: 'Chocolate', price: 5}),\n       (coffee:Product {name: 'Coffee', price: 10}),\n             \n       (amir:Customer {firstName: 'Amir', lastName: 'Rahman', email: 'amir.rahman@example.com', discount: 0.1}),\n       (keisha:Customer {firstName: 'Keisha', lastName: 'Nguyen', email: 'keisha.nguyen@example.com', discount: 0.2}),\n       (mateo:Customer {firstName: 'Mateo', lastName: 'Ortega', email: 'mateo.ortega@example.com', discount: 0.05}),\n       (hannah:Customer {firstName: 'Hannah', lastName: 'Connor', email: 'hannah.connor@example.com', discount: 0.15}),\n       (leila:Customer {firstName: 'Leila', lastName: 'Haddad', email: 'leila.haddad@example.com', discount: 0.1}),\n       (niko:Customer {firstName: 'Niko', lastName: 'Petrov', email: 'niko.petrov@example.com', discount: 0.25}),\n       (yusuf:Customer {firstName: 'Yusuf', lastName: 'Abdi', email: 'yusuf.abdi@example.com', discount: 0.1}),\n\n       (amir)-[:BUYS {date: date('2024-10-09')}]->(laptop),\n       (amir)-[:BUYS {date: date('2025-01-10')}]->(chocolate),\n       (keisha)-[:BUYS {date: date('2023-07-09')}]->(headphones),\n       (mateo)-[:BUYS {date: date('2025-03-05')}]->(chocolate),\n       (mateo)-[:BUYS {date: date('2025-03-05')}]->(coffee),\n       (mateo)-[:BUYS {date: date('2024-04-11')}]->(laptop),\n       (hannah)-[:BUYS {date: date('2023-12-11')}]->(coffee),\n       (hannah)-[:BUYS {date: date('2024-06-02')}]->(headphones),\n       (leila)-[:BUYS {date: date('2023-05-17')}]->(laptop),\n       (niko)-[:BUYS {date: date('2025-02-27')}]->(phone),\n       (niko)-[:BUYS {date: date('2024-08-23')}]->(headphones),\n       (niko)-[:BUYS {date: date('2024-12-24')}]->(coffee),\n       (yusuf)-[:BUYS {date: date('2024-12-24')}]->(chocolate),\n       (yusuf)-[:BUYS {date: date('2025-01-02')}]->(laptop),\n        \n       (techCorp)-[:SUPPLIES]->(laptop),\n       (techCorp)-[:SUPPLIES]->(phone),\n       (techCorp)-[:SUPPLIES]->(headphones),\n       (foodies)-[:SUPPLIES]->(chocolate),\n       (foodies)-[:SUPPLIES]->(coffee)", "MATCH (c:Customer)\nLET fullName = c.firstName + ' ' + c.lastName\nRETURN fullName", "MATCH (s:Supplier)-[:SUPPLIES]->(p:Product)\nLET supplier = s.name, product = p.name\nRETURN supplier, product", "MATCH (s:Supplier)-[:SUPPLIES]->(p:Product)\nWITH s.name AS supplier\nRETURN supplier, p.name AS product", "MATCH (s:Supplier)-[:SUPPLIES]->(p:Product)\nLET supplier =  s.name\nRETURN supplier, p.name AS product", "MATCH (p:Product)\nLET isExpensive = p.price >= 500\nLET isAffordable = NOT isExpensive\nLET discountCategory = CASE \n    WHEN isExpensive THEN 'High-end'\n    ELSE 'Budget'\nEND\nRETURN p.name AS product, p.price AS price, isAffordable, discountCategory\nORDER BY price", "MATCH (p:Product)\nWITH p, p.price >= 500 AS isExpensive\nWITH p, isExpensive, NOT isExpensive AS isAffordable\nWITH p, isExpensive, isAffordable, \n     CASE \n         WHEN isExpensive THEN 'High-end' \n         ELSE 'Budget' \n     END AS discountCategory\nRETURN p.name AS product, p.price AS price, isAffordable, discountCategory\nORDER BY price", "MATCH (c:Customer)-[:BUYS]->(p:Product)\nWITH DISTINCT c, sum(p.price) AS totalSpent\nRETURN c.firstName AS customer, totalSpent", "MATCH (c:Customer)-[:BUYS]->(p:Product)\nWITH DISTINCT c, sum(p.price) AS totalSpent\nLET fullName = c.firstName + ' ' + c.lastName\nRETURN fullName, totalSpent", "MATCH (c:Customer)-[b:BUYS]->(p:Product)<--(s:Supplier)\nLET fullname = c.firstName + ' ' + c.lastName,\n    effectivePrice = p.price * (1 - c.discount)\nLET message = fullname + \" bought \" + p.name + \" for $\" + effectivePrice + \" after a \" + (c.discount * 100) + \"% discount\"\nRETURN b.date AS date, message, s.email AS toSupplier\nORDER BY date"], "sections": [{"heading": "Example graph", "content": "A graph with the following schema is used for the examples below:\n\nimage::let-graph.svg[Example graph connecting suppliers, products, and customers,width=600,role=popup]\n\nTo recreate the graph, run the following query against an empty Neo4j database.\n\n[source, cypher, role=test-setup]\n----\nCREATE (techCorp:Supplier {name: 'TechCorp', email: 'contact@techcorp.com'}),\n       (foodies:Supplier {name: 'Foodies Inc.', email: 'info@foodies.com'}),\n             \n       (laptop:Product {name: 'Laptop', price: 1000}),\n       (phone:Product {name: 'Phone', price: 500}),\n       (headphones:Product {name: 'Headphones', price: 250}),\n       (chocolate:Product {name: 'Chocolate', price: 5}),\n       (coffee:Product {name: 'Coffee', price: 10}),\n             \n       (amir:Customer {firstName: 'Amir', lastName: 'Rahman', email: 'amir.rahman@example.com', discount: 0.1}),\n       (keisha:Customer {firstName: 'Keisha', lastName: 'Nguyen', email: 'keisha.nguyen@example.com', discount: 0.2}),\n       (mateo:Customer {firstName: 'Mateo', lastName: 'Ortega', email: 'mateo.ortega@example.com', discount: 0.05}),\n       (hannah:Customer {firstName: 'Hannah', lastName: 'Connor', email: 'hannah.connor@example.com', discount: 0.15}),\n       (leila:Customer {firstName: 'Leila', lastName: 'Haddad', email: 'leila.haddad@example.com', discount: 0.1}),\n       (niko:Customer {firstName: 'Niko', lastName: 'Petrov', email: 'niko.petrov@example.com', discount: 0.25}),\n       (yusuf:Customer {firstName: 'Yusuf', lastName: 'Abdi', email: 'yusuf.abdi@example.com', discount: 0.1}),\n\n       (amir)-[:BUYS {date: date('2024-10-09')}]->(laptop),\n       (amir)-[:BUYS {date: date('2025-01-10')}]->(chocolate),\n       (keisha)-[:BUYS {date: date('2023-07-09')}]->(headphones),\n       (mateo)-[:BUYS {date: date('2025-03-05')}]->(chocolate),\n       (mateo)-[:BUYS {date: date('2025-03-05')}]->(coffee),\n       (mateo)-[:BUYS {date: date('2024-04-11')}]->(laptop),\n       (hannah)-[:BUYS {date: date('2023-12-11')}]->(coffee),\n       (hannah)-[:BUYS {date: date('2024-06-02')}]->(headphones),\n       (leila)-[:BUYS {date: date('2023-05-17')}]->(laptop),\n       (niko)-[:BUYS {date: date('2025-02-27')}]->(phone),\n       (niko)-[:BUYS {date: date('2024-08-23')}]->(headphones),\n       (niko)-[:BUYS {date: date('2024-12-24')}]->(coffee),\n       (yusuf)-[:BUYS {date: date('2024-12-24')}]->(chocolate),\n       (yusuf)-[:BUYS {date: date('2025-01-02')}]->(laptop),\n        \n       (techCorp)-[:SUPPLIES]->(laptop),\n       (techCorp)-[:SUPPLIES]->(phone),\n       (techCorp)-[:SUPPLIES]->(headphones),\n       (foodies)-[:SUPPLIES]->(chocolate),\n       (foodies)-[:SUPPLIES]->(coffee)\n----\n\n[[assigning-expressions-to-variables]]"}, {"heading": "Bind values to variables", "content": "`LET` is used to bind variables to the results of expressions.\n\n.Syntax\n[source, syntax]\n----\nLET variable = expression, variable = expression\n----\n\n.Using `LET` to bind a variable\n[source, cypher]\n----\nMATCH (c:Customer)\nLET fullName = c.firstName + ' ' + c.lastName\nRETURN fullName\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\", cols=\"1*<m\"]\n|===\n| fullName\n\n| \"Amir Rahman\"\n| \"Keisha Nguyen\"\n| \"Mateo Ortega\"\n| \"Hannah Connor\"\n| \"Leila Haddad\"\n| \"Niko Petrov\"\n| \"Yusuf Abdi\"\n\n1+d|Rows: 7\n\n|===\n\n.Using `LET` to bind several variables\n// tag::clauses_let_bind_variables[]\n[source, cypher]\n----\nMATCH (s:Supplier)-[:SUPPLIES]->(p:Product)\nLET supplier = s.name, product = p.name\nRETURN supplier, product\n----\n// end::clauses_let_bind_variables[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\", cols=\"2*<m\"]\n|===\n| supplier | product\n\n| \"TechCorp\" | \"Laptop\"\n| \"TechCorp\" | \"Phone\"\n| \"TechCorp\" | \"Headphones\"\n| \"Foodies Inc.\" | \"Chocolate\"\n| \"Foodies Inc.\" | \"Coffee\"\n\n2+d|Rows: 4\n|===\n\n[[let-and-with-differences]]"}, {"heading": "Differences between `LET` and `WITH`", "content": "There are important differences between `LET` and `WITH` that can be divided into the following categories:\n\n* xref:clauses/let.adoc#variable-scope[Variables in scope]\n* xref:clauses/let.adoc#chaining-expressions[Chaining expressions]\n* xref:clauses/let.adoc#aggregations-distinct[Aggregations and `DISTINCT`]\n\n[[variable-scope]]"}, {"heading": "Variables in scope", "content": "`LET` does not drop variables from the scope of subsequent clauses, while `WITH` does.\nAs such, `LET <variable> = <expression>` is a substitute for `WITH *, <expression> AS <variable>`, not `WITH <expression> AS <variable>` (which would drop any variables present in the preceding clause not referenced in `<expression>`).\n\n.Variables in scope: comparing `LET` and `WITH`\n=====\n\nAny variable not explicitly referenced by `WITH` (or carried over by `WITH *`) is dropped from the scope of subsequent clauses.\n\n.Not allowed -- Referencing a variable dropped by `WITH`\n[source, cypher, role=test-fail]\n----\nMATCH (s:Supplier)-[:SUPPLIES]->(p:Product)\nWITH s.name AS supplier\nRETURN supplier, p.name AS product\n----\n\n.GQLSTATUS error chain\n[role=\"queryresult\",stripes=\"all\",cols=\"1\"]\n|===\n| link:https://neo4j.com/docs/status-codes/current/errors/gql-errors/42N62/[42N62]: error: syntax error or access rule violation - variable not defined. Variable `p` not defined.\n\nlink:https://neo4j.com/docs/status-codes/current/errors/gql-errors/42001/[42001]: error: syntax error or access rule violation - invalid syntax\n|===\n\n`LET`, however, cannot regulate which variables are in scope.\nReplacing `WITH` with `LET` in the above query would, therefore, return results.\n\n.`LET` does not drop variables\n[source, cypher]\n----\nMATCH (s:Supplier)-[:SUPPLIES]->(p:Product)\nLET supplier =  s.name\nRETURN supplier, p.name AS product\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\", cols=\"2*<m\"]\n|===\n| supplier | product\n\n| \"TechCorp\" | \"Laptop\"\n| \"TechCorp\" | \"Phone\"\n| \"TechCorp\" | \"Headphones\"\n| \"Foodies Inc.\" | \"Chocolate\"\n| \"Foodies Inc.\" | \"Coffee\"\n\n2+d|Rows: 5\n\n|===\n\n=====\n\n[[chaining-expressions]]"}, {"heading": "Chaining expressions", "content": "The fact that `LET` does not drop variables means that it can be used to chain expressions in a clear and concise manner, where variables bound in one `LET` clause can be referenced by subsequent clauses.\n\n.Chaining expressions: comparing `LET` and `WITH`\n=====\n\nThe below query shows that variables bound by a `LET` clause can be referenced by subsequent clauses without being explicitly carried over.\nSpecifically, the variable `isExpensive` is created in the first `LET` clause and referenced again in the subsequent clauses.\nNote also that the variable `p`, bound in the `MATCH` clause, is available in the final `RETURN` clause despite not being referenced in any of `LET` clauses.\n\n.`LET` referencing variables assigned in previous a `LET`\n// tag::clauses_let_chain_expressions[]\n[source, cypher]\n----\nMATCH (p:Product)\nLET isExpensive = p.price >= 500\nLET isAffordable = NOT isExpensive\nLET discountCategory = CASE \n    WHEN isExpensive THEN 'High-end'\n    ELSE 'Budget'\nEND\nRETURN p.name AS product, p.price AS price, isAffordable, discountCategory\nORDER BY price\n----\n// end::clauses_let_chain_expressions[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\", cols=\"4*<m\"]\n|===\n| product | price | isAffordable | discountCategory\n\n| \"Chocolate\" | 5 | TRUE | 'Budget'\n| \"Coffee\" | 10 | TRUE | 'Budget'\n| \"Headphones\" | 250 | TRUE | 'Budget'\n| \"Phone\" | 500   | FALSE | 'High-end'\n| \"Laptop\" | 1000  | FALSE | 'High-end'\n\n4+d|Rows: 5\n|===\n\nUsing `WITH`, the same query would become less succinct, as `WITH` would have to explicitly carry over each variable in between clauses:\n\n.Less succinct `WITH` equivalent\n[source, cypher]\n----\nMATCH (p:Product)\nWITH p, p.price >= 500 AS isExpensive\nWITH p, isExpensive, NOT isExpensive AS isAffordable\nWITH p, isExpensive, isAffordable, \n     CASE \n         WHEN isExpensive THEN 'High-end' \n         ELSE 'Budget' \n     END AS discountCategory\nRETURN p.name AS product, p.price AS price, isAffordable, discountCategory\nORDER BY price\n----\n\n=====\n\n[[aggregations-distinct]]"}, {"heading": "Aggregations and `DISTINCT`", "content": "Unlike `WITH`, `LET` cannot perform aggregations or be combined with `DISTINCT`.\nFor example, in the following query, `WITH` could not be replaced by `LET`:\n\n.Combining `WITH DISTINCT` and aggregations on expressions\n[source, cypher]\n----\nMATCH (c:Customer)-[:BUYS]->(p:Product)\nWITH DISTINCT c, sum(p.price) AS totalSpent\nRETURN c.firstName AS customer, totalSpent\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\", cols=\"2*<m\"]\n|===\n| customer | totalSpent\n\n| \"Amir\" | 1005\n| \"Keisha\" | 250\n| \"Mateo\" | 1015\n| \"Hannah\" | 260\n| \"Leila\" | 1000\n| \"Niko\" | 760\n| \"Yusuf\" | 1005\n\n2+d|Rows: 7\n|===\n\n.Combining `WITH` and `LET`\n[source, cypher]\n----\nMATCH (c:Customer)-[:BUYS]->(p:Product)\nWITH DISTINCT c, sum(p.price) AS totalSpent\nLET fullName = c.firstName + ' ' + c.lastName\nRETURN fullName, totalSpent\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\", cols=\"2*<m\"]\n|===\n| customer | totalSpent\n\n| \"Amir Rahman\" | 1005\n| \"Keisha Nguyen\" | 250\n| \"Mateo Ortega\" | 1015\n| \"Hannah Connor\" | 260\n| \"Leila Haddad\" | 1000\n| \"Niko Petrov\" | 760\n| \"Yusuf Abdi\" | 1005\n\n2+d|Rows: 7\n|===\n\n[[advanced-examples]]"}, {"heading": "Advanced examples", "content": "The following examples demonstrates how `LET`, and its ability to chain expressions, can be used in more advanced queries:\n\n.Scenario 1: Supplier notification on customer purchases and discounts\n=====\n\nThis example retrieves information about what `Product` a `Customer` has bought, and from what `Supplier`.\nIt then calculates the `price` after applying the `discount` and constructs a `message` for each purchase, including the `fullName` of each `Customer` and the `effectivePrice` of a `Product` after a discount, sent to the `Supplier` `email`.\n\nThis example highlights that `LET` does not drop variables.\nAll variables introduced in the `MATCH` and subsequent `LET` clauses are available in the final `RETURN` clause.\n\n.Retrieve `Customer` purchase details, including discount information\n[source, cypher]\n----\nMATCH (c:Customer)-[b:BUYS]->(p:Product)<--(s:Supplier)\nLET fullname = c.firstName + ' ' + c.lastName,\n    effectivePrice = p.price * (1 - c.discount)\nLET message = fullname + \" bought \" + p.name + \" for $\" + effectivePrice + \" after a \" + (c.discount * 100) + \"% discount\"\nRETURN b.date AS date, message, s.email AS toSupplier\nORDER BY date\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\", cols=\"1m, 2m, 1m\"]\n|===\n| date | message | toSupplier\n\n| 2023-05-17 | \"Leila Haddad bought Laptop for $900.0 after a 10.0% discount\" | \"contact@techcorp.com\"\n| 2023-07-09 | \"Keisha Nguyen bought Headphones for $200.0 after a 20.0% discount\" | \"contact@techcorp.com\"\n| 2023-12-11 | \"Hannah Connor bought Coffee for $8.5 after a 15.0% discount\" | \"info@foodies.com\"\n| 2024-04-11 | \"Mateo Ortega bought Laptop for $950.0 after a 5.0% discount\" | \"contact@techcorp.com\"\n| 2024-06-02 | \"Hannah Connor bought Headphones for $212.5 after a 15.0% discount\" | \"contact@techcorp.com\"\n| 2024-08-23 | \"Niko Petrov bought Headphones for $187.5 after a 25.0% discount\" | \"contact@techcorp.com\"\n| 2024-10-09 | \"Amir Rahman bought Laptop for $900.0 after a 10.0% discount\" | \"contact@techcorp.com\"\n| 2024-12-24 | \"Yusuf Abdi bought Chocolate for $4.5 after a 10.0% discount\" | \"info@foodies.com\"\n| 2024-12-24 | \"Niko Petrov bought Coffee for $7.5 after a 25.0% discount\" | \"info@foodies.com\"\n| 2025-01-02 | \"Yusuf Abdi bought Laptop for $900.0 after a 10.0% discount\" | \"contact@techcorp.com\"\n| 2025-01-10 | \"Amir Rahman bought Chocolate for $4.5 after a 10.0% discount\" | \"info@foodies.com\"\n| 2025-02-27 | \"Niko Petrov bought Phone for $375.0 after a 25.0% discount\" | \"contact@techcorp.com\"\n| 2025-03-05 | \"Mateo Ortega bought Chocolate for $4.75 after a 5.0% discount\" | \"info@foodies.com\"\n| 2025-03-05 | \"Mateo Ortega bought Coffee for $9.5 after a 5.0% discount\" | \"info@foodies.com\"\n\n3+d| Rows: 14\n|===\n\n=====\n\n.Scenario 2: Supplier gift card distribution based on customer spending\n=====\n\nThe example calculates the `customerRevenue` for each `Customer` after applying their `discount` on each `Product` they bought. Customers are then categorized into three groups based on their total spending: Category `A` for those who spent more than `850`, Category `B` for those who spent more than `350` but less than or equal to `850`, and Category `C` for those who spent `350` or less.\nCategory `C` customers are excluded from the results using the xref:clauses/filter.adoc[`FILTER`] clause, leaving only Category `A` and `B` customers eligible for a gift card.\nThe `amount` in the gift card is assigned based on the category, with with Category `A` receiving `20` and Category `B` receiving `10`.\nThe details of the gift card are then sent to the `email` of the relevant customers.\n\nThis example highlights how `LET` can be used to succinctly chain expressions, and also that it cannot be used to perform aggregations.\n\n.Calculate customer gift card distribution based on spending\n[source, cypher]\n----\nMATCH (customer:Customer)-[bought:BUYS]->(product:Product)\nLET effectivePrice = product.price * (1 - customer.discount)\nWITH customer, bought, sum(effectivePrice) AS customerRevenue\nLET category = CASE \n    WHEN customerRevenue > 850 THEN 'A'\n    WHEN customerRevenue > 350 THEN 'B'\n    ELSE 'C'\n  END\nFILTER category <> 'C'\nLET amount = CASE \n    WHEN category = 'A' THEN 20\n    WHEN category = 'B' THEN 10\nEND\nLET message = {\n    type: 'giftcard',\n    addressee: customer.firstName + ' ' + customer.lastName,\n    amount: amount,\n    year: bought.date.year\n}\nRETURN message, customer.email AS toCustomer, customerRevenue\nORDER BY amount\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\", cols=\"3m, 2m, 1m\"]\n|===\n| message | toCustomer | customerRevenue\n\n| {amount: 10, addressee: \"Niko Petrov\", type: \"giftcard\", year: 2025} | \"niko.petrov@example.com\" | 375.0\n| {amount: 20, addressee: \"Amir Rahman\", type: \"giftcard\", year: 2024} | \"amir.rahman@example.com\" | 900.0\n| {amount: 20, addressee: \"Mateo Ortega\", type: \"giftcard\", year: 2024} | \"mateo.ortega@example.com\" | 950.0\n| {amount: 20, addressee: \"Leila Haddad\", type: \"giftcard\", year: 2023} | \"leila.haddad@example.com\" | 900.0\n| {amount: 20, addressee: \"Yusuf Abdi\", type: \"giftcard\", year: 2025} | \"yusuf.abdi@example.com\" | 900.0\n\n3+d|Rows: 5\n|===\n====="}], "source_file": "modules\\ROOT\\pages\\clauses\\let.adoc", "authority_level": 1}
{"name": "LIMIT", "description": "`LIMIT` constrains the number of returned rows.", "syntax_examples": ["CREATE\n  (andy: Person {name: 'Andy'}),\n  (bernard: Person {name: 'Bernard'}),\n  (charlotte: Person {name: 'Charlotte'}),\n  (david: Person {name: 'David'}),\n  (erika: Person {name: 'Erika'}),\n  (andy)-[:KNOWS]->(bernard),\n  (andy)-[:KNOWS]->(charlotte),\n  (andy)-[:KNOWS]->(david),\n  (andy)-[:KNOWS]->(erika)", "MATCH (n)\nRETURN n.name\nORDER BY n.name\nLIMIT 3", "MATCH (n)\nRETURN n.name\nORDER BY n.name\nLIMIT 1 + toInteger(3 * rand())", "CREATE (n)\nRETURN n\nLIMIT 0", "MATCH (n {name: 'A'})\nSET n.age = 60\nRETURN n\nLIMIT 0", "MATCH (n)\nWITH n ORDER BY n.name LIMIT 1\nSET n.locked = true\nRETURN n\nORDER BY n.name", "MATCH (n)\nLIMIT 2\nRETURN collect(n.name) AS names", "MATCH (n)\nORDER BY n.name DESC\nSKIP 2\nLIMIT 2\nRETURN collect(n.name) AS names"], "sections": [{"heading": "Example graph", "content": "The following graph is used for the examples below:\n\nimage::graph-limit-clause.svg[Example graph connecting Person nodes,width=600,role=popup]\n\nTo recreate it, run the following query against an empty Neo4j database:\n\n[source, cypher, role=test-setup]\n----\nCREATE\n  (andy: Person {name: 'Andy'}),\n  (bernard: Person {name: 'Bernard'}),\n  (charlotte: Person {name: 'Charlotte'}),\n  (david: Person {name: 'David'}),\n  (erika: Person {name: 'Erika'}),\n  (andy)-[:KNOWS]->(bernard),\n  (andy)-[:KNOWS]->(charlotte),\n  (andy)-[:KNOWS]->(david),\n  (andy)-[:KNOWS]->(erika)\n----\n\n[[examples]]"}, {"heading": "Examples", "content": ".Return a limited subset of the rows\n====\n\nTo return a limited subset of the rows, use this syntax:\n\n.Query\n[source, cypher]\n----\nMATCH (n)\nRETURN n.name\nORDER BY n.name\nLIMIT 3\n----\n\nLimit to 3 rows by the example query.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| n.name\n| \"Andy\"\n| \"Bernard\"\n| \"Charlotte\"\nd|Rows: 3\n|===\n\n====\n\n.Using an expression with `LIMIT` to return a subset of the rows\n====\n\n`LIMIT` accepts any expression that evaluates to a positive integer, as long as it can be statically calculated (i.e. calculated before the query is run).\n\n.Query\n[source, cypher]\n----\nMATCH (n)\nRETURN n.name\nORDER BY n.name\nLIMIT 1 + toInteger(3 * rand())\n----\n\nLimit 1 row plus randomly 0, 1, or 2.\nSo randomly limit to 1, 2, or 3 rows.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| n.name\n| \"Andy\"\n| \"Bernard\"\n| \"Charlotte\"\nd|Rows: 3\n|===\n\n====\n\n[[limit-will-not-stop-side-effects]]"}, {"heading": "`LIMIT` and side effects", "content": "The use of `LIMIT` in a query will not stop side effects, like `CREATE`, `DELETE`, or `SET`, from happening if the limit is in the same query part as the side effect.\n\n.Query\n[source, cypher]\n----\nCREATE (n)\nRETURN n\nLIMIT 0\n----\n\nThis query returns nothing, but creates one node:\n\n.Result\n[role=\"queryresult\",options=\"footer\",cols=\"1*<m\"]\n|===\n|(empty result)\nd|Rows: 0 +\nNodes created: 1\n|===\n\n.Query\n[source, cypher]\n----\nMATCH (n {name: 'A'})\nSET n.age = 60\nRETURN n\nLIMIT 0\n----\n\nThis query returns nothing, but writes one property:\n\n.Result\n[role=\"queryresult\",options=\"footer\",cols=\"1*<m\"]\n|===\n|(empty result)\nd|Rows: 0 +\nProperties set: 1\n|===\n\nIf we want to limit the number of updates we can split the query using the `WITH` clause:\n\n.Query\n[source, cypher]\n----\nMATCH (n)\nWITH n ORDER BY n.name LIMIT 1\nSET n.locked = true\nRETURN n\nORDER BY n.name\n----\n\nWrites `locked` property on one node and return that node:\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| n\n| {locked:true,name:\"Andy\",age:60}\nd|Rows: 1 +\nProperties set: 1\n|===\n\n\n[[limit-standalone-clause]]"}, {"heading": "Using `LIMIT` as a standalone clause", "content": "`LIMIT` can be used as a standalone clause, or in conjunction with xref:clauses/order-by.adoc[`ORDER BY`] or xref:clauses/skip.adoc[`SKIP`]/xref:clauses/skip.adoc#offset-synonym[`OFFSET`].\n\n.Standalone use of `LIMIT`\n// tag::clauses_limit_standalone[]\n[source, cypher]\n----\nMATCH (n)\nLIMIT 2\nRETURN collect(n.name) AS names\n----\n// end::clauses_limit_standalone[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| names\n| [\"Andy\", \"Bernard\"]\n|Rows: 1\n|===\n\nThe following query orders all nodes by `name` descending, skips the two first rows and limits the results to two rows.\nIt then xref:functions/aggregating.adoc#functions-collect[collects] the results in a list.\n\n.`LIMIT` used in conjunction with `ORDER BY` and `SKIP`\n// tag::clauses_limit[]\n[source, cypher]\n----\nMATCH (n)\nORDER BY n.name DESC\nSKIP 2\nLIMIT 2\nRETURN collect(n.name) AS names\n----\n// end::clauses_limit[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| names\n| [\"David\", \"Charlotte\"]\n|Rows: 1\n|==="}], "source_file": "modules\\ROOT\\pages\\clauses\\limit.adoc", "authority_level": 1}
{"name": "SHOW FUNCTIONS", "description": "This section explains the `SHOW FUNCTIONS` command.", "syntax_examples": ["SHOW FUNCTIONS", "SHOW BUILT IN FUNCTIONS YIELD name, isBuiltIn\nWHERE name STARTS WITH 'a'", "SHOW FUNCTIONS EXECUTABLE BY CURRENT USER YIELD *", "SHOW FUNCTIONS EXECUTABLE BY jake"], "sections": [{"heading": "Syntax", "content": "[NOTE]\n====\nMore details about the syntax descriptions can be found link:{neo4j-docs-base-uri}/operations-manual/current/database-administration/syntax/#administration-syntax-reading[here].\n====\n\nList functions, either all or only built-in or user-defined::\n\n[source, syntax, role=\"noheader\"]\n----\nSHOW [ALL|BUILT IN|USER DEFINED] FUNCTION[S]\n[YIELD { * | field[, ...] } [ORDER BY field[, ...]] [SKIP n] [LIMIT n]]\n[WHERE expression]\n[RETURN field[, ...] [ORDER BY field[, ...]] [SKIP n] [LIMIT n]]\n----\n\n[NOTE]\n====\nWhen using the `RETURN` clause, the `YIELD` clause is mandatory and must not be omitted.\n====\n\nList functions that the current user can execute::\n\n[source, syntax, role=\"noheader\"]\n----\nSHOW [ALL|BUILT IN|USER DEFINED] FUNCTION[S] EXECUTABLE [BY CURRENT USER]\n[YIELD { * | field[, ...] } [ORDER BY field[, ...]] [SKIP n] [LIMIT n]]\n[WHERE expression]\n[RETURN field[, ...] [ORDER BY field[, ...]] [SKIP n] [LIMIT n]]\n----\n\n[NOTE]\n====\nWhen using the `RETURN` clause, the `YIELD` clause is mandatory and must not be omitted.\n====\n\nList functions that the specified user can execute::\n\n[source, syntax, role=\"noheader\", indent=0]\n----\nSHOW [ALL|BUILT IN|USER DEFINED] FUNCTION[S] EXECUTABLE BY username\n[YIELD { * | field[, ...] } [ORDER BY field[, ...]] [SKIP n] [LIMIT n]]\n[WHERE expression]\n[RETURN field[, ...] [ORDER BY field[, ...]] [SKIP n] [LIMIT n]]\n----\n\nRequired privilege link:{neo4j-docs-base-uri}/operations-manual/current/authentication-authorization/dbms-administration/dbms-user-management-privileges/[`SHOW USER`].\nThis command cannot be used for LDAP users.\n\n[NOTE]\n====\nWhen using the `RETURN` clause, the `YIELD` clause is mandatory and must not be omitted.\n===="}, {"heading": "Listing all functions", "content": "To list all available functions with the default output columns, the `SHOW FUNCTIONS` command can be used.\nIf all columns are required, use `SHOW FUNCTIONS YIELD *`.\n\n\n.Query\n[source, cypher, role=test-result-skip]\n----\nSHOW FUNCTIONS\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"3*<m\"]\n|===\n| name | category | description\n\n| \"abs\"\n| \"Numeric\"\n| \"Returns the absolute value of an `INTEGER`.\"\n\n| \"abs\"\n| \"Numeric\"\n| \"Returns the absolute value of a `FLOAT`.\"\n\n| \"acos\"\n| \"Trigonometric\"\n| \"Returns the arccosine of a `FLOAT` in radians.\"\n\n| \"all\"\n| \"Predicate\"\n| \"Returns true if the predicate holds for all elements in the given `LIST<ANY>`.\"\n\n| \"any\"\n| \"Predicate\"\n| \"Returns true if the predicate holds for at least one element in the given `LIST<ANY>`.\"\n\n| \"asin\"\n| \"Trigonometric\"\n| \"Returns the arcsine of a `FLOAT` in radians.\"\n\n| \"atan\"\n| \"Trigonometric\"\n| \"Returns the arctangent of a `FLOAT` in radians.\"\n\n| \"atan2\"\n| \"Trigonometric\"\n| \"Returns the arctangent2 of a set of coordinates in radians.\"\n\n| \"avg\"\n| \"Aggregating\"\n| \"Returns the average of a set of `INTEGER` values.\"\n\n| \"avg\"\n| \"Aggregating\"\n| \"Returns the average of a set of `FLOAT` values.\"\n\n| \"avg\"\n| \"Aggregating\"\n| \"Returns the average of a set of `DURATION` values.\"\n\n| \"ceil\"\n| \"Numeric\"\n| \"Returns the smallest `FLOAT` that is greater than or equal to a number and equal to an `INTEGER`.\"\n\n| \"coalesce\"\n| \"Scalar\"\n| \"Returns the first non-null value in a list of expressions.\"\n\n| \"collect\"\n| \"Aggregating\"\n| \"Returns a list containing the values returned by an expression.\"\n\n| \"cos\"\n| \"Trigonometric\"\n| \"Returns the cosine of a `FLOAT`.\"\n\n| \"cot\"\n| \"Trigonometric\"\n| \"Returns the cotangent of a `FLOAT`.\"\n\n| \"count\"\n| \"Aggregating\"\n| \"Returns the number of values or rows.\"\n\n| \"date\"\n| \"Temporal\"\n| \"Creates a `DATE` instant.\"\n\n| \"date.realtime\"\n| \"Temporal\"\n| \"Returns the current `DATE` instant using the realtime clock.\"\n\n| \"date.statement\"\n| \"Temporal\"\n| \"Returns the current `DATE` instant using the statement clock.\"\n\n3+d|Rows: 20\n|===\n\nThe above table only displays the first 20 results of the query.\nFor a full list of all available functions in Cypher, see the chapter on xref::clauses/index.adoc[Functions]."}, {"heading": "Listing functions with filtering on output columns", "content": "The listed functions can be filtered in multiple ways.\nOne way is through the type keywords, `BUILT IN` and `USER DEFINED`.\nA more flexible way is to use the `WHERE` clause.\nFor example, getting the name of all built-in functions starting with the letter 'a':\n\n.Query\n[source, cypher]\n----\nSHOW BUILT IN FUNCTIONS YIELD name, isBuiltIn\nWHERE name STARTS WITH 'a'\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| name    | isBuiltIn\n\n| \"abs\" | true\n| \"acos\" | true\n| \"all\" | true\n| \"allReduce\" | true\n| \"any\" | true\n| \"asin\" | true\n| \"atan\" | true\n| \"atan2\" | true\n| \"avg\" | true\n\n2+d|Rows: 9\n|==="}, {"heading": "Listing functions with other filtering", "content": "The listed functions can also be filtered on whether a user can execute them.\nThis filtering is only available through the `EXECUTABLE` clause and not through the `WHERE` clause.\nThis is due to using the user's privileges instead of filtering on the available output columns.\n\nThere are two options, how to use the `EXECUTABLE` clause.\nThe first option, is to filter for the current user:\n\n.Query\n[source, cypher, role=test-result-skip]\n----\nSHOW FUNCTIONS EXECUTABLE BY CURRENT USER YIELD *\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"6*<m\"]\n|===\n| name | category | description | rolesExecution | rolesBoostedExecution | ...\n\n| \"abs\"\n| \"Numeric\"\n| \"Returns the absolute value of an `INTEGER`.\"\n| <null>\n| <null>\n|\n\n| \"abs\"\n| \"Numeric\"\n| \"Returns the absolute value of a `FLOAT`.\"\n| <null>\n| <null>\n|\n\n| \"acos\"\n| \"Trigonometric\"\n| \"Returns the arccosine of a `FLOAT` in radians.\"\n| <null>\n| <null>\n|\n\n| \"all\"\n| \"Predicate\"\n| \"Returns true if the predicate holds for all elements in the given `LIST<ANY>`.\"\n| <null>\n| <null>\n|\n\n| \"any\"\n| \"Predicate\"\n| \"Returns true if the predicate holds for at least one element in the given `LIST<ANY>`.\"\n| <null>\n| <null>\n|\n\n| \"asin\"\n| \"Trigonometric\"\n| \"Returns the arcsine of a `FLOAT` in radians.\"\n| <null>\n| <null>\n|\n\n| \"atan\"\n| \"Trigonometric\"\n| \"Returns the arctangent of a `FLOAT` in radians.\"\n| <null>\n| <null>\n|\n\n| \"atan2\"\n| \"Trigonometric\"\n| \"Returns the arctangent2 of a set of coordinates in radians.\"\n| <null>\n| <null>\n|\n\n| \"avg\"\n| \"Aggregating\"\n| \"Returns the average of a set of `INTEGER` values.\"\n| <null>\n| <null>\n|\n\n| \"avg\"\n| \"Aggregating\"\n| \"Returns the average of a set of `FLOAT` values.\"\n| <null>\n| <null>\n|\n\n6+d|Rows: 10\n|===\n\nNotice that the two `roles` columns are empty due to missing the link:{neo4j-docs-base-uri}/operations-manual/current/authentication-authorization/dbms-administration#access-control-dbms-administration-role-management[`SHOW ROLE`] privilege.\nAlso note that the following columns are not present in the table: \n\n* `signature`\n* `isBuiltIn`\n* `argumentDescription`\n* `returnDescription`\n* `aggregating`\n* `isDeprecated`\n* `deprecatedBy`\n\nThe second option, is to filter for a specific user:\n\n.Query\n[source, cypher, role=test-result-skip]\n----\nSHOW FUNCTIONS EXECUTABLE BY jake\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"3*<m\"]\n|===\n| name | category | description\n\n| \"abs\"\n| \"Numeric\"\n| \"Returns the absolute value of an `INTEGER`.\"\n\n| \"abs\"\n| \"Numeric\"\n| \"Returns the absolute value of a `FLOAT`.\"\n\n| \"acos\"\n| \"Trigonometric\"\n| \"Returns the arccosine of a `FLOAT` in radians.\"\n\n| \"all\"\n| \"Predicate\"\n| \"Returns true if the predicate holds for all elements in the given `LIST<ANY>`.\"\n\n| \"any\"\n| \"Predicate\"\n| \"Returns true if the predicate holds for at least one element in the given `LIST<ANY>`.\"\n\n| \"asin\"\n| \"Trigonometric\"\n| \"Returns the arcsine of a `FLOAT` in radians.\"\n\n| \"atan\"\n| \"Trigonometric\"\n| \"Returns the arctangent of a `FLOAT` in radians.\"\n\n| \"atan2\"\n| \"Trigonometric\"\n| \"Returns the arctangent2 of a set of coordinates in radians.\"\n\n| \"avg\"\n| \"Aggregating\"\n| \"Returns the average of a set of `INTEGER` values.\"\n\n| \"avg\"\n| \"Aggregating\"\n| \"Returns the average of a set of `FLOAT` values.\"\n\n3+d|Rows: 10\n|==="}], "source_file": "modules\\ROOT\\pages\\clauses\\listing-functions.adoc", "authority_level": 1}
{"name": "SHOW PROCEDURES", "description": "This section explains the `SHOW PROCEDURES` command.", "syntax_examples": ["SHOW PROCEDURES", "SHOW PROCEDURES YIELD name, admin\nWHERE admin", "SHOW PROCEDURES EXECUTABLE BY CURRENT USER YIELD *", "SHOW PROCEDURES EXECUTABLE BY jake"], "sections": [{"heading": "Syntax", "content": "[NOTE]\n====\nMore details about the syntax descriptions can be found link:{neo4j-docs-base-uri}/operations-manual/current/database-administration/syntax/#administration-syntax-reading[here].\n====\n\nList all procedures::\n\n[source, syntax, role=\"noheader\", indent=0]\n----\nSHOW PROCEDURE[S]\n[YIELD { * | field[, ...] } [ORDER BY field[, ...]] [SKIP n] [LIMIT n]]\n[WHERE expression]\n[RETURN field[, ...] [ORDER BY field[, ...]] [SKIP n] [LIMIT n]]\n----\n\n[NOTE]\n====\nWhen using the `RETURN` clause, the `YIELD` clause is mandatory and must not be omitted.\n====\n\nList procedures that the current user can execute::\n\n[source, syntax, role=\"noheader\", indent=0]\n----\nSHOW PROCEDURE[S] EXECUTABLE [BY CURRENT USER]\n[YIELD { * | field[, ...] } [ORDER BY field[, ...]] [SKIP n] [LIMIT n]]\n[WHERE expression]\n[RETURN field[, ...] [ORDER BY field[, ...]] [SKIP n] [LIMIT n]]\n----\n\n[NOTE]\n====\nWhen using the `RETURN` clause, the `YIELD` clause is mandatory and must not be omitted.\n====\n\nList procedures that the specified user can execute::\n\n[source, syntax, role=\"noheader\", indent=0]\n----\nSHOW PROCEDURE[S] EXECUTABLE BY username\n[YIELD { * | field[, ...] } [ORDER BY field[, ...]] [SKIP n] [LIMIT n]]\n[WHERE expression]\n[RETURN field[, ...] [ORDER BY field[, ...]] [SKIP n] [LIMIT n]]\n----\n\nRequires the privilege link:{neo4j-docs-base-uri}/operations-manual/current/authentication-authorization/dbms-administration/dbms-user-management-privileges/[`SHOW USER`].\nThis command cannot be used for LDAP users.\n\n[NOTE]\n====\nWhen using the `RETURN` clause, the `YIELD` clause is mandatory and must not be omitted.\n===="}, {"heading": "Listing all procedures", "content": "To list all available procedures with the default output columns, the `SHOW PROCEDURES` command can be used.\nIf all columns are required, use `SHOW PROCEDURES YIELD *`.\n\n.Query\n[source, cypher, role=test-result-skip]\n----\nSHOW PROCEDURES\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2m,2m,1m,1m\"]\n|===\n| name | description | mode | worksOnSystem\n\n| \"cdc.current\"\n| \"Returns the current change identifier that can be used to stream changes from.\"\n| \"READ\"\n| false\n\n| \"cdc.earliest\"\n| \"Returns the earliest change identifier that can be used to stream changes from.\"\n| \"READ\"\n| false\n\n| \"cdc.query\"\n| \"Query changes observed by the provided change identifier.\"\n| \"READ\"\n| false\n\n| \"db.awaitIndex\"\n| \"Wait for an index to come online (for example: CALL db.awaitIndex(\"MyIndex\", 300)).\"\n| \"READ\"\n| true\n\n| \"db.awaitIndexes\"\n| \"Wait for all indexes to come online (for example: CALL db.awaitIndexes(300)).\"\n| \"READ\"\n| true\n\n| \"db.checkpoint\"\n| \"Initiate and wait for a new check point, or wait any already on-going check point to complete. Note that this temporarily disables the `dbms.checkpoint.iops.limit` setting in order to make the check point complete faster. This might cause transaction throughput to degrade slightly, due to increased IO load.\"\n| \"DBMS\"\n| true\n\n| \"db.clearQueryCaches\"\n| \"Clears all query caches.\"\n| \"DBMS\"\n| true\n\n| \"db.createLabel\"\n| \"Create a label\"\n| \"WRITE\"\n| false\n\n| \"db.createProperty\"\n| \"Create a Property\"\n| \"WRITE\"\n| false\n\n| \"db.createRelationshipType\"\n| \"Create a RelationshipType\"\n| \"WRITE\"\n| false\n\n| \"db.index.fulltext.awaitEventuallyConsistentIndexRefresh\"\n| \"Wait for the updates from recently committed transactions to be applied to any eventually-consistent full-text indexes.\"\n| \"READ\"\n| true\n\n| \"db.index.fulltext.listAvailableAnalyzers\"\n| \"List the available analyzers that the full-text indexes can be configured with.\"\n| \"READ\"\n| true\n\n| \"db.index.fulltext.queryNodes\"\n| \"Query the given full-text index. Returns the matching nodes, and their Lucene query score, ordered by score. Valid keys for the options map are: 'skip' to skip the top N results; 'limit' to limit the number of results returned; 'analyzer' to use the specified analyzer as search analyzer for this query.\"\n| \"READ\"\n| true\n\n| \"db.index.fulltext.queryRelationships\"\n| \"Query the given full-text index. Returns the matching relationships, and their Lucene query score, ordered by score. Valid keys for the options map are: 'skip' to skip the top N results; 'limit' to limit the number of results returned; 'analyzer' to use the specified analyzer as search analyzer for this query.\"\n| \"READ\"\n| true\n\n| \"db.info\"\n| \"Provides information regarding the database.\"\n| \"READ\"\n| true\n\n| \"db.labels\"\n| \"List all available labels in the database.\"\n| \"READ\"\n| true\n\n| \"db.listLocks\"\n| \"List all locks in the database.\"\n| \"DBMS\"\n| true\n\n| \"db.ping\"\n| \"This procedure can be used by client side tooling to test whether they are correctly connected to a database. The procedure is available in all databases and always returns true. A faulty connection can be detected by not being able to call this procedure.\"\n| \"READ\"\n| true\n\n4+d|Rows: 15\n|===\n\nThe above table only displays the first 15 results of the query.\nFor a full list of all built-in procedures in Neo4j, visit the link:{neo4j-docs-base-uri}/operations-manual/current/procedures[Operations Manual -> Procedures]."}, {"heading": "Listing procedures with filtering on output columns", "content": "The listed procedures can be filtered in multiple ways, one way is to use the `WHERE` clause.\nFor example, returning the names of all `admin` procedures:\n\n.Query\n[source, cypher, role=test-result-skip]\n----\nSHOW PROCEDURES YIELD name, admin\nWHERE admin\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| name | admin\n\n| \"cdc.query\" | true\n| \"db.cdc.query\" | true\n| \"db.cdc.translateId\" | true\n| \"db.clearQueryCaches\" | true\n| \"db.listLocks\" | true\n\n2+d|Rows: 5\n|===\n\nThe above table only displays the first 5 results of the query.\nFor a full list of all procedures which require `admin` privileges in Neo4j, visit the link:{neo4j-docs-base-uri}/operations-manual/current/procedures[Operations Manual -> Procedures]."}, {"heading": "Listing procedures with other filtering", "content": "The listed procedures can also be filtered by whether a user can execute them.\nThis filtering is only available through the `EXECUTABLE` clause and not through the `WHERE` clause.\nThis is due to using the user's privileges instead of filtering on the available output columns.\n\nThere are two options for using the `EXECUTABLE` clause.\nThe first option is to filter for the current user:\n\n.Query\n[source, cypher, role=test-result-skip]\n----\nSHOW PROCEDURES EXECUTABLE BY CURRENT USER YIELD *\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2m,2m,1m,1m,1m\"]\n|===\n| name | description | rolesExecution | rolesBoostedExecution | ...\n\n| \"db.awaitIndex\"\n| \"Wait for an index to come online (for example: CALL db.awaitIndex(\"MyIndex\", 300)).\"\n| <null>\n| <null>\n|\n\n| \"db.awaitIndexes\"\n| \"Wait for all indexes to come online (for example: CALL db.awaitIndexes(300)).\"\n| <null>\n| <null>\n|\n\n| \"db.checkpoint\"\n| \"Initiate and wait for a new check point, or wait any already on-going check point to complete. Note that this temporarily disables the `dbms.checkpoint.iops.limit` setting in order to make the check point complete faster. This might cause transaction throughput to degrade slightly, due to increased IO load.\"\n| <null>\n| <null>\n|\n\n| \"db.clearQueryCaches\"\n| \"Clears all query caches.\"\n| <null>\n| <null>\n|\n\n| \"db.createLabel\"\n| \"Create a label\"\n| <null>\n| <null>\n|\n\n| \"db.createProperty\"\n| \"Create a Property\"\n| <null>\n| <null>\n|\n\n| \"db.createRelationshipType\"\n| \"Create a RelationshipType\"\n| <null>\n| <null>\n|\n\n| \"db.index.fulltext.awaitEventuallyConsistentIndexRefresh\"\n| \"Wait for the updates from recently committed transactions to be applied to any eventually-consistent full-text indexes.\"\n| <null>\n| <null>\n|\n\n| \"db.index.fulltext.listAvailableAnalyzers\"\n| \"List the available analyzers that the full-text indexes can be configured with.\"\n| <null>\n| <null>\n|\n\n| \"db.index.fulltext.queryNodes\"\n| \"Query the given full-text index. Returns the matching nodes, and their Lucene query score, ordered by score. Valid keys for the options map are: 'skip' to skip the top N results; 'limit' to limit the number of results returned; 'analyzer' to use the specified analyzer as search analyzer for this query.\"\n| <null>\n| <null>\n|\n\n| \"db.index.fulltext.queryRelationships\"\n| \"Query the given full-text index. Returns the matching relationships, and their Lucene query score, ordered by score. Valid keys for the options map are: 'skip' to skip the top N results; 'limit' to limit the number of results returned; 'analyzer' to use the specified analyzer as search analyzer for this query.\"\n| <null>\n| <null>\n|\n\n| \"db.info\"\n| \"Provides information regarding the database.\"\n| <null>\n| <null>\n|\n\n| \"db.labels\"\n| \"List all available labels in the database.\"\n| <null>\n| <null>\n|\n\n| \"db.listLocks\"\n| \"List all locks in the database.\"\n| <null>\n| <null>\n|\n\n| \"db.ping\"\n| \"This procedure can be used by client side tooling to test whether they are correctly connected to a database. The procedure is available in all databases and always returns true. A faulty connection can be detected by not being able to call this procedure.\"\n| <null>\n| <null>\n|\n\n5+d|Rows: 15\n|===\n\nThe above table only displays the first 15 results of the query.\nNote that the two `roles` columns are empty due to missing the link:{neo4j-docs-base-uri}/operations-manual/current/authentication-authorization/dbms-administration/dbms-role-management-privileges/[`SHOW ROLE`] privilege.\nAlso note that the following columns are not present in the table: \n\n* `mode`\n* `worksOnSystem`\n* `signature`\n* `argumentDescription`\n* `returnDescription`\n* `admin`\n* `isDeprecated`\n* `deprecatedBy`\n* `options`\n\nThe second option for using the `EXECUTABLE` clause is to filter the list to only contain procedures executable by a specific user.\nThe below example shows the procedures available to the user `jake`, who has been granted the `EXECUTE PROCEDURE dbms.*` privilege by the `admin` of the database.\n(More information about `DBMS EXECUTE` privilege administration can be found in the link:{neo4j-docs-base-uri}/operations-manual/current/authentication-authorization/dbms-administration/#access-control-dbms-administration-execute[Operations Manual -> The `DBMS EXECUTE` privileges]).\n\n.Query\n[source, cypher, role=test-result-skip]\n----\nSHOW PROCEDURES EXECUTABLE BY jake\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2m,2m,1m,1m\"]\n|===\n| name | description | mode | worksOnSystem\n\n| \"dbms.cluster.protocols\"\n| \"Overview of installed protocols.\"\n| \"DBMS\"\n| true\n\n| \"dbms.cluster.routing.getRoutingTable\"\n| \"Returns the advertised bolt capable endpoints for a given database, divided by each endpoint's capabilities. For example an endpoint may serve read queries, write queries and/or future getRoutingTable requests.\"\n| \"DBMS\"\n| true\n\n| \"dbms.components\"\n| \"List DBMS components and their versions.\"\n| \"DBMS\"\n| true\n\n| \"dbms.info\"\n| \"Provides information regarding the DBMS.\"\n| \"DBMS\"\n| true\n\n| \"dbms.killConnection\n| \"Kill network connection with the given connection id.\"\n| \"DBMS\"\n| false\n\n| \"dbms.killConnections\"\n| \"Kill all network connections with the given connection ids.\"\n| \"DBMS\"\n| true\n\n| \"dbms.listActiveLocks\"\n| \"List the active lock requests granted for the transaction executing the query with the given query id.\"\n| \"DBMS\"\n| true\n\n| \"dbms.listCapabilities\"\n| \"List capabilities\"\n| \"DBMS\"\n| true\n\n| \"dbms.listConnections\"\n| \"List all accepted network connections at this instance that are visible to the user.\"\n| \"DBMS\"\n| true\n\n| \"dbms.listPools\"\n| \"List all memory pools, including sub pools, currently registered at this instance that are visible to the user.\"\n| \"DBMS\"\n| true\n\n| \"dbms.queryJmx\"\n| \"Query JMX management data by domain and name. For instance, \"*:*\"\"\n| \"DBMS\"\n| true\n\n| \"dbms.routing.getRoutingTable\"\n| \"Returns the advertised bolt capable endpoints for a given database, divided by each endpoint's capabilities. For example an endpoint may serve read queries, write queries and/or future getRoutingTable requests.\"\n| \"DBMS\"\n| true\n\n| \"dbms.showCurrentUser\"\n| \"Shows the current user.\"\n| \"DBMS\"\n| true\n\n4+d|Rows: 13\n|==="}], "source_file": "modules\\ROOT\\pages\\clauses\\listing-procedures.adoc", "authority_level": 1}
{"name": "SHOW SETTINGS", "description": "This section explains the `SHOW SETTINGS` command.", "syntax_examples": ["SHOW SETTINGS", "SHOW SETTINGS YIELD name, value, description\nWHERE name STARTS WITH 'server'\nRETURN name, value, description\nLIMIT 3", "SHOW SETTINGS \"server.bolt.enabled\", \"server.bolt.advertised_address\", \"server.bolt.listen_address\""], "sections": [{"heading": "Syntax", "content": "[NOTE]\n====\nMore details about the syntax descriptions can be found link:{neo4j-docs-base-uri}/operations-manual/current/database-administration/syntax/#administration-syntax-reading[here].\n====\n\nList settings::\n\n[source, syntax, role=\"noheader\"]\n----\nSHOW SETTING[S] [setting-name[,...]]\n[YIELD { * | field[, ...] } [ORDER BY field[, ...]] [SKIP n] [LIMIT n]]\n[WHERE expression]\n[RETURN field[, ...] [ORDER BY field[, ...]] [SKIP n] [LIMIT n]]\n----\n\nSetting names must be supplied as one or more comma-separated quoted `STRING` values or as an expression resolving to a `STRING` or a `LIST<STRING>`.\n\n[NOTE]\n====\nWhen using the `RETURN` clause, the `YIELD` clause is mandatory and must not be omitted.\n===="}, {"heading": "Listing all settings", "content": "To list all settings with the default output columns, the `SHOW SETTINGS` command can be used.\nIf all columns are required, use `SHOW SETTINGS YIELD *`.\n\n\n.Query\n[source, cypher, role=test-result-skip]\n----\nSHOW SETTINGS\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2m,1m,1m,1m,3m\"]\n|===\n| name | value | isDynamic | defaultValue | description\n\n| \"browser.allow_outgoing_connections\"\n| \"true\"\n| false\n| \"true\"\n| \"Configure the policy for outgoing Neo4j Browser connections.\"\n\n| \"browser.credential_timeout\"\n| \"0s\"\n| false\n| \"0s\"\n| \"Configure the Neo4j Browser to time out logged in users after this idle period. Setting this to 0 indicates no limit.\"\n\n| \"browser.post_connect_cmd\"\n| \"\"\n| false\n| \"\"\n| \"Commands to be run when Neo4j Browser successfully connects to this server. Separate multiple commands with semi-colon.\"\n\n| \"browser.remote_content_hostname_whitelist\"\n| \"guides.neo4j.com,localhost\"\n| false\n| \"guides.neo4j.com,localhost\"\n| \"Whitelist of hosts for the Neo4j Browser to be allowed to fetch content from.\"\n\n| \"browser.retain_connection_credentials\"\n| \"true\"\n| false\n| \"true\"\n| \"Configure the Neo4j Browser to store or not store user credentials.\"\n\n| \"browser.retain_editor_history\"\n| \"true\"\n| false\n| \"true\"\n| \"Configure the Neo4j Browser to store or not store user editor history.\"\n\n| \"client.allow_telemetry\"\n| \"true\"\n| false\n| \"true\"\n| \"Configure client applications such as Browser and Bloom to send Product Analytics data.\"\n\n| \"db.checkpoint\"\n| \"PERIODIC\"\n| false\n| \"PERIODIC\"\n| \"Configures the general policy for when check-points should occur. The default policy is the 'periodic' check-point policy, as specified by the 'db.checkpoint.interval.tx' and 'db.checkpoint.interval.time' settings. The Neo4j Enterprise Edition provides two alternative policies: The first is the 'continuous' check-point policy, which will ignore those settings and run the check-point process all the time. The second is the 'volumetric' check-point policy, which makes a best-effort at check-pointing often enough so that the database doesn't get too far behind on deleting old transaction logs in accordance with the 'db.tx_log.rotation.retention_policy' setting.\"\n\n| \"db.checkpoint.interval.time\"\n| \"15m\"\n| false\n| \"15m\"\n| \"Configures the time interval between check-points. The database will not check-point more often than this (unless check pointing is triggered by a different event), but might check-point less often than this interval, if performing a check-point takes longer time than the configured interval. A check-point is a point in the transaction logs, which recovery would start from. Longer check-point intervals typically mean that recovery will take longer to complete in case of a crash. On the other hand, a longer check-point interval can also reduce the I/O load that the database places on the system, as each check-point implies a flushing and forcing of all the store files.\"\n\n| \"db.checkpoint.interval.tx\"\n| \"100000\"\n| false\n| \"100000\"\n| \"Configures the transaction interval between check-points. The database will not check-point more often  than this (unless check pointing is triggered by a different event), but might check-point less often than this interval, if performing a check-point takes longer time than the configured interval. A check-point is a point in the transaction logs, which recovery would start from. Longer check-point intervals typically mean that recovery will take longer to complete in case of a crash. On the other hand, a longer check-point interval can also reduce the I/O load that the database places on the system, as each check-point implies a flushing and forcing of all the store files.  The default is '100000' for a check-point every 100000 transactions.\"\n\n5+d|Rows: 10\n|===\n\nThe above table only displays the first 10 results of the query.\nFor a full list of all available settings in Neo4j, refer to link:{neo4j-docs-base-uri}/operations-manual/current/configuration/configuration-settings[Configuration settings]."}, {"heading": "Listing settings with filtering on output columns", "content": "The listed settings can be filtered by using the `WHERE` clause.\nFor example, the following query returns the name, value, and description of the first three settings starting with 'server':\n\n.Query\n[source, cypher]\n----\nSHOW SETTINGS YIELD name, value, description\nWHERE name STARTS WITH 'server'\nRETURN name, value, description\nLIMIT 3\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2m,1m,3m\"]\n|===\n| name | value | description\n\n| \"server.backup.advertised_address\"\n| \"localhost:0\"\n| \"The advertised address for the backup server. Default is the default advertised address combined with port defined in the backup listen address.\"\n\n| \"server.backup.enabled\"\n| \"true\"\n| \"Enable support for running online backups.\"\n\n| \"server.backup.exec_connector.command\"\n| \"\"\n| \"Command to execute for ExecDataConnector list\"\n\n3+d|Rows: 3\n|==="}, {"heading": "Listing specific settings", "content": "It is possible to specify which settings to return in the list by setting names.\n\n.Query\n[source, cypher]\n----\nSHOW SETTINGS \"server.bolt.enabled\", \"server.bolt.advertised_address\", \"server.bolt.listen_address\"\n----\n\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2m,1m,1m,1m,3m\"]\n|===\n| name | value | isDynamic | defaultValue | description\n\n| \"server.bolt.advertised_address\"\n| \"localhost:7687\"\n| false\n| \":7687\"\n| \"Advertised address for this connector.\"\n\n| \"server.bolt.enabled\"\n| \"true\"\n| false\n| \"true\"\n| \"Enable the bolt connector.\"\n\n| \"server.bolt.listen_address\"\n| \"localhost:7687\"\n| false\n| \":7687\"\n| \"Address the connector should bind to.\"\n\n5+d|Rows: 3\n|==="}], "source_file": "modules\\ROOT\\pages\\clauses\\listing-settings.adoc", "authority_level": 1}
{"name": "LOAD CSV", "description": "`LOAD CSV` is used to import data from CSV files into a Neo4j database.", "syntax_examples": ["LOAD CSV FROM 'https://data.neo4j.com/bands/artists.csv' // <1>\nAS row  // <2>\nMERGE (:Artist {name: row[1], year: toInteger(row[2])})  // <3>", "LOAD CSV FROM 'file:///artists.csv' AS row\nMERGE (a:Artist {name: row[1], year: toInteger(row[2])})\nRETURN a.name, a.year", "LOAD CSV FROM 'https://data.neo4j.com/bands/artists.csv' AS row\nMERGE (a:Artist {name: row[1], year: toInteger(row[2])})\nRETURN a.name, a.year", "LOAD CSV FROM 'ftp://<username>:<password>@<domain>/bands/artists.csv' AS row\nMERGE (a:Artist {name: row[1], year: toInteger(row[2])})\nRETURN a.name, a.year", "LOAD CSV FROM 'azb://azb-account/azb-container/artists.csv' AS row\nMERGE (a:Artist {name: row[1], year: toInteger(row[2])})\nRETURN a.name, a.year", "LOAD CSV FROM 'gs://gs-bucket/artists.csv' AS row\nMERGE (a:Artist {name: row[1], year: toInteger(row[2])})\nRETURN a.name, a.year", "LOAD CSV FROM 's3://aws-bucket/artists.csv' AS row\nMERGE (a:Artist {name: row[1], year: toInteger(row[2])})\nRETURN a.name, a.year", "LOAD CSV WITH HEADERS FROM 'file:///bands-with-headers.csv' AS line\nMERGE (n:$(line.Label) {name: line.Name})\nRETURN n AS bandNodes", "LOAD CSV FROM 'file:///artists.zip' AS row\nMERGE (:Artist {name: row[1], year: toInteger(row[2])})", "// Create `Book` nodes\nLOAD CSV WITH HEADERS FROM 'https://data.neo4j.com/importing-cypher/books.csv' AS row\nMERGE (b:Book {id: row.id, title: row.title})\nMERGE (a:Author {name: row.author});\n\n// Create `WROTE` relationships\nLOAD CSV WITH HEADERS FROM 'https://data.neo4j.com/importing-cypher/books.csv' AS row\nMATCH (a:Author{name: row.author})\nMATCH (b:Book{id: row.id})\nMERGE (a)-[:WROTE]->(b);"], "sections": [{"heading": "Import CSV data into Neo4j", "content": "[role=label--not-on-aura]"}, {"heading": "Import local files", "content": "You can store CSV files on the database server and then access them by using a `+file:///+` URL.\nBy default, paths are resolved relative to the Neo4j import directory.\n\n.Import artists name and year information from a local file\n====\n\n.artists.csv\n[source, csv, filename=\"artists.csv\"]\n----\n1,ABBA,1992\n2,Roxette,1986\n3,Europe,1979\n4,The Cardigans,1992\n----\n\n.Query\n// tag::clauses_load_csv_local_files[]\n[source, cypher]\n----\nLOAD CSV FROM 'file:///artists.csv' AS row\nMERGE (a:Artist {name: row[1], year: toInteger(row[2])})\nRETURN a.name, a.year\n----\n// end::clauses_load_csv_local_files[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| a.name | a.year\n| 'ABBA' | '1992'\n| 'Roxette' | '1986'\n| 'Europe' | '1979'\n| 'The Cardigans' | '1992'\n2+d|4 rows\n\nAdded 4 nodes, Set 8 properties, Added 4 labels\n|===\n====\n\n[NOTE]\nFor ways of importing data into an Aura instance, see link:https://neo4j.com/docs/aura/classic/auradb/importing/importing-data/[Aura -> Importing data].\n\n[TIP]\nWhen using `+file:///+` URLs, spaces and other non-alphanumeric characters must be link:https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding[URL-encoded]."}, {"heading": "Configuration settings for file URLs", "content": "link:{neo4j-docs-base-uri}/operations-manual/current/configuration/configuration-settings#config_dbms.security.allow_csv_import_from_file_urls[dbms.security.allow_csv_import_from_file_urls]::\nThis setting determines whether `+file:///+` URLs are allowed.\n\nlink:{neo4j-docs-base-uri}/operations-manual/current/configuration/configuration-settings#config_server.directories.import[server.directories.import]::\nThis setting sets the root directory relative to which `+file:///+` URLs are parsed."}, {"heading": "Import from a remote location", "content": "You can import data from a CSV file hosted on a remote path.\n\n`LOAD CSV` supports accessing CSV files via HTTPS, HTTP, and FTP (with or without credentials).\nIt also follows redirects, except those changing the protocol (for security reasons).\n\n[IMPORTANT]\n====\nIt is strongly recommended to permit resource loading only over secure protocols such as HTTPS instead of insecure protocols like HTTP. \nThis can be done by limiting the link:{neo4j-docs-base-uri}/operations-manual/current/authentication-authorization/load-privileges/#access-control-load-cidr[load privileges] to only trusted sources that use secure protocols. \nIf allowing an insecure protocol is absolutely unavoidable, Neo4j takes measures internally to enhance the security of these requests within their limitations. \nHowever, this means that insecure URLs on virtual hosts will not function unless you add the JVM argument `-Dsun.net.http.allowRestrictedHeaders=true` to the configuration setting link:{neo4j-docs-base-uri}/operations-manual/current/configuration/configuration-settings/#config_server.jvm.additional[`server.jvm.additional`].\n====\n\n\n.Import artists name and year information from a remote file via HTTPS\n====\n\n.https://data.neo4j.com/bands/artists.csv\n[source, csv, filename=\"artists.csv\"]\n----\n1,ABBA,1992\n2,Roxette,1986\n3,Europe,1979\n4,The Cardigans,1992\n----\n\n.Query\n// tag::clauses_load_csv_remote_locations[]\n[source, cypher]\n----\nLOAD CSV FROM 'https://data.neo4j.com/bands/artists.csv' AS row\nMERGE (a:Artist {name: row[1], year: toInteger(row[2])})\nRETURN a.name, a.year\n----\n// end::clauses_load_csv_remote_locations[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| a.name | a.year\n| 'ABBA' | '1992'\n| 'Roxette' | '1986'\n| 'Europe' | '1979'\n| 'The Cardigans' | '1992'\n2+d|4 rows\n\nAdded 4 nodes, Set 8 properties, Added 4 labels\n|===\n====\n\n\n.Import artists name and year information from a remote file via FTP using credentials\n====\n\n.\\ftp://<username>:<password>@<domain>/bands/artists.csv\n[source, csv, filename=\"artists.csv\"]\n----\n1,ABBA,1992\n2,Roxette,1986\n3,Europe,1979\n4,The Cardigans,1992\n----\n\n.Query\n[source, cypher, role=test-skip]\n----\nLOAD CSV FROM 'ftp://<username>:<password>@<domain>/bands/artists.csv' AS row\nMERGE (a:Artist {name: row[1], year: toInteger(row[2])})\nRETURN a.name, a.year\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| a.name | a.year\n| 'ABBA' | '1992'\n| 'Roxette' | '1986'\n| 'Europe' | '1979'\n| 'The Cardigans' | '1992'\n2+d|4 rows\n\nAdded 4 nodes, Set 8 properties, Added 4 labels\n|===\n====\n\n[role=label--enterprise-edition label--not-on-aura]"}, {"heading": "Import from cloud URIs", "content": "You can import data from a number of different cloud storages:\n\n* xref:clauses/load-csv.adoc#azure-cloud-storage[Azure Cloud Storage]\n* xref:clauses/load-csv.adoc#google-cloud-storage[Google Cloud Storage]\n* xref:clauses/load-csv.adoc#aws-s3[AWS S3]\n\nSee link:{neo4j-docs-base-uri}/operations-manual/current/backup-restore/restore-dump/#load-dump-cloud-storage[Operations Manual -> Load a dump from a cloud storage] on how to set up access to cloud storages.\n\n[[azure-cloud-storage]]"}, {"heading": "Import from an Azure Cloud Storage URI", "content": "You can import data from a CSV file hosted in an Azure Cloud Storage URI.\n\n.Import artists name and year information from an Azure Cloud Storage URI\n====\n\n.azb://azb-account/azb-container/artists.csv\n[source, csv, filename=\"artists.csv\"]\n----\n1,ABBA,1992\n2,Roxette,1986\n3,Europe,1979\n4,The Cardigans,1992\n----\n\n.Query\n[source, cypher, role=test-skip]\n----\nLOAD CSV FROM 'azb://azb-account/azb-container/artists.csv' AS row\nMERGE (a:Artist {name: row[1], year: toInteger(row[2])})\nRETURN a.name, a.year\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| a.name | a.year\n| 'ABBA' | '1992'\n| 'Roxette' | '1986'\n| 'Europe' | '1979'\n| 'The Cardigans' | '1992'\n2+d|4 rows\n\nAdded 4 nodes, Set 8 properties, Added 4 labels\n|===\n====\n\n[[google-cloud-storage]]"}, {"heading": "Import from a Google Cloud Storage URI", "content": "You can import data from a CSV file hosted in a Google Cloud Storage URI.\n\n.Import artists name and year information from a Google Cloud Storage URI\n====\n\n.gs://gs-bucket/artists.csv\n[source, csv, filename=\"artists.csv\"]\n----\n1,ABBA,1992\n2,Roxette,1986\n3,Europe,1979\n4,The Cardigans,1992\n----\n\n.Query\n[source, cypher, role=test-skip]\n----\nLOAD CSV FROM 'gs://gs-bucket/artists.csv' AS row\nMERGE (a:Artist {name: row[1], year: toInteger(row[2])})\nRETURN a.name, a.year\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| a.name | a.year\n| 'ABBA' | '1992'\n| 'Roxette' | '1986'\n| 'Europe' | '1979'\n| 'The Cardigans' | '1992'\n2+d|4 rows\n\nAdded 4 nodes, Set 8 properties, Added 4 labels\n|===\n====\n\n[[aws-s3]]"}, {"heading": "Import from an AWS S3 URI", "content": "You can import data from a CSV file hosted in an AWS S3 URI.\n\n.Import artists name and year information from an AWS S3 URI\n====\n\n.s3://aws-bucket/artists.csv\n[source, csv, filename=\"artists.csv\"]\n----\n1,ABBA,1992\n2,Roxette,1986\n3,Europe,1979\n4,The Cardigans,1992\n----\n\n.Query\n[source, cypher, role=test-skip]\n----\nLOAD CSV FROM 's3://aws-bucket/artists.csv' AS row\nMERGE (a:Artist {name: row[1], year: toInteger(row[2])})\nRETURN a.name, a.year\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| a.name | a.year\n| 'ABBA' | '1992'\n| 'Roxette' | '1986'\n| 'Europe' | '1979'\n| 'The Cardigans' | '1992'\n2+d|4 rows\n\nAdded 4 nodes, Set 8 properties, Added 4 labels\n|===\n====\n\n[[dynamic-columns]]"}, {"heading": "Import CSV files using dynamic columns", "content": "CSV columns can be referenced dynamically to map labels to nodes in the graph.\nThis enables flexible data handling, allowing labels to be be populated from CSV column values without manually specifying each entry.\nIt also mitigates the risk of Cypher injection.\n(For more information about Cypher injection, see link:https://neo4j.com/developer/kb/protecting-against-cypher-injection/[Neo4j Knowledge Base -> Protecting against Cypher injection]).\n\n.bands-with-headers.csv\n[source, csv, filename=\"bands-with-headers.csv\"]\n----\nId,Label,Name\n1,Band,The Beatles\n2,Band,The Rolling Stones\n3,Band,Pink Floyd\n4,Band,Led Zeppelin\n----\n\n.Query\n// tag::clauses_load_csv_dynamic_columns[]\n[source, cypher]\n----\nLOAD CSV WITH HEADERS FROM 'file:///bands-with-headers.csv' AS line\nMERGE (n:$(line.Label) {name: line.Name})\nRETURN n AS bandNodes\n----\n// end::clauses_load_csv_dynamic_columns[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| bandNodes\n\n| (:Band {name: 'The Beatles'})\n| (:Band {name: 'The Rolling Stones'})\n| (:Band {name: 'Pink Floyd'})\n| (:Band {name: 'Led Zeppelin'})\n\n1+d|Rows: 4 +\nAdded 4 nodes, Set 4 properties, Added 4 labels\n|===\n\n[NOTE]\n`MERGE` queries using dynamic values may not be as performant as those using static values.\nThis is because the xref:planning-and-tuning/execution-plans.adoc[Cypher planner] uses statically available information when planning queries to determine whether to use an xref:indexes/search-performance-indexes/index.adoc[index] or not, and this is not possible when using dynamic values.\nFor more information, see xref:clauses/merge.adoc#dynamic-merge-caveats[`MERGE` using dynamic node labels and relationship types -> Performance caveats]."}, {"heading": "Import compressed CSV files", "content": "`LOAD CSV` can read local CSV files compressed with ZIP or gzip.\nZIP archives can have arbitrary directory structures but may only contain a single CSV file.\n\n.Import a CSV file from within a ZIP file\n[source, cypher, role=test-skip]\n----\nLOAD CSV FROM 'file:///artists.zip' AS row\nMERGE (:Artist {name: row[1], year: toInteger(row[2])})\n----\n\n[NOTE]\nYou can't load zipped CSV files from remote URLs."}, {"heading": "Import data from relational databases", "content": "If the source data comes from a relational model, it's worth evaluating how to gain the most from moving to a graph data model.\nBefore running the import, think about how the data can be modeled as a graph, and adapt its structure accordingly when running the import (see link:https://neo4j.com/docs/getting-started/data-modeling/tutorial-data-modeling/[Graph data modeling]).\n\nData from relational databases may consist of one or multiple CSV files, depending on the source database structure.\nA performant approach is to run multiple passes of `LOAD CSV` to import nodes separately from relationships.\n\n\n.Import from a single CSV file\n====\nThe source file link:https://data.neo4j.com/importing-cypher/books.csv[_books.csv_] contains information about both authors and books.\nFrom a graph perspective, these are nodes with different labels, so it takes different queries to load them.\n\nThe example executes multiple passes of `LOAD CSV` on that one file, and each pass focuses on the creation of _one_ entity type.\n\n.books.csv\n[source, csv, filename=\"books.csv\"]\n----\nid,title,author,publication_year,genre,rating,still_in_print,last_purchased\n19515,The Heights,Anne Conrad,2012,Comedy,5,true,2023/4/12 8:17:00\n39913,Starship Ghost,Michael Tyler,1985,Science Fiction|Horror,4.2,false,2022/01/16 17:15:56\n60980,The Death Proxy,Tim Brown,2002,Horror,2.1,true,2023/11/26 8:34:26\n18793,Chocolate Timeline,Mary R. Robb,1924,Romance,3.5,false,2022/9/17 14:23:45\n67162,Stories of Three,Eleanor Link,2022,Romance|Comedy,2,true,2023/03/12 16:01:23\n25987,Route Down Below,Tim Brown,2006,Horror,4.1,true,2023/09/24 15:34:18\n----\n\n.Query\n[source, cypher]\n----\n// Create `Book` nodes\nLOAD CSV WITH HEADERS FROM 'https://data.neo4j.com/importing-cypher/books.csv' AS row\nMERGE (b:Book {id: row.id, title: row.title})\nMERGE (a:Author {name: row.author});\n\n// Create `WROTE` relationships\nLOAD CSV WITH HEADERS FROM 'https://data.neo4j.com/importing-cypher/books.csv' AS row\nMATCH (a:Author{name: row.author})\nMATCH (b:Book{id: row.id})\nMERGE (a)-[:WROTE]->(b);\n----\n\n.Result\n[source, role=\"queryresult\"]\n----\nAdded 11 nodes, Set 17 properties, Added 11 labels\nCreated 6 relationships\n----\n====\n\n\n.Import from multiple CSV files\n====\nThe file link:https://data.neo4j.com/importing-cypher/acted_in.csv[_acted_in.csv_] contains data about the relationship between actors and the movies they acted in (from link:https://data.neo4j.com/importing-cypher/persons.csv[_persons.csv_] and link:https://data.neo4j.com/importing-cypher/movies.csv[_movies.csv_]).\nActors and movies are linked through their ID columns `person_tmdbId` and `movieId`.\n\nThe file also contains the role the actor played in the movie, and it is imported in Neo4j as a relationship property.\n\n.acted_in.csv\n[source, csv, filename=\"acted_in.csv\"]\n----\nmovieId,person_tmdbId,role\n1,12899,Slinky Dog (voice)\n1,12898,Buzz Lightyear (voice)\n...\n----\n\nIt takes three `LOAD CSV` clauses to import this dataset: the first two  create `Person` nodes from _persons.csv_ and `Movie` nodes from _movies.csv_, and the third adds the `:ACTED_IN` relationship from _acted_in.csv_.\n\n.Query\n[source, cypher]\n----\n// Create person nodes\nLOAD CSV WITH HEADERS FROM 'https://data.neo4j.com/importing-cypher/persons.csv' AS row\nMERGE (p:Person {name: row.name, tmdbId: row.person_tmdbId});\n\n// Create movie nodes\nLOAD CSV WITH HEADERS FROM 'https://data.neo4j.com/importing-cypher/movies.csv' AS row\nMERGE (m:Movie {movieId: row.movieId, title: row.title});\n\n// Create relationships\nLOAD CSV WITH HEADERS FROM 'https://data.neo4j.com/importing-cypher/acted_in.csv' AS row\nMATCH (p:Person {tmdbId: row.person_tmdbId})\nMATCH (m:Movie {movieId: row.movieId})\nMERGE (p)-[r:ACTED_IN {role: row.role}]->(m);\n----\n\n.Result\n[source, role=\"queryresult\"]\n----\nAdded 444 nodes, Set 888 properties, Added 444 labels\nAdded 93 nodes, Set 186 properties, Added 93 labels\nCreated 372 relationships, Set 372 properties\n----\n====\n\n[TIP]\nFor a guide on importing the Northwind dataset from Postgres into Neo4j, see link:https://neo4j.com/docs/getting-started/data-import/import-relational-and-etl/[Tutorial: Import data from a relational database into Neo4j] in the Getting Started Guide."}, {"heading": "Create additional node labels", "content": "In Neo4j a node can have multiple labels, while in a relational setting it's not as straightforward to mix entities.\nFor example, a node in Neo4j can be labeled both `Dog` and `Actor`, while in a relational model dogs and actors are separate entities.\n\nAfter a relational dataset has been imported, there may be further labels that can be added, depending on the use case.\nAdditional labels can speed up pinpointing a node if you use them in your queries.\n\n.Add extra `Actor` label on `Person` nodes\n====\nThe `:ACTED_IN` relationship from _acted_in.csv_ implicitly defines actors as a subset of people.\nThe following queries adds an additional `Actor` label to all people who have an outgoing `:ACTED_IN` relationship.\n\n.Query\n[source, cypher]\n----\nMATCH (p:Person)-[:ACTED_IN]->()\nWITH DISTINCT p\nSET p:Actor\n----\n\n.Result\n[source, role=\"queryresult\"]\n----\nAdded 353 labels\n----\n===="}, {"heading": "Pre-process the data during import", "content": ""}, {"heading": "Cast CSV columns to Neo4j data types", "content": "`LOAD CSV` inserts all imported CSV data as `STRING` properties.\nHowever, Neo4j supports a range of xref:values-and-types/index.adoc[data types], and storing data with appropriate types allows both to query it more effectively and to process it with type-specific Cypher functions.\n\n.Import numeric and temporal data\n====\nThe column `person_tmdbId` and `born` in the file link:https://data.neo4j.com/importing-cypher/persons.csv[_persons.csv_] contains `INTEGER` and `DATE` values respectively.\nThe functions `toInteger()` and `date()` allow to cast those values to the appropriate types before importing them.\n\n.persons.csv\n[source, csv, filename=\"persons.csv\"]\n----\nperson_tmdbId,bio,born,bornIn,died,person_imdbId,name,person_poster,person_url\n3,\"Legendary Hollywood Icon Harrison Ford was born on July 13,1942 in Chicago, Illinois.  His familyhistory includes a strong lineage of actors, radio personalities, and models.  Harrison attended public high school in ParkRidge, Illinois where he was a member of the school Radio Station WMTH. Harrison worked as the lead voice for sports reporting at WMTH for severalyears.  Acting wasnt a major interest toFord until his junior year at Ripon College when he first took an acting class...\",1942-07-13,\"Chicago, Illinois, USA\",,148,Harrison Ford,https://image.tmdb.org/t/p/w440_and_h660_face/5M7oN3sznp99hWYQ9sX0xheswWX.jpg,https://themoviedb.org/person/3\n...\n----\n\n.Query\n[source, cypher]\n----\nLOAD CSV WITH HEADERS FROM 'https://data.neo4j.com/importing-cypher/persons.csv' AS row\nMERGE (p:Person {tmdbId: toInteger(row.person_tmdbId)})\nSET p.name = row.name, p.born = date(row.born)\nRETURN\n  p.name AS name,\n  p.tmdbId AS tmdbId,\n  p.born AS born\nLIMIT 5\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"3*<m\"]\n|===\n| name | tmdbId | born\n| 'Harrison Ford' | 3      | 1942-07-13\n| 'Tom Hanks'     | 31     | 1956-07-09\n| 'Robin Wright'  | 32     | 1966-04-08\n| 'Sally Field'   | 35     | 1946-11-06\n| 'Sean Bean'     | 48     | 1959-04-17\n3+d|5 rows\n\nAdded 444 nodes, Set 1332 properties, Added 444 labels\n|===\n====\n\nFor a list of type casting functions, see xref:values-and-types/casting-data.adoc[Casting data values]."}, {"heading": "Handle `null` values", "content": "Neo4j does not store `null` values.\n`null` or empty fields in a CSV files can be skipped or replaced with default values in `LOAD CSV`.\n\n.Processing a file with `null` values\n====\nIn the file `companies.csv`, some rows do not specify values for some columns.\nThe examples show several options of how to handle `null` values.\n\n[NOTE]\nThe queries in this example use xref:clauses/filter.adoc#filter-with-where[`FILTER`] (introduced in Neo4j 2025.06) as a replacement for `WITH * WHERE <predicate>`.\n\n.companies.csv\n[source, csv, filename=\"companies.csv\"]\n----\nId,Name,Location,Email,BusinessType\n1,Neo4j,San Mateo,contact@neo4j.com,P\n2,AAA,,info@aaa.com,\n3,BBB,Chicago, ,G\n,CCC,Michigan,info@ccc.com,G\n----\n\n.Skip `null` values\n[source, cypher]\n----\nLOAD CSV WITH HEADERS FROM 'file:///companies.csv' AS row\nFILTER row.Id IS NOT NULL\nMERGE (c:Company {id: row.Id})\n----\n\n.Provide a default for `null` values\n[source, cypher]\n----\nLOAD CSV WITH HEADERS FROM 'file:///companies.csv' AS row\nFILTER row.Id IS NOT NULL\nMERGE (c:Company {id: row.Id, hqLocation: coalesce(row.Location, \"Unknown\")})\n----\n\n.Change empty `STRING` values to `null` values (not stored)\n[source, cypher]\n----\nLOAD CSV WITH HEADERS FROM 'file:///companies.csv' AS row\nFILTER row.Id IS NOT NULL\nMERGE (c:Company {id: row.Id})\nSET c.email = nullIf(trim(row.Email), \"\")\n----\n====\n\n[TIP]\n`null` values are not stored in the database.\nA strategy for selectively getting rid of some values is to map them into `null` values.\nThe empty `STRING` values from the last query serve as an example."}, {"heading": "Split list values", "content": "The function `split()` allows to convert a `STRING` of elements into a list.\n\n.Parse movies languages and genres as lists\n====\nThe file link:https://data.neo4j.com/importing-cypher/movies.csv[_movies.csv_] contains a header line and a total of 94 lines.\n\nThe columns `languages` and `genres` contain list-like values.\nBoth are separated by a pipe `|`, and `split()` allows to make them into Cypher lists ahead of inserting them into the database.\n\n.movies.csv\n[source, csv, filename=\"movies.csv\"]\n----\nmovieId,title,budget,countries,movie_imdbId,imdbRating,imdbVotes,languages,plot,movie_poster,released,revenue,runtime,movie_tmdbId,movie_url,year,genres\n1,Toy Story,30000000.0,USA,114709,8.3,591836,English,A cowboy doll is profoundly threatened and jealous when a new spaceman figure supplants him as top toy in a boy's room.,https://image.tmdb.org/t/p/w440_and_h660_face/uXDfjJbdP4ijW5hWSBrPrlKpxab.jpg,1995-11-22,373554033.0,81,862,https://themoviedb.org/movie/862,1995,Adventure|Animation|Children|Comedy|Fantasy\n2,Jumanji,65000000.0,USA,113497,6.9,198355,English|French,\"When two kids find and play a magical board game, they release a man trapped for decades in it and a host of dangers that can only be stopped by finishing the game.\",https://image.tmdb.org/t/p/w440_and_h660_face/vgpXmVaVyUL7GGiDeiK1mKEKzcX.jpg,1995-12-15,262797249.0,104,8844,https://themoviedb.org/movie/8844,1995,Adventure|Children|Fantasy\n...\n----\n\n.Query\n[source, cypher]\n----\nLOAD CSV WITH HEADERS FROM 'https://data.neo4j.com/importing-cypher/movies.csv' AS row\nMERGE (m:Movie {id: toInteger(row.movieId)})\nSET \n    m.title = row.title,\n    m.imdbId = toInteger(row.movie_imdbId),\n    m.languages = split(row.languages, '|'), \n    m.genres = split(row.genres, '|')\nRETURN\n  m.title AS title,\n  m.imdbId AS imdbId,\n  m.languages AS languages,\n  m.genres AS genres\nLIMIT 5\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"4*<m\"]\n|===\n| title                         | imdbId | languages             | genres                                                      \n| 'Toy Story'                   | 114709 | ['English']           | ['Adventure', 'Animation', 'Children', 'Comedy', 'Fantasy']\n| 'Jumanji'                     | 113497 | ['English', 'French'] | ['Adventure', 'Children', 'Fantasy']                       \n| 'Grumpier Old Men'            | 113228 | ['English']           | ['Comedy', 'Romance\"]                                      \n| 'Waiting to Exhale'           | 114885 | ['English']           | ['Comedy', 'Romance', 'Drama']                             \n| 'Father of the Bride Part II' | 113041 | ['English']           | ['Comedy']                                                 \n4+d|5 rows\n\nAdded 93 nodes, Set 465 properties, Added 93 labels\n|===\n====\n\nFor more `STRING` manipulation functions, see xref:functions/string.adoc[String functions]."}, {"heading": "Recommendations", "content": ""}, {"heading": "Create property uniqueness constraints", "content": "Always create xref:schema/constraints/create-constraints.adoc#create-property-uniqueness-constraints[property uniqueness constraints] prior to importing data, to avoid duplicates or colliding entities.\nIf the source file contains duplicated data and the right constraints are in place, Cypher raises an error.\n\n.Create a node property uniqueness constraints on person ID\n====\n\n.persons.csv\n[source, csv, filename=\"persons.csv\"]\n----\nperson_tmdbId,bio,born,bornIn,died,person_imdbId,name,person_poster,person_url\n3,\"Legendary Hollywood Icon Harrison Ford was born on July 13,1942 in Chicago, Illinois.  His familyhistory includes a strong lineage of actors, radio personalities, and models.  Harrison attended public high school in ParkRidge, Illinois where he was a member of the school Radio Station WMTH. Harrison worked as the lead voice for sports reporting at WMTH for severalyears.  Acting wasnt a major interest toFord until his junior year at Ripon College when he first took an acting class...\",1942-07-13,\"Chicago, Illinois, USA\",,148,Harrison Ford,https://image.tmdb.org/t/p/w440_and_h660_face/5M7oN3sznp99hWYQ9sX0xheswWX.jpg,https://themoviedb.org/person/3\n...\n----\n\n.Create a node property uniqueness constraint on person ID\n[source, cypher]\n----\nCREATE CONSTRAINT Person_tmdbId IF NOT EXISTS\nFOR (p:Person) REQUIRE p.tmdbId IS UNIQUE\n----\n\n.Result\n[source, role=\"queryresult\"]\n----\nAdded 1 constraints\n----\n===="}, {"heading": "Handle large amounts of data", "content": "`LOAD CSV` may run into memory issues with files containing a significant number of rows (approaching hundreds of thousands or millions). For large files, it's recommended to split the import process in several lighter transactions through the clause xref:subqueries/subqueries-in-transactions.adoc[`CALL {...} IN TRANSACTIONS`].\n\n.Load a large CSV file in several transactions\n====\nThe file link:https://data.neo4j.com/importing-cypher/persons.csv[_persons.csv_] contains a header line and a total of 869 lines.\nThe example loads the `name` and `born` columns in transactions of 200 rows.\n\n.persons.csv\n[source, csv, filename=\"persons.csv\"]\n----\nperson_tmdbId,bio,born,bornIn,died,person_imdbId,name,person_poster,person_url\n3,\"Legendary Hollywood Icon Harrison Ford was born on July 13,1942 in Chicago, Illinois.  His familyhistory includes a strong lineage of actors, radio personalities, and models.  Harrison attended public high school in ParkRidge, Illinois where he was a member of the school Radio Station WMTH. Harrison worked as the lead voice for sports reporting at WMTH for severalyears.  Acting wasnt a major interest toFord until his junior year at Ripon College when he first took an acting class...\",1942-07-13,\"Chicago, Illinois, USA\",,148,Harrison Ford,https://image.tmdb.org/t/p/w440_and_h660_face/5M7oN3sznp99hWYQ9sX0xheswWX.jpg,https://themoviedb.org/person/3\n...\n----\n\n[NOTE]\nThe below query uses a xref:subqueries/call-subquery.adoc#variable-scope-clause[variable scope clause] to import variables into the `CALL` subquery.\n\n.Query\n// tag::clauses_load_csv_transactions[]\n[source, cypher]\n----\nLOAD CSV WITH HEADERS FROM 'https://data.neo4j.com/importing-cypher/persons.csv' AS row\nCALL (row) {\n  MERGE (p:Person {tmdbId: row.person_tmdbId})\n  SET p.name = row.name, p.born = row.born\n} IN TRANSACTIONS OF 200 ROWS\n----\n// end::clauses_load_csv_transactions[]\n\n.Result\n[source, role=\"queryresult\"]\n----\nAdded 444 nodes, Set 1332 properties, Added 444 labels\n----\n====\n\n[NOTE]\nIn case of errors, `CALL {...} IN TRANSACTIONS` may only import a part of the CSV data as the transactions are _committed_.\nFor example, if the first 200 rows are error free, they are committed.\nIf the next 200 rows contain data that causes an error, the second transaction fails, but leaves the first transaction unaffected."}, {"heading": "LOAD CSV and Neo4j functions", "content": ""}], "source_file": "modules\\ROOT\\pages\\clauses\\load-csv.adoc", "authority_level": 1}
{"name": "MATCH", "description": "The `MATCH` clause is used to search for the pattern described in it.", "syntax_examples": ["CREATE (charlie:Person:Actor {name: 'Charlie Sheen'}),\n       (martin:Person:Actor {name: 'Martin Sheen'}),\n       (michael:Person:Actor {name: 'Michael Douglas'}),\n       (oliver:Person:Director {name: 'Oliver Stone'}),\n       (rob:Person:Director {name: 'Rob Reiner'}),\n       (wallStreet:Movie {title: 'Wall Street'}),\n       (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),\n       (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),\n       (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),\n       (oliver)-[:DIRECTED]->(wallStreet),\n       (thePresident:Movie {title: 'The American President'}),\n       (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),\n       (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),\n       (rob)-[:DIRECTED]->(thePresident)", "MATCH (n)\nRETURN n", "MATCH (movie:Movie)\nRETURN movie.title", "MATCH (n:Movie|Person)\nRETURN n.name AS name, n.title AS title", "MATCH (n:!Movie)\nRETURN labels(n) AS label, count(n) AS labelCount", "MATCH (:Person {name: 'Oliver Stone'})--(n)\nRETURN n AS connectedNodes", "MATCH (:Person {name: 'Oliver Stone'})-->(movie:Movie)\nRETURN movie.title AS movieTitle", "MATCH (:Person {name: 'Oliver Stone'})-[r]->()\nRETURN type(r) AS relType", "MATCH (a)-[:ACTED_IN {role: 'Bud Fox'}]-(b)\nRETURN a, b", "MATCH (:Movie {title: 'Wall Street'})<-[:ACTED_IN]-(actor:Person)\nRETURN actor.name AS actor"], "sections": [{"heading": "Example graph", "content": "The following graph is used for the examples below:\n\nimage::graph-match-clause.svg[Example graph connecting Person and Movie nodes,role=popup,width=600]\n\nTo recreate the graph, run the following query against an empty Neo4j database:\n\n[source, cypher, role=test-setup]\n----\nCREATE (charlie:Person:Actor {name: 'Charlie Sheen'}),\n       (martin:Person:Actor {name: 'Martin Sheen'}),\n       (michael:Person:Actor {name: 'Michael Douglas'}),\n       (oliver:Person:Director {name: 'Oliver Stone'}),\n       (rob:Person:Director {name: 'Rob Reiner'}),\n       (wallStreet:Movie {title: 'Wall Street'}),\n       (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),\n       (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),\n       (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),\n       (oliver)-[:DIRECTED]->(wallStreet),\n       (thePresident:Movie {title: 'The American President'}),\n       (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),\n       (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),\n       (rob)-[:DIRECTED]->(thePresident)\n----\n\n[[find-nodes]]"}, {"heading": "Find nodes", "content": "The `MATCH` clause allows you to specify node patterns of varying complexity to retrieve from a graph.\nFor more information about finding node patterns, see xref:patterns/fixed-length-patterns#node-patterns[Patterns -> Node patterns].\n\n[[find-all-nodes]]"}, {"heading": "Find all nodes", "content": "By specifying a pattern with a single node and no labels, all nodes in the graph will be returned.\n\n.Find all nodes in a graph\n// tag::clauses_match_all_nodes[]\n[source, cypher]\n----\nMATCH (n)\nRETURN n\n----\n// end::clauses_match_all_nodes[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| n\n| (:Person {\"name\":\"Charlie Sheen\"})\n| (:Person {\"name\":\"Martin Sheen\"})\n| (:Person {\"name\":\"Michael Douglas\"})\n| (:Person {\"name\":\"Oliver Stone\"})\n| (:Person {\"name\":\"Rob Reiner\"})\n| (:Movie {\"title\":\"Wall Street\"})\n| (:Movie {\"title\":\"The American President\"})\n1+d| Rows: 7\n|===\n\n\n[[find-nodes-with-label]]"}, {"heading": "Find nodes with a specific label", "content": ".Find all nodes with the `Movie` label\n// tag::clauses_match_label[]\n[source, cypher]\n----\nMATCH (movie:Movie)\nRETURN movie.title\n----\n// end::clauses_match_label[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| movie.title\n| \"Wall Street\"\n| \"The American President\"\n1+d| Rows: 2\n|===\n\n\n[[match-node-label-expressions]]"}, {"heading": "MATCH using node label expressions", "content": ".Node pattern using the `OR` (`|`) label expression\n// tag::clauses_match_label_expression_or[]\n[source, cypher]\n----\nMATCH (n:Movie|Person)\nRETURN n.name AS name, n.title AS title\n----\n// end::clauses_match_label_expression_or[]\n\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| name | title\n| \"Charlie Sheen\" | <null>\n| \"Martin Sheen\" | <null>\n| \"Michael Douglas\" | <null>\n| \"Oliver Stone\" | <null>\n| \"Rob Reiner\" | <null>\n| <null> | \"Wall Street\"\n| <null> | \"The American President\"\n2+d| Rows: 7\n|===\n\n.Node pattern using negation (`!`) label expression\n// tag::clauses_match_label_expression_negation[]\n[source, cypher]\n----\nMATCH (n:!Movie)\nRETURN labels(n) AS label, count(n) AS labelCount\n----\n// end::clauses_match_label_expression_negation[]\n\n\n[NOTE]\nThe above query uses the xref:functions/list.adoc#functions-labels[`labels()`] and xref:functions/aggregating.adoc#functions-count[`count()`] functions.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| label | labelCount\n| [\"Person\", \"Actor\"] | 3\n| [\"Person\", \"Director\"] | 2\n\n2+d| Rows: 2\n|===\n\nFor a list of all label expressions supported by Cypher, see xref:patterns/reference.adoc#label-expressions[Patterns -> Label expressions].\n\n[[find-relationships]]"}, {"heading": "Find relationships", "content": "The `MATCH` clause allows you to specify relationship patterns of varying complexity to retrieve from a graph.\nUnlike a node pattern, a relationship pattern cannot be used in a `MATCH` clause without node patterns at both ends.\nFor more information about relationship patterns, see xref:patterns/fixed-length-patterns#relationship-patterns[Patterns -> Relationship patterns].\n\n[NOTE]\nCypher default match mode, `DIFFERENT RELATIONSHIPS`, will only match a relationship once inside a single pattern.\nThe same is not true for the `REPEATABLE ELEMENTS` match mode.\nFor more information, see xref::patterns/match-modes.adoc[Match modes]\n\n[[empty-relationship-patterns]]"}, {"heading": "Empty relationship patterns", "content": "By applying `--`, a pattern will be matched for a relationship with any direction and without any filtering on relationship types or properties.\n\n.Find connected nodes using an empty relationship pattern\n[source, cypher]\n----\nMATCH (:Person {name: 'Oliver Stone'})--(n)\nRETURN n AS connectedNodes\n----\n\n.Result\n[source, role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| connectedNodes\n| (:Movie {title: \"Wall Street\"})\n1+d| Rows: 1\n|===\n\n[[directed-relationship-patterns]]"}, {"heading": "Directed relationship patterns", "content": "The direction of a relationship in a pattern is indicated by arrows: `+-->+` or `+<--+`.\n\n.Find all nodes connected to `Oliver Stone` by an outgoing relationship.\n[source, cypher]\n----\nMATCH (:Person {name: 'Oliver Stone'})-->(movie:Movie)\nRETURN movie.title AS movieTitle\n----\n\n.Result\n[source, role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| movieTitle\n| \"Wall Street\"\n1+d| Rows: 1\n|===\n\n[[relationship-variables]]"}, {"heading": "Relationship variables", "content": "It is possible to introduce a variable to a pattern, either for filtering on relationship properties or to return a relationship.\n\n.Find the types of an aliased relationship\n// tag::clauses_match_relationship_types[]\n[source, cypher]\n----\nMATCH (:Person {name: 'Oliver Stone'})-[r]->()\nRETURN type(r) AS relType\n----\n// end::clauses_match_relationship_types[]\n\n[NOTE]\nThe above query uses the xref:functions/scalar.adoc#functions-type[`type()` function].\n\n.Result\n[source, role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| relType\n| \"DIRECTED\"\n1+d| Rows: 1\n|===\n\n[[undirected-relationships]]"}, {"heading": "MATCH on an undirected relationship", "content": "When a pattern contains a bound relationship, and that relationship pattern does not specify direction, Cypher will match the relationship in both directions.\n\n.Relationship pattern without direction\n[source, cypher]\n----\nMATCH (a)-[:ACTED_IN {role: 'Bud Fox'}]-(b)\nRETURN a, b\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| a | b\n\n| (:Movie {\"title\":\"Wall Street\"})\n| (:Person {\"name\":\"Charlie Sheen\"})\n\n| (:Person {\"name\":\"Charlie Sheen\"})\n| (:Movie {\"title\":\"Wall Street\"})\n\n2+d| Rows: 2\n|===\n\n[[match-on-relationship-type]]"}, {"heading": "Filter on relationship types", "content": "It is possible to specify the type of a relationship in a relationship pattern by using a colon (`:`) before the relationship type.\n\n.Relationship pattern filtering on the `ACTED_IN` relationship type\n// tag::clauses_match_relationship[]\n[source, cypher]\n----\nMATCH (:Movie {title: 'Wall Street'})<-[:ACTED_IN]-(actor:Person)\nRETURN actor.name AS actor\n----\n// end::clauses_match_relationship[]\n\n.Result\n[source, role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| actor\n| \"Michael Douglas\"\n| \"Martin Sheen\"\n| \"Charlie Sheen\"\n1+d| Rows: 3\n|===\n\n[[match-relationship-type-expressions]]"}, {"heading": "MATCH using relationship type expressions", "content": "It is possible to match a pattern containing one of several relationship types using the `OR` symbol, `|`.\n\n.Relationship pattern including either `ACTED_IN` or `DIRECTED` relationship types\n// tag::clauses_match_type_expression_or[]\n[source, cypher]\n----\nMATCH (:Movie {title: 'Wall Street'})<-[:ACTED_IN|DIRECTED]-(person:Person)\nRETURN person.name AS person\n----\n// end::clauses_match_type_expression_or[]\n\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| person\n| \"Oliver Stone\"\n| \"Michael Douglas\"\n| \"Martin Sheen\"\n| \"Charlie Sheen\"\n1+d| Rows: 4\n|===\n\nAs relationships can only have exactly one type each, `()-[:A&B]->()` will never match a relationship.\n\nFor a list of all relationship type expressions supported by Cypher, see xref:patterns/reference.adoc#label-expressions[Patterns -> Label expressions].\n\n[[multiple-relationships]]"}, {"heading": "Find multiple relationships", "content": "A graph pattern can contain several relationship patterns.\n\n.Graph pattern including several relationship patterns\n[source, cypher]\n----\nMATCH (:Person {name: 'Charlie Sheen'})-[:ACTED_IN]->(movie:Movie)<-[:DIRECTED]-(director:Person)\nRETURN movie.title AS movieTitle, director.name AS director\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| movieTitle | director\n| \"Wall Street\" | \"Oliver Stone\"\n2+d| Rows: 1\n|===\n\n[[where-predicates]]"}, {"heading": "MATCH with WHERE predicates", "content": "The `MATCH` clause is often paired with a `WHERE` sub-clause, which adds predicates to refine the patterns, making them more specific.\nThese predicates are part of the pattern itself, not just filters applied after matching.\nThus, always place the `WHERE` clause with its corresponding `MATCH` clause.\n\n.Simple `WHERE` predicate\n[source, cypher]\n----\nMATCH (charlie:Person)-[:ACTED_IN]->(movie:Movie)\nWHERE charlie.name = 'Charlie Sheen'\nRETURN movie.title AS movieTitle\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| movieTitle\n| \"Wall Street\"\n1+d| Rows: 1\n|===\n\n.More complex `WHERE` predicate\n[source, cypher]\n----\nMATCH (martin:Person)-[:ACTED_IN]->(movie:Movie)\nWHERE martin.name = 'Martin Sheen' AND NOT EXISTS {\n    MATCH (movie)<-[:DIRECTED]-(director:Person {name: 'Oliver Stone'})\n}\nRETURN movie.title AS movieTitle\n----\n\n[NOTE]\nThe above query uses an xref:subqueries/existential.adoc[`EXISTS` subquery].\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| movieTitle\n| \"The American President\"\n1+d| Rows: 1\n|===\n\nFor more information, see the xref:clauses/where.adoc[`WHERE`] page.\n\n[[parameters]]"}, {"heading": "MATCH with parameters", "content": "The `MATCH` clause can be used with parameters.\n\n.Parameters\n[source, parameters]\n----\n{\n  \"movieTitle\": \"Wall Street\",\n  \"actorRole\": \"Fox\"\n}\n----\n\n.Find nodes using paramters\n[source, cypher]\n----\nMATCH (:Movie {title: $movieTitle})<-[r:ACTED_IN]-(p:Person)\nWHERE r.role CONTAINS $actorRole\nRETURN p.name AS actor, r.role AS role\n----\n\n[NOTE]\nThe above query uses the xref:expressions/predicates/string-operators.adoc[`CONTAINS` operator].\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| actor | role\n\n| \"Charlie Sheen\" | \"Bud Fox\"\n| \"Martin Sheen\"  | \"Carl Fox\"\n\n2+d|Rows: 2\n|===\n\nFor more information about how to set parameters, see xref:syntax/parameters.adoc[Syntax -> Parameters].\n\n[[find-paths]]"}, {"heading": "Find paths", "content": "The `MATCH` clause can also be used to bind whole paths to variables.\n\n.Find all paths matching a pattern\n// tag::clauses_match_path[]\n[source, cypher]\n----\nMATCH path = ()-[:ACTED_IN]->(movie:Movie)\nRETURN path\n----\n// end::clauses_match_path[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| path\n| (:Person {name: \"Charlie Sheen\"})-[:ACTED_IN {role: \"Bud Fox\"}]->(:Movie {title: \"Wall Street\"}) \n| (:Person {name: \"Martin Sheen\"})-[:ACTED_IN {role: \"Carl Fox\"}]->(:Movie {title: \"Wall Street\"})\n| (:Person {name: \"Martin Sheen\"})-[:ACTED_IN {role: \"A.J. MacInerney\"}]->(:Movie {title: \"The American President\"})\n| (:Person {name: \"Michael Douglas\"})-[:ACTED_IN {role: \"Gordon Gekko\"}]->(:Movie {title: \"Wall Street\"})\n| (:Person {name: \"Michael Douglas\"})-[:ACTED_IN {role: \"President Andrew Shepherd\"}]->(:Movie {title: \"The American President\"})\n1+d| Rows: 5\n|===\n\n\n.Find paths matching a pattern including a `WHERE` predicate\n[source, cypher]\n----\nMATCH path = (:Person)-[:ACTED_IN]->(movie:Movie)<-[:DIRECTED]-(:Person)\nWHERE movie.title = 'Wall Street'\nRETURN path\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| path\n| (:Person {name: \"Charlie Sheen\"})-[:ACTED_IN {role: \"Bud Fox\"}]->(:Movie {title: \"Wall Street\"})<-[:DIRECTED]-(:Person {name: \"Oliver Stone\"})\n| (:Person {name: \"Martin Sheen\"})-[:ACTED_IN {role: \"Carl Fox\"}]->(:Movie {title: \"Wall Street\"})<-[:DIRECTED]-(:Person {name: \"Oliver Stone\"})\n| (:Person {name: \"Michael Douglas\"})-[:ACTED_IN {role: \"Gordon Gekko\"}]->(:Movie {title: \"Wall Street\"})<-[:DIRECTED]-(:Person {name: \"Oliver Stone\"})\n1+d| Rows: 3\n|===\n\nFor more information about how `MATCH` is used to find patterns of varying complexity (including xref:patterns/variable-length-patterns.adoc#quantified-path-patterns[quantified path patterns], xref:patterns/variable-length-patterns.adoc#quantified-relationships[quantified relationships], and the xref:patterns/shortest-paths.adoc[shortest paths] between nodes), see the section on xref::patterns/index.adoc[Patterns]."}, {"heading": "Multiple MATCH clauses, the WITH clause, and clause composition", "content": "In Cypher, the behavior of a query is defined by its clauses.\nEach clause takes the current graph state and a table of intermediate results, processes them, and passes the updated graph state and results to the next clause.\nThe first clause starts with the graph's initial state and an empty table, while the final clause produces the query result.\n\n.Chaining consecutive `MATCH` clauses\n[source, cypher]\n----\nMATCH (:Person {name: 'Martin Sheen'})-[:ACTED_IN]->(movie:Movie) // <1>\nMATCH (director:Person)-[:DIRECTED]->(movie) // <2>\nRETURN director.name AS director, movie.title AS movieTitle\n----\n<1> The result of the first `MATCH` clause is the variable `movie` which holds all the `Movies` that `Martin Sheen` has `ACTED_IN`.\n<2> The second `MATCH` clause uses the `movie` variable to find any `Person` node with a `DIRECTED` relationship to those `Movie` nodes that `Martin Sheen` has `ACTED_IN`.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| director | movieTitle\n\n| \"Oliver Stone\" | \"Wall Street\"\n| \"Rob Reiner\"   | \"The American President\"\n\n2+d| Rows: 2\n|===\n\nA variable can be implicitly carried over to the following clause by being referenced in another operation.\nA variable can also be explicitly passed to the following clause using the xref:clauses/with.adoc[`WITH`] clause.\nIf a variable is neither implicitly nor explicitly carried over to its following clause, it will be discarded and is not available for reference later in the query.\n\n.Using `WITH` and multiple `MATCH` clauses\n[source, cypher]\n----\nMATCH (actors:Person)-[:ACTED_IN]->(movies:Movie) // <1>\nWITH actors, count(movies) AS movieCount // <2>\nORDER BY movieCount DESC\nLIMIT 1 // <3>\nMATCH (actors)-[:ACTED_IN]->(movies) // <4>\nRETURN actors.name AS actor, movieCount, collect(movies.title) AS movies\n----\n<1> The `Person` and `Movie` nodes matched in this step are stored in variables, which are then passed on to the second row of the query.\n<2> The `movies` variable is implicitly imported by its occurrence in the `count()` function.\nThe `WITH` clause explicitly imports the `actors` variable.\n<3> An xref:clauses/order-by.adoc[`ORDER BY`] clause orders the results by `movieCount` in descending order, ensuring that the `Person` with the highest number of movies appears at the top, and xref:clauses/limit.adoc[`LIMIT`] `1` ensures that all other `Person` nodes are discarded.\n<4> The second `MATCH` clause finds all `Movie` nodes associated with the `Person` nodes currently bound to the `actors` variable.\n\n[NOTE]\nThe above query uses the xref:functions/aggregating.adoc#functions-collect[`collect()` function].\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"3*<m\"]\n|===\n| actor | movieCount | movies\n\n| \"Martin Sheen\" | 2 | [\"Wall Street\", \"The American President\"]\n3+d| Rows: 1\n\n|===\n\nFor more information about how Cypher queries work, see xref:clauses/clause-composition.adoc[].\n\n[[dynamic-match]]"}, {"heading": "MATCH using dynamic node labels and relationship types", "content": "Node labels and relationship types can be referenced dynamically in expressions, parameters, and variables when matching nodes and relationships.\nThis allows for more flexible queries and mitigates the risk of Cypher injection.\n(For more information about Cypher injection, see link:https://neo4j.com/developer/kb/protecting-against-cypher-injection/[Neo4j Knowledge Base -> Protecting against Cypher injection]).\n\n.Syntax for matching node labels dynamically\n[source, syntax]\n----\nMATCH (n:$(<expr>))\nMATCH (n:$any(<expr>))\nMATCH (n:$all(<expr>))\n----\n\n[NOTE]\n`MATCH (n:$all(<expr>))` is functionally equivalent to `MATCH (n:$(<expr>))`.\n\n.Syntax for matching relationship types dynamically\n[source, syntax]\n----\nMATCH ()-[r:$(<expr>))]->()\nMATCH ()-[r:$any(<expr>)]->()\nMATCH ()-[r:$all(<expr>))]->()\n----\n\nThe expression must evaluate to a `STRING NOT NULL | LIST<STRING NOT NULL> NOT NULL` value.\nIf you use a `LIST<STRING>` with more than one item in a relationship pattern with dynamic relationship types, no results will be returned.\nThis is because a relationship can only have exactly one type.\n\n.Match labels dynamically\n[source, cypher]\n----\nWITH [\"Person\", \"Director\"] AS labels\nMATCH (directors:$(labels))\nRETURN directors\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| directors\n\n| (:Person:Director {name: \"Oliver Stone\"})\n| (:Person:Director {name: \"Rob Reiner\"})\n\n1+d|Rows: 2\n|===\n\n.Match nodes dynamically using `any()`\n[source, cypher]\n----\nMATCH (n:$any([\"Movie\", \"Actor\"]))\nRETURN n AS nodes\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| nodes\n\n| (:Person:Actor {name: \"Charlie Sheen\"})\n| (:Person:Actor {name: \"Martin Sheen\"})\n| (:Person:Actor {name: \"Michael Douglas\"})\n| (:Movie {title: \"Wall Street\"})\n| (:Movie {title: \"The American President\"})\n\n1+d|Rows: 5\n|===\n\n\n.Parameter\n[source, parameters]\n----\n{\n  \"label\": \"Movie\"\n}\n----\n\n.Match nodes dynamically using a parameter\n// tag::clauses_match_dynamic_match_parameter[]\n[source, cypher]\n----\nMATCH (movie:$($label))\nRETURN movie.title AS movieTitle\n----\n// end::clauses_match_dynamic_match_parameter[]\n\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| movieTitle\n\n| \"Wall Street\"\n| \"The American President\"\n\n1+d|Rows: 2\n|===\n\n\n.Match relationships dynamically using a variable\n// tag::clauses_match_dynamic_match_variable[]\n[source, cypher]\n----\nCALL db.relationshipTypes()\nYIELD relationshipType\nMATCH ()-[r:$(relationshipType)]->()\nRETURN relationshipType, count(r) AS relationshipCount\n----\n// end::clauses_match_dynamic_match_variable[]\n\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| relationshipType | relationshipCount\n\n| \"ACTED_IN\" | 5\n| \"DIRECTED\" | 2\n\n2+d|Rows: 2\n|===\n\n[[dynamic-match-caveats]]"}, {"heading": "Performance caveats", "content": "`MATCH` queries that use dynamic values may not perform as well as those with static values.\nNeo4j is actively working to improve the performance of these queries.\nThe table below outlines performance caveats for specific Neo4j versions.\n\n.Neo4j versions and performance caveats\n[%header,cols=\"a,5a\"]\n|===\n| Neo4j versions | Performance caveat\n\n| 5.26 -- 2025.07\n| The xref:planning-and-tuning/execution-plans.adoc[Cypher planner] is not able to leverage xref:indexes/search-performance-indexes/index.adoc[indexes] with xref:planning-and-tuning/operators/operators-detail.adoc#leaf-operators[index scans or seeks] and must instead utilize the xref:planning-and-tuning/operators/operators-detail.adoc#query-plan-all-nodes-scan[`AllNodesScan`] operator, which reads all nodes from the node store and is therefore more costly.\n\n| 2025.08 -- 2025.10\n| The Cypher planner is able to leverage xref:indexes/search-performance-indexes/using-indexes.adoc#token-lookup-indexes[token lookup indexes] when matching node labels and relationship types dynamically.\nThis is enabled by the introduction of three new query plan operators: \nxref:planning-and-tuning/operators/operators-detail.adoc#query-plan-dynamic-label-node-lookup[`DynamicLabelNodeLookup`], xref:planning-and-tuning/operators/operators-detail.adoc#query-plan-dynamic-directed-relationship-type-lookup[`DynamicDirectedRelationshipTypeLookup`], and xref:planning-and-tuning/operators/operators-detail.adoc#query-plan-dynamic-undirected-relationship-type-lookup[`DynamicUndirectedRelationshipTypeLookup`].\nIt is not, however, able to use indexes on property values.\nFor example, `MATCH (n:$(Label) {foo: bar})` will not use any indexes on `n.foo` but can use a `DynamicLabelNodeLookup` on `$(label)`.\n\n| 2025.11 -- current\na| The Cypher planner is able to leverage indexes on property values, however:\n\n* It only supports exact seeks on range indexes (no full text or spatial).\n* The index order cannot be leveraged, so the planner must insert separate ordering if required later on in the query.\n* Parallel runtime seeks and scans are single-threaded.\n* The planner doesn't combine multiple property index seeks when generating the results for the dynamic part of the query. For example, using `$any` in combination with multiple labels that share an index on a property result in the operator choosing one of the indexes based on selectivity and then stepping through the seek results and filtering for the remainder of the expression.\n+ Example:\n+\n[source, cypher, role=test-skip]\n----\nCREATE RANGE INDEX actor_has_birthyear FOR (a:Actor) ON (a.birthYear)\nCREATE RANGE INDEX director_has_birthyear FOR (d:Director) ON (d.birthYear)\n\n// The below MATCH can leverage one of the indexes, but not both\nMATCH (p:$any([\"Actor\", \"Director\"]) { birthYear: 1983 }) RETURN p.name\n----\n\n|===\n\n[[further-reading]]"}, {"heading": "Further reading", "content": "link:https://medium.com/neo4j/cypher-dynamism-a-step-toward-simpler-and-more-secure-queries-70fab8a815b2[Neo4j Developer Blog: Cypher Dynamism: A Step Toward Simpler and More Secure Queries]"}], "source_file": "modules\\ROOT\\pages\\clauses\\match.adoc", "authority_level": 1}
{"name": "MERGE", "description": "The `MERGE` clause ensures that a pattern exists in the graph.", "syntax_examples": ["CREATE\n  (charlie:Person {name: 'Charlie Sheen', bornIn: 'New York', chauffeurName: 'John Brown'}),\n  (martin:Person {name: 'Martin Sheen', bornIn: 'Ohio', chauffeurName: 'Bob Brown'}),\n  (michael:Person {name: 'Michael Douglas', bornIn: 'New Jersey', chauffeurName: 'John Brown'}),\n  (oliver:Person {name: 'Oliver Stone', bornIn: 'New York', chauffeurName: 'Bill White'}),\n  (rob:Person {name: 'Rob Reiner', bornIn: 'New York', chauffeurName: 'Ted Green'}),\n  (wallStreet:Movie {title: 'Wall Street'}),\n  (theAmericanPresident:Movie {title: 'The American President'}),\n  (charlie)-[:ACTED_IN]->(wallStreet),\n  (martin)-[:ACTED_IN]->(wallStreet),\n  (michael)-[:ACTED_IN]->(wallStreet),\n  (martin)-[:ACTED_IN]->(theAmericanPresident),\n  (michael)-[:ACTED_IN]->(theAmericanPresident),\n  (oliver)-[:DIRECTED]->(wallStreet),\n  (rob)-[:DIRECTED]->(theAmericanPresident)", "MERGE (robert:Critic)\nRETURN labels(robert)", "MERGE (robert:Critic:Viewer)\nRETURN labels(robert)", "MERGE (robert:Critic&Viewer)\nRETURN labels(robert)", "MERGE (charlie {name: 'Charlie Sheen', age: 10})\nRETURN charlie", "MERGE (martin:Person {name: 'Martin Sheen', age: null})\nRETURN martin", "MERGE (michael:Person {name: 'Michael Douglas'})\nRETURN michael.name, michael.bornIn", "MATCH (person:Person)\nMERGE (location:Location {name: person.bornIn})\nRETURN person.name, person.bornIn, location", "MERGE (keanu:Person {name: 'Keanu Reeves', bornIn: 'Beirut', chauffeurName: 'Eric Brown'})\nON CREATE\n  SET keanu.created = timestamp()\nRETURN keanu.name, keanu.created", "MERGE (person:Person)\nON MATCH\n  SET person.found = true\nRETURN person.name, person.found"], "sections": [{"heading": "Introduction", "content": "The `MERGE` clause either matches existing node patterns in the graph and binds them or, if not present, creates new data and binds that.\nIn this way, it acts as a combination of `MATCH` and `CREATE` that allows for specific actions depending on whether the specified data was matched or created.\n\nFor example, `MERGE` can be used to specify that a graph must contain a node with a `Person` label and a specific `name` property.\nIf there isn't a node with the specific `name` property, a new node will be created with that `name` property.\n\n[NOTE]\n====\nFor performance reasons, creating a schema index on the label or property is highly recommended when using `MERGE`.\nSee xref:indexes/search-performance-indexes/create-indexes.adoc[] for more information.\n====\n\nWhen using `MERGE` on full patterns, the behavior is that either the whole pattern matches, or the whole pattern is created.\n`MERGE` will not partially use existing patterns.\nIf partial matches are needed, this can be accomplished by splitting a pattern into multiple `MERGE` clauses.\n\n[NOTE]\n====\nUnder concurrent updates, `MERGE` only guarantees the existence of the `MERGE` pattern, but not uniqueness.\nTo guarantee uniqueness of nodes with certain properties, a xref:schema/constraints/create-constraints.adoc#create-property-uniqueness-constraints[property uniqueness constraint] should be used.\nSee xref::clauses/merge.adoc#query-merge-using-unique-constraints[Using property uniqueness constraints with `MERGE`].\n====\n\nSimilar to `MATCH`, `MERGE` can match multiple occurrences of a pattern.\nIf there are multiple matches, they will all be passed on to later stages of the query.\n\nThe last part of a `MERGE` clause is the `ON CREATE` and/or `ON MATCH` operators.\nThese allow a query to express additional changes to the properties of a node or relationship, depending on whether the element was matched (`MATCH`) in the database or if it was created (`CREATE`)."}, {"heading": "Example graph", "content": "The following graph is used for the examples below:\n\nimage::graph-merge-clause.svg[Example graph connecting Person and Movie nodes,role=popup,width=600]\n\nTo recreate the graph, run the following query in an empty Neo4j database:\n\n[source, cypher, role=test-setup]\n----\nCREATE\n  (charlie:Person {name: 'Charlie Sheen', bornIn: 'New York', chauffeurName: 'John Brown'}),\n  (martin:Person {name: 'Martin Sheen', bornIn: 'Ohio', chauffeurName: 'Bob Brown'}),\n  (michael:Person {name: 'Michael Douglas', bornIn: 'New Jersey', chauffeurName: 'John Brown'}),\n  (oliver:Person {name: 'Oliver Stone', bornIn: 'New York', chauffeurName: 'Bill White'}),\n  (rob:Person {name: 'Rob Reiner', bornIn: 'New York', chauffeurName: 'Ted Green'}),\n  (wallStreet:Movie {title: 'Wall Street'}),\n  (theAmericanPresident:Movie {title: 'The American President'}),\n  (charlie)-[:ACTED_IN]->(wallStreet),\n  (martin)-[:ACTED_IN]->(wallStreet),\n  (michael)-[:ACTED_IN]->(wallStreet),\n  (martin)-[:ACTED_IN]->(theAmericanPresident),\n  (michael)-[:ACTED_IN]->(theAmericanPresident),\n  (oliver)-[:DIRECTED]->(wallStreet),\n  (rob)-[:DIRECTED]->(theAmericanPresident)\n----\n\n[[query-merge-node-derived]]"}, {"heading": "Merge nodes", "content": "[[merge-merge-single-node-with-a-label]]"}, {"heading": "Merge single node with a label", "content": "Merge a node with a specific label:\n\n.Query\n[source, cypher]\n----\nMERGE (robert:Critic)\nRETURN labels(robert)\n----\n\nA new node is created because there are no nodes labeled `Critic` in the database:\n\n.Result\n[role=\"queryresult\",options=\"header\",cols=\"1\"]\n|===\n| labels(robert)\n| [\"Critic\"]\n|===\n\n[[merge-merge-single-node-with-multiple-labels]]"}, {"heading": "Merge single node with multiple labels", "content": "Multiple labels are separated by colons:\n\n.Query\n[source, cypher]\n----\nMERGE (robert:Critic:Viewer)\nRETURN labels(robert)\n----\n\nA new node is created because there are no nodes labeled both `Critic` and `Viewer` in the database:\n\n.Result\n[role=\"queryresult\",options=\"header\",cols=\"1\"]\n|===\n| labels(robert)\n| [\"Critic\",\"Viewer\"]\n|===\n\nMultiple labels can also be separated by an ampersand `&`, in the same manner as it is used in xref:patterns/reference.adoc#label-expressions[label expressions].\nSeparation by colon `:` and ampersand `&` cannot be mixed in the same clause.\n\n.Query\n[source, cypher]\n----\nMERGE (robert:Critic&Viewer)\nRETURN labels(robert)\n----\n\nNo new node is created because there was already a node labeled both `Critic` and `Viewer` in the database:\n\n.Result\n[role=\"queryresult\",options=\"header\",cols=\"1\"]\n|===\n| labels(robert)\n| [\"Critic\",\"Viewer\"]\n|===\n\n[[merge-merge-single-node-with-properties]]"}, {"heading": "Merge single node with properties", "content": "Merging a node with properties that differ from the properties on existing nodes in the graph will create a new node:\n\n.Query\n[source, cypher]\n----\nMERGE (charlie {name: 'Charlie Sheen', age: 10})\nRETURN charlie\n----\n\nA new node with the name `Charlie Sheen` is created since not all properties matched those set to the pre-existing `Charlie Sheen` node:\n\n.Result\n[role=\"queryresult\",options=\"header\",cols=\"1*<m\"]\n|===\n| charlie\n| (:Person {\"name\":\"Charlie Sheen\", \"age\":10})\n|===\n\n\n[NOTE]\n====\n`MERGE` cannot be used for nodes with property values that are `null`.\nFor example, the following query will throw an error:\n\n.Query\n[source, cypher, role=test-fail]\n----\nMERGE (martin:Person {name: 'Martin Sheen', age: null})\nRETURN martin\n----\n\n.GQLSTATUS error chain\n[role=\"queryresult\",stripes=\"all\", cols=\"1\", ]\n|===\n| link:https://neo4j.com/docs/status-codes/current/errors/gql-errors/22N31/[22N31]: error: data exception - invalid properties in merge pattern. The node property `age` in '(:Person {age: null})' is invalid. 'MERGE' cannot be used with a graph element property value that is null.\n\nlink:https://neo4j.com/docs/status-codes/current/errors/gql-errors/22G03/[22G03]: error: data exception - invalid value type\n|===\n\n====\n\n[[merge-merge-single-node-specifying-both-label-and-property]]"}, {"heading": "Merge single node specifying both label and property", "content": "Merging a single node with both label and property matching an existing node will not create a new node:\n\n.Query\n[source, cypher]\n----\nMERGE (michael:Person {name: 'Michael Douglas'})\nRETURN michael.name, michael.bornIn\n----\n\n`Michael Douglas` is matched and the `name` and `bornIn` properties are returned:\n\n.Result\n[role=\"queryresult\",options=\"header\",cols=\"2*<m\"]\n|===\n| michael.name | michael.bornIn\n| \"Michael Douglas\" | \"New Jersey\"\n|===\n\n[[merge-merge-single-node-derived-from-an-existing-node-property]]"}, {"heading": "Merge single node derived from an existing node property", "content": "It is possible to merge nodes using existing node properties:\n\n.Query\n[source, cypher]\n----\nMATCH (person:Person)\nMERGE (location:Location {name: person.bornIn})\nRETURN person.name, person.bornIn, location\n----\n\nIn the above query, three nodes labeled `Location` are created, each of which contains a `name` property with the value of `New York`, `Ohio`, and `New Jersey` respectively.\nNote that even though the `MATCH` clause results in three bound nodes having the value `New York` for the `bornIn` property, only a single `New York` node (i.e. a `Location` node with a name of `New York`) is created.\nAs the `New York` node is not matched for the first bound node, it is created.\nHowever, the newly-created `New York` node is matched and bound for the second and third bound nodes.\n\n.Result\n[role=\"queryresult\",options=\"header\",cols=\"3*<m\"]\n|===\n| person.name | person.bornIn | location\n| \"Charlie Sheen\" | \"New York\" | {name:\"New York\"}\n| \"Martin Sheen\" | \"Ohio\" | {name:\"Ohio\"}\n| \"Michael Douglas\" | \"New Jersey\" | {name:\"New Jersey\"}\n| \"Oliver Stone\" | \"New York\" | {name:\"New York\"}\n| \"Rob Reiner\" | \"New York\" | {name:\"New York\"}\n|===\n\n[[query-merge-on-create-on-match]]"}, {"heading": "Use `ON CREATE` and `ON MATCH`", "content": "[[merge-merge-with-on-create]]"}, {"heading": "Merge with `ON CREATE`", "content": "Merge a node and set properties if the node needs to be created:\n\n.Query\n[source, cypher, role=test-result-skip]\n----\nMERGE (keanu:Person {name: 'Keanu Reeves', bornIn: 'Beirut', chauffeurName: 'Eric Brown'})\nON CREATE\n  SET keanu.created = timestamp()\nRETURN keanu.name, keanu.created\n----\n\nThe query creates the `Person` node named `Keanu Reeves`, with a `bornIn` property set to `Beirut` and a `chauffeurName` property set to `Eric Brown`.\nIt also sets a timestamp for the `created` property.\n\n.Result\n[role=\"queryresult\",options=\"header\",cols=\"2*<m\"]\n|===\n| keanu.name | keanu.created\n| \"Keanu Reeves\" | 1655200898563\n|===\n\n\n[[merge-merge-with-on-match]]"}, {"heading": "Merge with `ON MATCH`", "content": "Merging nodes and setting properties on found nodes:\n\n.Query\n[source, cypher]\n----\nMERGE (person:Person)\nON MATCH\n  SET person.found = true\nRETURN person.name, person.found\n----\n\nThe query finds all the `Person` nodes, sets a property on them, and returns them:\n\n.Result\n[role=\"queryresult\",options=\"header\",cols=\"2*<m\"]\n|===\n| person.name | person.found\n| \"Charlie Sheen\" | true\n| \"Martin Sheen\" | true\n| \"Michael Douglas\" | true\n| \"Oliver Stone\" | true\n| \"Rob Reiner\" | true\n| \"Keanu Reeves\" | true\n|===\n\n\n[[merge-merge-with-on-create-and-on-match]]"}, {"heading": "Merge with `ON CREATE` and `ON MATCH`", "content": ".Query\n[source, cypher, role=test-result-skip]\n----\nMERGE (keanu:Person {name: 'Keanu Reeves'})\nON CREATE\n  SET keanu.created = timestamp()\nON MATCH\n  SET keanu.lastSeen = timestamp()\nRETURN keanu.name, keanu.created, keanu.lastSeen\n----\n\nBecause the `Person` node named `Keanu Reeves` already exists, this query does not create a new node.\nInstead, it adds a timestamp on the `lastSeen` property.\n\n.Result\n[role=\"queryresult\",options=\"header\",cols=\"3*<m\"]\n|===\n| keanu.name | keanu.created | keanu.lastSeen\n| \"Keanu Reeves\" | 1655200902354 | 1674655352124\n|===\n\n\n[[merge-merge-with-on-match-setting-multiple-properties]]"}, {"heading": "Merge with `ON MATCH` setting multiple properties", "content": "If multiple properties should be set, separate them with commas:\n\n.Query\n[source, cypher, role=test-result-skip]\n----\nMERGE (person:Person)\nON MATCH\n  SET\n    person.found = true,\n    person.lastAccessed = timestamp()\nRETURN person.name, person.found, person.lastAccessed\n----\n\n.Result\n[role=\"queryresult\",options=\"header\",cols=\"3*<m\"]\n|===\n| person.name | person.found | person.lastAccessed\n| \"Charlie Sheen\" | true | 1655200903558\n| \"Martin Sheen\" | true | 1655200903558\n| \"Michael Douglas\" | true | 1655200903558\n| \"Oliver Stone\" | true | 1655200903558\n| \"Rob Reiner\" | true | 1655200903558\n| \"Keanu Reeves\" | true | 1655200903558\n|===\n\n\n[[query-merge-relationships]]"}, {"heading": "Merge relationships", "content": "[[merge-merge-on-a-relationship]]"}, {"heading": "Merge on a relationship", "content": "`MERGE` can be used to match or create a relationship:\n\n.Query\n[source, cypher]\n----\nMATCH\n  (charlie:Person {name: 'Charlie Sheen'}),\n  (wallStreet:Movie {title: 'Wall Street'})\nMERGE (charlie)-[r:ACTED_IN]->(wallStreet)\nRETURN charlie.name, type(r), wallStreet.title\n----\n\n`Charlie Sheen` had already been marked as acting in `Wall Street`, so the existing relationship is found and returned.\nNote that in order to match or create a relationship when using `MERGE`, at least one bound node must be specified, which is done via the `MATCH` clause in the above example.\n\n.Result\n[role=\"queryresult\",options=\"header\",cols=\"3*<m\"]\n|===\n| charlie.name | type(r) | wallStreet.title\n| \"Charlie Sheen\" | \"ACTED_IN\" | \"Wall Street\"\n|===\n\n[NOTE]\n====\n`MERGE` cannot be used for relationships with property values that are `null`.\nFor example, the following query will throw an error:\n\n.Query\n[source, cypher, role=test-fail]\n----\nMERGE (martin:Person {name: 'Martin Sheen'})-[r:FATHER_OF {since: null}]->(charlie:Person {name: 'Charlie Sheen'})\nRETURN type(r)\n----\n\n.GQLSTATUS error chain\n[role=\"queryresult\",stripes=\"all\", cols=\"1\", ]\n|===\n| link:https://neo4j.com/docs/status-codes/current/errors/gql-errors/22N31/[22N31]: error: data exception - invalid properties in merge pattern. The relationship property `since` in '(martin)-[:FATHER_OF {since: null}]->(charlie)' is invalid. 'MERGE' cannot be used with a graph element property value that is null.\n\nlink:https://neo4j.com/docs/status-codes/current/errors/gql-errors/22G03/[22G03]: error: data exception - invalid value type\n|===\n\n====\n\n[NOTE]\n====\nSpecifying a property of an entity (node or relationship) by referring to the property of another entity within the same `MERGE` clause is not allowed.\n\nFor example, referring to `charlie.bornIn` in the property definition of `oliver.bornIn` is not allowed.\n\n.Query\n[source, cypher, role=test-fail]\n----\nMERGE (charlie:Person {name: 'Charlie Sheen', bornIn: 'New York'})-[:ACTED_IN]->(movie:Movie)<-[:DIRECTED]-(oliver:Person {name: 'Oliver Stone', bornIn: charlie.bornIn})\nRETURN movie\n----\n\n.GQLSTATUS error chain\n[role=\"queryresult\",stripes=\"all\", cols=\"1\", ]\n|===\n| link:https://neo4j.com/docs/status-codes/current/errors/gql-errors/42I58/[42I58]: error: syntax error or access rule violation - invalid entity reference. Entity, 'charlie', cannot be created and referenced in the same clause.\n\nlink:https://neo4j.com/docs/status-codes/current/errors/gql-errors/42001/[42001]: error: syntax error or access rule violation - invalid syntax\n|===\n\n====\n\n\n[[merge-merge-on-multiple-relationships]]"}, {"heading": "Merge on multiple relationships", "content": ".Query\n[source, cypher]\n----\nMATCH\n  (oliver:Person {name: 'Oliver Stone'}),\n  (reiner:Person {name: 'Rob Reiner'})\nMERGE (oliver)-[:DIRECTED]->(movie:Movie)<-[:DIRECTED]-(reiner)\nRETURN movie\n----\n\nIn the example graph, `Oliver Stone` and `Rob Reiner` have never worked together.\nWhen trying to `MERGE` a `Movie` node between them, Neo4j will not use any of the existing `Movie` nodes already connected to either person.\nInstead, a new `Movie` node is created.\n\n.Result\n[role=\"queryresult\",options=\"header\",cols=\"1*<m\"]\n|===\n| movie\n| (:Movie)\n|===\n\n\n[[merge-merge-on-an-undirected-relationship]]"}, {"heading": "Merge on an undirected relationship", "content": "`MERGE` can also be used without specifying the direction of a relationship.\nCypher will first try to match the relationship in both directions.\nIf the relationship does not exist in either direction, it will create one left to right.\n\n.Query\n[source, cypher]\n----\nMATCH\n  (charlie:Person {name: 'Charlie Sheen'}),\n  (oliver:Person {name: 'Oliver Stone'})\nMERGE (charlie)-[r:KNOWS]-(oliver)\nRETURN r\n----\n\nAs `Charlie Sheen` and `Oliver Stone` do not know each other in the example graph, this `MERGE` query will create a `KNOWS` relationship between them.\nThe direction of the created relationship is left to right.\n\n.Result\n[role=\"queryresult\",options=\"header\",cols=\"1*<m\"]\n|===\n| r\n| [:KNOWS]\n|===\n\n\n[[merge-merge-on-a-relationship-between-two-existing-nodes]]"}, {"heading": "Merge on a relationship between two existing nodes", "content": "`MERGE` can be used in conjunction with preceding `MATCH` and `MERGE` clauses to create a relationship between two bound nodes `m` and `n`, where `m` is returned by `MATCH` and `n` is created or matched by the earlier `MERGE`.\n\n.Query\n[source, cypher]\n----\nMATCH (person:Person)\nMERGE (location:Location {name: person.bornIn})\nMERGE (person)-[r:BORN_IN]->(location)\nRETURN person.name, person.bornIn, location\n----\n\nThis builds on the example from xref::clauses/merge.adoc#merge-merge-single-node-derived-from-an-existing-node-property[Merge single node derived from an existing node property].\nThe second `MERGE` creates a `BORN_IN` relationship between each person and a location corresponding to the value of the persons `bornIn` property.\n`Charlie Sheen`, `Rob Reiner`, and `Oliver Stone` all have a `BORN_IN` relationship to the _same_ `Location` node (`New York`).\n\n.Result\n[role=\"queryresult\",options=\"header\",cols=\"3*<m\"]\n|===\n| person.name | person.bornIn | location\n| \"Charlie Sheen\" | \"New York\" | (:Location {name:\"New York\"})\n| \"Martin Sheen\" | \"Ohio\" | (:Location {name:\"Ohio\"})\n| \"Michael Douglas\" | \"New Jersey\" | (:Location {name:\"New Jersey\"})\n| \"Oliver Stone\" | \"New York\" | (:Location {name:\"New York\"})\n| \"Rob Reiner\" | \"New York\" | (:Location {name:\"New York\"})\n| \"Keanu Reeves\" | \"Beirut\" | (:Location {name:\"Beirut\"})\n|===\n\n\n[[merge-merge-on-a-relationship-between-an-existing-node-and-a-merged-node-derived-from-a-node-property]]"}, {"heading": "Merge on a relationship between an existing node and a merged node derived from a node property", "content": "`MERGE` can be used to simultaneously create both a new node `n` and a relationship between a bound node `m` and `n`:\n\n.Query\n[source, cypher]\n----\nMATCH (person:Person)\nMERGE (person)-[r:HAS_CHAUFFEUR]->(chauffeur:Chauffeur {name: person.chauffeurName})\nRETURN person.name, person.chauffeurName, chauffeur\n----\n\nAs `MERGE` found no matches -- in the example graph, there are no nodes labeled with `Chauffeur` and no `HAS_CHAUFFEUR` relationships -- `MERGE` creates six nodes labeled with `Chauffeur`, each of which contains a `name` property whose value corresponds to each matched `Person` node's `chauffeurName` property value.\n`MERGE` also creates a `HAS_CHAUFFEUR` relationship between each `Person` node and the newly-created corresponding `Chauffeur` node.\nAs `'Charlie Sheen'` and `'Michael Douglas'` both have a chauffeur with the same name -- `'John Brown'` -- a new node is created in each case, resulting in _two_ `Chauffeur` nodes having a `name` of `'John Brown'`, correctly denoting the fact that even though the `name` property may be identical, these are two separate people.\nThis is in contrast to the example shown above in xref::clauses/merge.adoc#merge-merge-on-a-relationship-between-two-existing-nodes[Merge on a relationship between two existing nodes], where the first `MERGE` was used to bind the `Location` nodes and to prevent them from being recreated (and thus duplicated) on the second `MERGE`.\n\n.Result\n[role=\"queryresult\",options=\"header\",cols=\"3*<m\"]\n|===\n| person.name | person.chauffeurName | chauffeur\n| \"Charlie Sheen\" | \"John Brown\" | (:Person {name:\"John Brown\"})\n| \"Martin Sheen\" | \"Bob Brown\" | (:Person {name:\"Bob Brown\"})\n| \"Michael Douglas\" | \"John Brown\" | (:Person {name:\"John Brown\"})\n| \"Oliver Stone\" | \"Bill White\" | (:Person {name:\"Bill White\"})\n| \"Rob Reiner\" | \"Ted Green\" | (:Person {name:\"Ted Green\"})\n| \"Keanu Reeves\" | \"Eric Brown\" | (:Person {name:\"Eric Brown\"})\n|===\n\n\n[[query-merge-using-unique-constraints]]"}, {"heading": "Using node property uniqueness constraints with `MERGE`", "content": "Cypher prevents getting conflicting results from `MERGE` when using patterns that involve xref:schema/constraints/create-constraints.adoc#create-property-uniqueness-constraints[property uniqueness constraints].\nIn this case, there must be at most one node that matches that pattern.\n\nFor example, given two property node uniqueness constraints on `:Person(id)` and `:Person(ssn)`, a query such as `MERGE (n:Person {id: 12, ssn: 437})` will fail, if there are two different nodes (one with `id` 12 and one with `ssn` 437), or if there is only one node with only one of the properties.\nIn other words, there must be exactly one node that matches the pattern, or no matching nodes.\n\nNote that the following examples assume the existence of property uniqueness constraints that have been created using:\n\n[source, cypher]\n----\nCREATE CONSTRAINT FOR (n:Person) REQUIRE n.name IS UNIQUE;\nCREATE CONSTRAINT FOR (n:Person) REQUIRE n.role IS UNIQUE;\n----\n\n\n[[merge-merge-using-unique-constraints-creates-a-new-node-if-no-node-is-found]]"}], "source_file": "modules\\ROOT\\pages\\clauses\\merge.adoc", "authority_level": 1}
{"name": "OPTIONAL MATCH", "description": "The `OPTIONAL MATCH` clause is used to search for the pattern described in it, while using nulls for missing parts of the pattern.", "syntax_examples": ["CREATE\n  (charlie:Person {name: 'Charlie Sheen'}),\n  (martin:Person {name: 'Martin Sheen'}),\n  (michael:Person {name: 'Michael Douglas'}),\n  (oliver:Person {name: 'Oliver Stone'}),\n  (rob:Person {name: 'Rob Reiner'}),\n  (wallStreet:Movie {title: 'Wall Street'}),\n  (charlie)-[:ACTED_IN]->(wallStreet),\n  (martin)-[:ACTED_IN]->(wallStreet),\n  (michael)-[:ACTED_IN]->(wallStreet),\n  (oliver)-[:DIRECTED]->(wallStreet),\n  (thePresident:Movie {title: 'The American President'}),\n  (martin)-[:ACTED_IN]->(thePresident),\n  (michael)-[:ACTED_IN]->(thePresident),\n  (rob)-[:DIRECTED]->(thePresident),\n  (martin)-[:FATHER_OF]->(charlie)", "MATCH (a:Person {name: 'Martin Sheen'})\nMATCH (a)-[r:DIRECTED]->()\nRETURN a.name, r", "MATCH (p:Person {name: 'Martin Sheen'})\nOPTIONAL MATCH (p)-[r:DIRECTED]->()\nRETURN p.name, r", "MATCH (a:Movie {title: 'Wall Street'})\nOPTIONAL MATCH (a)-->(x)\nRETURN x", "MATCH (a:Person {name: 'Charlie Sheen'})\nOPTIONAL MATCH (a)-->(x)\nRETURN x", "MATCH (a:Movie {title: 'Wall Street'})\nOPTIONAL MATCH (a)-->(x)\nRETURN x, x.name", "MATCH (a:Person {name: 'Martin Sheen'})\nOPTIONAL MATCH (a)-->(x)\nRETURN x, x.name", "MATCH (a:Movie {title: 'Wall Street'})\nOPTIONAL MATCH (a)-[r:ACTED_IN]->()\nRETURN a.title, r", "MATCH (a:Movie {title: 'Wall Street'})\nOPTIONAL MATCH (x)-[r:ACTED_IN]->(a)\nRETURN a.title, x.name, type(r)"], "sections": [{"heading": "Introduction", "content": "`OPTIONAL MATCH` matches patterns against a graph database, just as `MATCH` does.\nThe difference is that if no matches are found, `OPTIONAL MATCH` will use a `null` for missing parts of the pattern.\n`OPTIONAL MATCH` could therefore be considered the Cypher equivalent of the outer join in SQL.\n\nWhen using `OPTIONAL MATCH`, either the whole pattern is matched, or nothing is matched.\nThe `WHERE` clause is part of the pattern description, and its predicates will be considered while looking for matches, not after.\nThis matters especially in the case of multiple (`OPTIONAL`) `MATCH` clauses, where it is crucial to put `WHERE` together with the `MATCH` it belongs to."}, {"heading": "Example graph", "content": "The following graph is used for the examples below:\n\nimage::graph-optional-match-clause.svg[Example graph connecting Person and Movie nodes,width=600,role=popup]\n\nTo recreate the graph, run the following query in an empty Neo4j database:\n\n[source, cypher, role=test-setup]\n----\nCREATE\n  (charlie:Person {name: 'Charlie Sheen'}),\n  (martin:Person {name: 'Martin Sheen'}),\n  (michael:Person {name: 'Michael Douglas'}),\n  (oliver:Person {name: 'Oliver Stone'}),\n  (rob:Person {name: 'Rob Reiner'}),\n  (wallStreet:Movie {title: 'Wall Street'}),\n  (charlie)-[:ACTED_IN]->(wallStreet),\n  (martin)-[:ACTED_IN]->(wallStreet),\n  (michael)-[:ACTED_IN]->(wallStreet),\n  (oliver)-[:DIRECTED]->(wallStreet),\n  (thePresident:Movie {title: 'The American President'}),\n  (martin)-[:ACTED_IN]->(thePresident),\n  (michael)-[:ACTED_IN]->(thePresident),\n  (rob)-[:DIRECTED]->(thePresident),\n  (martin)-[:FATHER_OF]->(charlie)\n----"}, {"heading": "OPTIONAL MATCH in more detail", "content": "Like SQL, Cypher queries are constructed using various clauses which are chained together to feed intermediate results between each other.\nFor example, the matching variables from one `MATCH` clause will provide the context in which the next clause exists.\nHowever, there are two important differences between Neo4j and SQL which helps to explain `OPTIONAL MATCH` further.\n\n. While it is both possible and advised to enforce partial schemas using indexes and constraints, Neo4j offers a greater degree of schema flexibility than a relational database.\nNodes and relationships in a Neo4j database do not have to have a specific property set to them because other nodes or relationships in the same graph have that property (unless there is a xref:schema/constraints/create-constraints.adoc#create-property-existence-constraints[property existence constraint] created on the specific property).\n\n. Queries in Cypher are run as pipelines.\nIf a clause returns no results, it will effectively end the query as subsequent clauses will have no data to execute upon.\n\nFor example, the following query returns no results:\n\n[source, cypher]\n----\nMATCH (a:Person {name: 'Martin Sheen'})\nMATCH (a)-[r:DIRECTED]->()\nRETURN a.name, r\n----\n\n\n[source, result]\n----\n(no changes, no records)\n----\n\nThis is because the second `MATCH` clause returns no data (there are no `DIRECTED` relationships connected to `Martin Sheen` in the graph) to pass on to the `RETURN` clause.\n\nHowever, replacing the second `MATCH` clause with `OPTIONAL MATCH` does return results.\nThis is because, unlike `MATCH`, `OPTIONAL MATCH` enables the value `null` to be passed between clauses.\n\n// tag::clauses_optional_match[]\n[source, cypher]\n----\nMATCH (p:Person {name: 'Martin Sheen'})\nOPTIONAL MATCH (p)-[r:DIRECTED]->()\nRETURN p.name, r\n----\n// end::clauses_optional_match[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| p.name | r\n\n| \"Martin Sheen\"\n| <null>\n2+d|Rows: 1\n|===\n\n`OPTIONAL MATCH` can therefore be used to check graphs for missing as well as existing values, and to pass on rows without any data to subsequent clauses in a query.\n\n[[optional-relationships]]"}, {"heading": "Optional relationships", "content": "If the existence of a relationship is optional, use the `OPTIONAL MATCH` clause.\nIf the relationship exists, it is returned.\nIf it does not, `null` is returned in its place.\n\n[source, cypher]\n----\nMATCH (a:Movie {title: 'Wall Street'})\nOPTIONAL MATCH (a)-->(x)\nRETURN x\n----\n\nReturns `null`, since the `Movie` node `Wall Street` has no outgoing relationships.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| x\n| <null>\n1+d|Rows: 1\n|===\n\nOn the other hand, the following query does not return `null` since the `Person` node `Charlie Sheen` has one outgoing relationship.\n\n[source, cypher]\n----\nMATCH (a:Person {name: 'Charlie Sheen'})\nOPTIONAL MATCH (a)-->(x)\nRETURN x\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| x\n| {\"title\":\"Wall Street\"}\n1+d|Rows: 2\n|===\n\n\n[[properties-on-optional-elements]]"}, {"heading": "Properties on optional elements", "content": "If the existence of a property is optional, use the `OPTIONAL MATCH` clause.\n`null` will be returned if the specified property does not exist.\n\n[source, cypher]\n----\nMATCH (a:Movie {title: 'Wall Street'})\nOPTIONAL MATCH (a)-->(x)\nRETURN x, x.name\n----\n\nReturns the element `x` (`null` in this query), and `null` for its `name` property, because the `Movie` node `Wall Street` has no outgoing relationships.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| x | x.name\n| <null> | <null>\n2+d|Rows: 1\n|===\n\nThe following query only returns `null` for the nodes which lack a `name` property.\n\n\n[source, cypher]\n----\nMATCH (a:Person {name: 'Martin Sheen'})\nOPTIONAL MATCH (a)-->(x)\nRETURN x, x.name\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| x | x.name\n| {\"title\":\"Wall Street\"} | <null>\n| {\"name\":\"Charlie Sheen\"} | \"Charlie Sheen\"\n| {\"title\":\"The American President\"} | <null>\n2+d|Rows: 3\n|===\n\n\n[[optional-typed-named-relationship]]"}, {"heading": "Optional typed and named relationship", "content": "It is also possible to look for specific relationship types when using `OPTIONAL MATCH`:\n\n[source, cypher]\n----\nMATCH (a:Movie {title: 'Wall Street'})\nOPTIONAL MATCH (a)-[r:ACTED_IN]->()\nRETURN a.title, r\n----\n\nThis returns the title of the `Movie` node `Wall Street`, and since this node has no outgoing `ACTED_IN` relationships, `null` is returned for the relationship denoted by the variable `r`.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| a.title | r\n| \"Wall Street\" | <null>\n2+d|Rows: 1\n|===\n\nHowever, the following query does not return `null` since it is looking for incoming relationships of the type `ACTED_IN` to the `Movie` node `Wall Street`.\n\n[source, cypher]\n----\nMATCH (a:Movie {title: 'Wall Street'})\nOPTIONAL MATCH (x)-[r:ACTED_IN]->(a)\nRETURN a.title, x.name, type(r)\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"3*<m\"]\n|===\n| a.title | x.name | type(r)\n| \"Wall Street\" | \"Michael Douglas\" | \"ACTED_IN\"\n| \"Wall Street\" | \"Martin Sheen\" | \"ACTED_IN\"\n| \"Wall Street\" | \"Charlie Sheen\" | \"ACTED_IN\"\n\n3+d|Rows: 3\n|==="}], "source_file": "modules\\ROOT\\pages\\clauses\\optional-match.adoc", "authority_level": 1}
{"name": "ORDER BY", "description": "Information about Cypher's `ORDER BY` subclause.", "syntax_examples": ["CREATE (o1:Order {id: 'ORD-001', orderDate: datetime('2024-05-01T10:00:00'), total: 550, status: 'shipped'}),\n       (o2:Order {id: 'ORD-002', orderDate: datetime('2024-05-02T14:30:00'), total: 1000, status: 'pending'}),\n       (o3:Order {id: 'ORD-003', orderDate: datetime('2024-05-03T09:15:00'), total: 550, status: 'pending'}),\n       (o4:Order {id: 'ORD-004', orderDate: datetime('2024-05-04T12:45:00'), total: 200}),\n       (o5:Order {id: 'ORD-005', orderDate: datetime('2024-05-05T15:00:00'), total: 800, status: 'shipped'}),\n\n       (i1:Item {name: 'Phone', price: 500}),\n       (i2:Item {name: 'Laptop', price: 1000}),\n       (i3:Item {name: 'Headphones', price: 250}),\n       (i4:Item {name: 'Charger', price: 50}),\n       (i5:Item {name: 'Keyboard', price: 200}),\n\n       (o1)-[:CONTAINS]->(i1),\n       (o1)-[:CONTAINS]->(i4),\n       (o2)-[:CONTAINS]->(i2),\n       (o3)-[:CONTAINS]->(i1),\n       (o3)-[:CONTAINS]->(i4),\n       (o4)-[:CONTAINS]->(i5),\n       (o5)-[:CONTAINS]->(i1),\n       (o5)-[:CONTAINS]->(i3),\n       (o5)-[:CONTAINS]->(i4)", "MATCH (o:Order)\nRETURN o.id AS order,\n       o.total AS total\n  ORDER BY total", "MATCH (o:Order)\nRETURN o.id AS order,\n       o.total AS total,\n       o.orderDate AS orderDate\n  ORDER BY total,\n           orderDate", "MATCH (o:Order)\nRETURN o.id AS order,\n       elementId(o) AS elementId\n  ORDER BY elementId", "MATCH (o:Order)\nRETURN o.id AS order,\n       o.total * 0.9 AS discountedTotal\n  ORDER BY discountedTotal", "MATCH (o:Order)\nRETURN o.id AS order,\n      COUNT { (o)-[:CONTAINS]->(:Item) } AS itemCount\n  ORDER BY itemCount", "MATCH (o:Order)\nRETURN o.id AS order\n  ORDER BY COUNT { (o)-[:CONTAINS]->(:Item) }", "MATCH (o:Order)\nRETURN o.id AS order,\n       o.total AS total\n  ORDER BY total ASC", "MATCH (o:Order)\nRETURN o.id AS order,\n       o.total AS total\n  ORDER BY total DESC", "MATCH (o:Order)\nRETURN o.id AS order,\n       o.total AS total,\n       o.orderDate AS orderDate\n  ORDER BY total DESC,\n           orderDate ASC"], "sections": [{"heading": "Example graph", "content": "A graph with the following schema is used for the examples below:\n\nimage::order-by-graph.svg[Graph showing orders and the items they contain, width=400, role=popup]\n\nTo recreate it, run the following query against an empty Neo4j database:\n\n[source, cypher, role=test-setup]\n----\nCREATE (o1:Order {id: 'ORD-001', orderDate: datetime('2024-05-01T10:00:00'), total: 550, status: 'shipped'}),\n       (o2:Order {id: 'ORD-002', orderDate: datetime('2024-05-02T14:30:00'), total: 1000, status: 'pending'}),\n       (o3:Order {id: 'ORD-003', orderDate: datetime('2024-05-03T09:15:00'), total: 550, status: 'pending'}),\n       (o4:Order {id: 'ORD-004', orderDate: datetime('2024-05-04T12:45:00'), total: 200}),\n       (o5:Order {id: 'ORD-005', orderDate: datetime('2024-05-05T15:00:00'), total: 800, status: 'shipped'}),\n\n       (i1:Item {name: 'Phone', price: 500}),\n       (i2:Item {name: 'Laptop', price: 1000}),\n       (i3:Item {name: 'Headphones', price: 250}),\n       (i4:Item {name: 'Charger', price: 50}),\n       (i5:Item {name: 'Keyboard', price: 200}),\n\n       (o1)-[:CONTAINS]->(i1),\n       (o1)-[:CONTAINS]->(i4),\n       (o2)-[:CONTAINS]->(i2),\n       (o3)-[:CONTAINS]->(i1),\n       (o3)-[:CONTAINS]->(i4),\n       (o4)-[:CONTAINS]->(i5),\n       (o5)-[:CONTAINS]->(i1),\n       (o5)-[:CONTAINS]->(i3),\n       (o5)-[:CONTAINS]->(i4)\n----\n\n\n[[basic-examples]]"}, {"heading": "Basic examples", "content": ".Order by property values\n=====\n\n`ORDER BY` can be used to sort the result by property values.\n\n.Order by node property\n// tag::clauses_order_by[]\n[source, cypher]\n----\nMATCH (o:Order)\nRETURN o.id AS order,\n       o.total AS total\n  ORDER BY total\n----\n// end::clauses_order_by[]\n\nThe nodes are returned, sorted by the value of the `total` properties in an ascending order.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| order | total\n\n| \"ORD-004\" | 200\n| \"ORD-001\" | 550\n| \"ORD-003\" | 550\n| \"ORD-005\" | 800\n| \"ORD-002\" | 1000 \n\n2+d|Rows: 5\n|===\n\n=====\n\n.Order by multiple property values\n=====\n\nOrder by multiple property values by listing two or more properties in the `ORDER BY` subclause.\nCypher sorts by the first property, and if values are equal, it moves to the next property, and so on.\n\n.Order by multiple properties\n// tag::clauses_order_by_multiple[]\n[source, cypher]\n----\nMATCH (o:Order)\nRETURN o.id AS order,\n       o.total AS total,\n       o.orderDate AS orderDate\n  ORDER BY total,\n           orderDate\n----\n// end::clauses_order_by_multiple[]\n\nThis returns the nodes, sorted first by their `total` property, and then, for equal values, by their `orderDate` property.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"3*<m\"]\n|===\n| order | total | orderDate\n\n| \"ORD-004\" | 200   | 2024-05-04T12:45Z\n| \"ORD-001\" | 550   | 2024-05-01T10:00Z\n| \"ORD-003\" | 550   | 2024-05-03T09:15Z\n| \"ORD-005\" | 800   | 2024-05-05T15:00Z\n| \"ORD-002\" | 1000  | 2024-05-02T14:30Z\n\n3+d|Rows: 5\n|===\n\n=====\n\n.Order by ID\n=====\n\n`ORDER BY` can be used to sort nodes or relationships by their ID (retrieved by either the xref:functions/scalar.adoc#functions-elementid[`elementId()`] or xref:functions/scalar.adoc#functions-id[`id()`] functions).\n\n.Order by element ID\n[source, cypher, role=test-result-skip]\n----\nMATCH (o:Order)\nRETURN o.id AS order,\n       elementId(o) AS elementId\n  ORDER BY elementId\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| order | elementId\n\n| \"ORD-001\" | \"4:9350eddd-5a35-413d-8684-708b1da35d23:0\"\n| \"ORD-002\" | \"4:9350eddd-5a35-413d-8684-708b1da35d23:1\"\n| \"ORD-003\" | \"4:9350eddd-5a35-413d-8684-708b1da35d23:2\"\n| \"ORD-004\" | \"4:9350eddd-5a35-413d-8684-708b1da35d23:3\"\n| \"ORD-005\" | \"4:9350eddd-5a35-413d-8684-708b1da35d23:4\"\n\n2+d|Rows: 5\n|===\n\n[NOTE]\nNeo4j reuses its internal IDs when nodes and relationships are deleted.\nApplications relying on internal Neo4j IDs are, as a result, brittle and can be inaccurate.\nIt is recommended to use application-generated IDs instead.\n\n=====\n\n.Order by expressions\n=====\n\n`ORDER BY` can be used to sort according to the results of an xref:expressions/index.adoc[expression].\nThe below query calculates a 10% discount on each order's `total` property value, and then orders the results by the discounted total.\n\n.Order by an expression result\n[source, cypher]\n----\nMATCH (o:Order)\nRETURN o.id AS order,\n       o.total * 0.9 AS discountedTotal\n  ORDER BY discountedTotal\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| order | discountedTotal\n\n| \"ORD-004\" | 180.0\n| \"ORD-001\" | 495.0\n| \"ORD-003\" | 495.0\n| \"ORD-005\" | 720.0\n| \"ORD-002\" | 900.0\n\n2+d|Rows: 5\n|===\n\nThis next query xref:subqueries/count.adoc[counts] the number of items contained in each order and then orders the results by the item count.\n\n.Order by an expression result\n[source, cypher]\n----\nMATCH (o:Order)\nRETURN o.id AS order,\n      COUNT { (o)-[:CONTAINS]->(:Item) } AS itemCount\n  ORDER BY itemCount\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| order | itemCount\n\n| \"ORD-002\" | 1\n| \"ORD-004\" | 1\n| \"ORD-001\" | 2\n| \"ORD-003\" | 2\n| \"ORD-005\" | 3 \n\n2+d|Rows: 5\n|===\n\n=====\n\n[[order-by-values-not-in-result]]"}, {"heading": "Order by values not in the result", "content": "`ORDER BY` can sort by values that are not included in the result set.\nThat is, the sort key does not need to be part of the preceding `RETURN` or `WITH` clause.\nFor example, the query below sorts orders based on how many items they contain, even though that count is not returned.\n\n.Order by values not in the returned results\n[source, cypher]\n----\nMATCH (o:Order)\nRETURN o.id AS order\n  ORDER BY COUNT { (o)-[:CONTAINS]->(:Item) }\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| order\n\n| \"ORD-002\"\n| \"ORD-004\"\n| \"ORD-001\"\n| \"ORD-003\"\n| \"ORD-005\"\n\n1+d|Rows: 5\n|===\n\n[[ascending-descending-order]]"}, {"heading": "Ascending and descending order", "content": "`ORDER BY` sorts results in an ascending order by default.\nTo explicitly sort results in an ascending order, append `ASC[ENDING]`.\n\n.Explicitly sort results in an ascending order\n[source, cypher]\n----\nMATCH (o:Order)\nRETURN o.id AS order,\n       o.total AS total\n  ORDER BY total ASC\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| order | total\n\n| \"ORD-004\" | 200\n| \"ORD-001\" | 550\n| \"ORD-003\" | 550\n| \"ORD-005\" | 800\n| \"ORD-002\" | 1000\n\n2+d|Rows: 5\n|===\n\nTo sort results in a descending order, append `DESC[ENDING]`.\n\n.Sort results in a descending order\n[source, cypher]\n----\nMATCH (o:Order)\nRETURN o.id AS order,\n       o.total AS total\n  ORDER BY total DESC\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| order | total\n\n| \"ORD-002\" | 1000\n| \"ORD-005\" | 800\n| \"ORD-001\" | 550\n| \"ORD-003\" | 550\n| \"ORD-004\" | 200\n\n2+d|Rows: 5\n|===\n\n`ORDER BY` can combine ascending and descending ordering.\nIn the example below, results are sorted first by `total` values in descending order and then by `orderDate` values in ascending order.\n\n.Combine ascending and descending result ordering\n[source, cypher]\n----\nMATCH (o:Order)\nRETURN o.id AS order,\n       o.total AS total,\n       o.orderDate AS orderDate\n  ORDER BY total DESC,\n           orderDate ASC\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"3*<m\"]\n|===\n| order | total | orderDate\n\n| \"ORD-002\" | 1000  | 2024-05-02T14:30Z\n| \"ORD-005\" | 800   | 2024-05-05T15:00Z\n| \"ORD-001\" | 550   | 2024-05-01T10:00Z\n| \"ORD-003\" | 550   | 2024-05-03T09:15Z\n| \"ORD-004\" | 200   | 2024-05-04T12:45Z\n\n3+d|Rows: 5\n|===\n\n\n[[limit-pattern-matching]]"}, {"heading": "ORDER BY and pattern matching", "content": "`ORDER BY` can be used to sort results before continuing with additional pattern matching.\nIn the example below, it is combined with the xref:clauses/limit.adoc[`LIMIT`] to first sort `Order` nodes by their `orderDate` property values, limit the result to the most recent `Order`, and then match any connected `Item` nodes.\nAlso note that `ORDER BY` and `LIMIT` are used as xref:clauses/order-by.adoc#order-standalone-clause[standalone clauses] and not as subclauses in this example.\n\n.Find the items contained in the most recently placed order\n[source, cypher]\n----\nMATCH (o:Order)\nORDER BY o.orderDate DESC\nLIMIT 1\nMATCH (o)-[:CONTAINS]->(i:Item)\nRETURN o.id AS order,\n       o.total,\n       collect(i.name) AS items\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"3*<m\"]\n|===\n| order | total | items\n\n| \"ORD-005\" | 800 | [\"Phone\", \"Headphones\", \"Charger\"]\n\n3+d|Rows: 1\n|===\n\n[[null]]"}, {"heading": "Null values", "content": "When sorting, `null` values appear last in ascending order and first in descending order.\n\n.Sort on null property\n[source, cypher]\n----\nMATCH (o:Order)\nRETURN o.id AS order,\n       o.status AS status\n  ORDER BY status DESC\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| order | status\n\n| \"ORD-004\" | null\n| \"ORD-001\" | \"shipped\"\n| \"ORD-005\" | \"shipped\"\n| \"ORD-002\" | \"pending\"\n| \"ORD-003\" | \"pending\"\n\n2+d|Rows: 5\n|===\n\n\n[[order-with]]"}, {"heading": "ORDER BY and the WITH clause", "content": "When `ORDER BY` is present on a `WITH` clause, the immediately following clause will receive records in the specified order.\nThis guaranteed order is useful for operations that rely on the sequence in which values are processed.\nFor example, appending `ORDER BY` to a `WITH` clause can be used to control the order of items in the list produced by the xref:functions/aggregating.adoc#functions-collect[`collect()`] aggregating function.\nThe xref:clauses/merge.adoc[`MERGE`] and xref:clauses/set.adoc[`SET`] clauses also have ordering dependencies which can be controlled this way.\n\nThe below example uses `WITH` and `ORDER BY` to sort `Item` nodes by their `price` property, then the `collect()` in the subsequent `RETURN` clause builds an ordered list per order based on that sort.\n\n.`WITH`, `ORDER BY`, and `collect()`\n[source, cypher]\n----\nMATCH (o:Order)-[:CONTAINS]->(i:Item)\nWITH o, i\n  ORDER BY i.price DESC\nRETURN o.id AS order,\n       collect(i.name || \" ($\" || toString(i.price) || \")\") AS orderedListOfItems\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| order | orderedListOfItems\n\n| \"ORD-002\" | [\"Laptop ($1000)\"]\n| \"ORD-001\" | [\"Phone ($500)\", \"Charger ($50)\"]\n| \"ORD-003\" | [\"Phone ($500)\", \"Charger ($50)\"]\n| \"ORD-005\" | [\"Phone ($500)\", \"Headphones ($250)\", \"Charger ($50)\"]\n| \"ORD-004\" | [\"Keyboard ($200)\"]\n\n2+d|Rows: 5\n|===\n\n[[aggregation-distinct]]"}, {"heading": "Ordering aggregated or DISTINCT results", "content": "The variables available to `ORDER BY` depend on whether or not the preceding `RETURN` or `WITH` clause performs an aggregation to combine results or uses `DISTINCT` to remove duplicates.\n\n* If the `RETURN` or `WITH` is not aggregating values or using `DISTINCT`, then `ORDER BY` can reference any variables referenced in the preceding `RETURN` or `WITH` clause.\n\n.`ORDER BY` following a `WITH` clause excluding aggregation or `DISTINCT`\n[source, cypher]\n----\nMATCH (o:Order)-[:CONTAINS]->(i:Item)\nWITH o.id AS order,\n     i.name AS item\n  ORDER BY o.orderDate\nRETURN order, item\n----\n\n* If the `RETURN` or `WITH` performs an aggregation or uses `DISTINCT` only the projected variables from either operation are available to `ORDER BY`.\nThis is because these operations alter the number of rows produced by the clause and any variables not explicitly projected are discarded.\n\n.`ORDER BY` following a `WITH` clause projecting an aggregated value\n[source, cypher, role=test-fail]\n----\nMATCH (o:Order)-[:CONTAINS]->(i:Item)\nWITH collect(o.id) AS orders,\n     i.name AS items\n  ORDER BY o.orderDate\nRETURN orders, items\n----\n\n.GQLSTATUS error chain\n[role=\"queryresult\",stripes=\"all\",cols=\"1\"]\n|===\n| link:https://neo4j.com/docs/status-codes/current/errors/gql-errors/42N44/[42N44]: error: syntax error or access rule violation - inaccessible variable. It is not possible to access the variable `o` declared before the WITH clause when using `DISTINCT` or an aggregation.\n\nlink:https://neo4j.com/docs/status-codes/current/errors/gql-errors/42001/[42001]: error: syntax error or access rule violation - invalid syntax\n|===\n\n[[indexes]]"}, {"heading": "ORDER BY and indexes", "content": "The performance of Cypher queries using `ORDER BY` on node properties can be influenced by the existence and use of an index for finding the nodes.\nIf the index can provide the nodes in the order requested in the query, Cypher can avoid the use of an expensive `Sort` operation.\nRead more about this capability in xref::indexes/search-performance-indexes/using-indexes.adoc#range-index-backed-order-by[Range index-backed ORDER BY].\n\n\n[[order-standalone-clause]]"}, {"heading": "Using `ORDER BY` as a standalone clause", "content": "`ORDER BY` can be used as a standalone clause, or in conjunction with `SKIP`/`OFFSET` or `LIMIT`.\n\n.Standalone use of `ORDER BY`\n// tag::clauses_order_by_standalone[]\n[source, cypher]\n----\nMATCH (i:Item)\nORDER BY i.price\nRETURN collect(i.name || \" ($\" || toString(i.price) || \")\") AS orderedPriceList\n----\n// end::clauses_order_by_standalone[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| orderedPriceList\n\n| [\"Charger ($50)\", \"Keyboard ($200)\", \"Headphones ($250)\", \"Phone ($500)\", \"Laptop ($1000)\"]\n\n1+d|Rows: 1\n|===\n\n.`ORDER BY` used in conjunction with `SKIP` and `LIMIT`\n// tag::clauses_order_by_descending[]\n[source, cypher]\n----\nMATCH (i:Item)\nORDER BY i.price DESC\nSKIP 1\nLIMIT 1\nRETURN i.name AS secondMostExpensiveItem,\n       i.price AS price\n----\n// end::clauses_order_by_descending[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| secondMostExpensiveItem | price\n\n| \"Phone\" | 500\n\n2+d|Rows: 1\n|==="}], "source_file": "modules\\ROOT\\pages\\clauses\\order-by.adoc", "authority_level": 1}
{"name": "REMOVE", "description": "The `REMOVE` clause is used to remove properties from nodes and relationships, and to remove labels from nodes.", "syntax_examples": ["CREATE\n  (a:Swedish {name: 'Andy', age: 36, propTestValue1: 42}),\n  (t:Swedish {name: 'Timothy', age: 25, propTestValue2: 42}),\n  (p:German:Swedish {name: 'Peter', age: 34}),\n  (a)-[:KNOWS]->(t),\n  (a)-[:KNOWS]->(p)", "MATCH (a {name: 'Andy'})\nREMOVE a.age\nRETURN a.name, a.age", "MATCH (n) \nWITH n, [k IN keys(n) WHERE k CONTAINS \"Test\" | k] as propertyKeys // <1>\nFOREACH (i IN propertyKeys | REMOVE n[i]) // <2>\nRETURN n.name, keys(n);", "MATCH (n {name: 'Peter'})\nREMOVE n:German\nRETURN n.name, labels(n)", "MATCH (n {name: 'Peter'})\nUNWIND labels(n) AS label // <1>\nREMOVE n:$(label)\nRETURN n.name, labels(n)", "MATCH (n {name: 'Peter'})\nREMOVE n:German:Swedish\nRETURN n.name, labels(n)", "MATCH (n {name: 'Peter'})\nREMOVE n:$(labels(n))\nRETURN n.name, labels(n)"], "sections": [{"heading": "Example graph", "content": "The following graph is used for the examples below:\n\nimage::graph-remove-clause.svg[Example graph connecting people after their nationality as nodes,width=600,role=popup]\n\nTo recreate it, run the following query against an empty Neo4j database:\n\n[source, cypher, role=test-setup]\n----\nCREATE\n  (a:Swedish {name: 'Andy', age: 36, propTestValue1: 42}),\n  (t:Swedish {name: 'Timothy', age: 25, propTestValue2: 42}),\n  (p:German:Swedish {name: 'Peter', age: 34}),\n  (a)-[:KNOWS]->(t),\n  (a)-[:KNOWS]->(p)\n----\n\n\n[[remove-remove-a-property]]"}, {"heading": "Remove a property", "content": "Neo4j doesn't allow storing `null` in properties.\nInstead, if no value exists, the property is just not there.\nSo, `REMOVE` is used to remove a property value from a node or a relationship.\n\n.Query\n[source, cypher, indent=0]\n----\nMATCH (a {name: 'Andy'})\nREMOVE a.age\nRETURN a.name, a.age\n----\n\nThe node is returned, and no property `age` exists on it.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| a.name | a.age\n| \"Andy\" | <null>\n2+d|Rows: 1 +\nProperties set: 1\n|===\n\n\n[[remove-remove-all-properties]]"}, {"heading": "Remove all properties", "content": "`REMOVE` cannot be used to remove all existing properties from a node or relationship.\nInstead, using xref::clauses/set.adoc#set-remove-properties-using-empty-map[`SET`] with `=` and an empty map as the right operand will clear all properties from the node or relationship.\n\n[[dynamic-remove-property]]"}, {"heading": "Dynamically remove a property", "content": "`REMOVE` can be used to remove a property on a node or relationship even when the property key name is not statically known.\nThis allows for more flexible queries and mitigates the risk of Cypher injection.\n(For more information about Cypher injection, see link:https://neo4j.com/developer/kb/protecting-against-cypher-injection/[Neo4j Knowledge Base -> Protecting against Cypher injection]).\n\n[source, syntax]\n----\nREMOVE n[key]\n----\n\nThe dynamically calculated key must evaluate to a `STRING` value.\nThis query creates a copy of every property on the nodes:\n\n.Query\n[source, cypher, indent=0]\n----\nMATCH (n) \nWITH n, [k IN keys(n) WHERE k CONTAINS \"Test\" | k] as propertyKeys // <1>\nFOREACH (i IN propertyKeys | REMOVE n[i]) // <2>\nRETURN n.name, keys(n);\n----\n\n<1> The xref:functions/list.adoc#functions-keys[keys()] function retrieves all property keys of the matched nodes, and a xref:expressions/list-expressions.adoc#list-comprehension[list comprehension] filters these keys to include only those that contain the substring \"Test\", assigning the resulting list to the variable `propertyKeys`.\n<2> The xref:clauses/foreach.adoc[`FOREACH`] clause iterates over each key in the `propertyKeys` list and removes the corresponding property using the `REMOVE` clause.\n\nAll properties with the word \"Test\" in them are removed:\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| n.name    | keys(n)\n| \"Andy\"    | [\"name\", \"age\"]\n| \"Timothy\" | [\"name\", \"age\"]\n| \"Peter\"   | [\"name\", \"age\"]\n2+d|Rows: 3 +\nProperties set: 2\n|===\n\n[[remove-remove-a-label-from-a-node]]"}, {"heading": "Remove a label from a node", "content": "To remove labels, you use `REMOVE`.\n\n.Query\n[source, cypher, indent=0]\n----\nMATCH (n {name: 'Peter'})\nREMOVE n:German\nRETURN n.name, labels(n)\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| n.name | labels(n)\n| \"Peter\" | [\"Swedish\"]\n2+d|Rows: 1 +\nLabels removed: 1\n|===\n\n[[dynamic-remove-node-label]]"}, {"heading": "Dynamically remove a node label", "content": "`REMOVE` can be used to remove a label on a node even when the label is not statically known.\n\n[source, syntax]\n----\nMATCH (n)\nREMOVE n:$(expr)\n----\n\nThe expression must evaluate to a `STRING NOT NULL | LIST<STRING NOT NULL> NOT NULL` value.\n\n.Query\n[source, cypher, indent=0]\n----\nMATCH (n {name: 'Peter'})\nUNWIND labels(n) AS label // <1>\nREMOVE n:$(label)\nRETURN n.name, labels(n)\n----\n\n<1> xref:clauses/unwind.adoc[`UNWIND`] is used here to transform the list of labels from the xref:functions/list.adoc#functions-labels[`labels()`] function into separate rows, allowing subsequent operations to be performed on each label individually.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| n.name | labels(n)\n| \"Peter\" | []\n2+d|Rows: 1 +\nLabels removed: 2\n|===\n\n\n[[remove-remove-multiple-labels]]"}, {"heading": "Remove multiple labels from a node", "content": "To remove multiple labels, you use `REMOVE`.\n\n.Query\n[source, cypher, indent=0]\n----\nMATCH (n {name: 'Peter'})\nREMOVE n:German:Swedish\nRETURN n.name, labels(n)\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| n.name | labels(n)\n| \"Peter\" | []\n2+d|Rows: 1 +\nLabels removed: 2\n|===\n\n\n[[remove-remove-multiple-labels-dynamically]]"}, {"heading": "Remove multiple labels dynamically from a node", "content": "It is possible to remove multiple labels dynamically using a `LIST<STRING>` and/or by chaining them separately with a `:`:\n\n.Query\n[source, cypher, indent=0]\n----\nMATCH (n {name: 'Peter'})\nREMOVE n:$(labels(n))\nRETURN n.name, labels(n)\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| n.name | labels(n)\n| \"Peter\" | []\n2+d|Rows: 1 +\nLabels removed: 2\n|==="}], "source_file": "modules\\ROOT\\pages\\clauses\\remove.adoc", "authority_level": 1}
{"name": "RETURN", "description": "The `RETURN` clause defines what to include in the query result set.", "syntax_examples": ["CREATE\n  (keanu:Person {name: 'Keanu Reeves', bornIn: 'Beirut', nationality: 'Canadian'}),\n  (taiChi:Movie {title: 'Man of Tai Chi', released: 2013}),\n  (keanu)-[:ACTED_IN]->(taiChi),\n  (keanu)-[:DIRECTED]->(taiChi)", "MATCH (p:Person {name: 'Keanu Reeves'})\nRETURN p", "MATCH (p:Person {name: 'Keanu Reeves'})-[r:ACTED_IN]->(m)\nRETURN type(r)", "MATCH (p:Person {name: 'Keanu Reeves'})\nRETURN p.bornIn", "MATCH p = (keanu:Person {name: 'Keanu Reeves'})-[r]->(m)\nRETURN *", "MATCH (`/uncommon variable\\`)\nWHERE `/uncommon variable\\`.name = 'Keanu Reeves'\nRETURN `/uncommon variable\\`.bornIn", "MATCH (p:Person {name: 'Keanu Reeves'})\nRETURN p.nationality AS citizenship", "MATCH (n)\nRETURN n.bornIn", "MATCH (m:Movie {title: 'Man of Tai Chi'})\nRETURN m.released < 2012, \"I'm a literal\",[p=(m)--() | p] AS `(m)--()`", "MATCH (p:Person {name: 'Keanu Reeves'})-->(m)\nRETURN DISTINCT m"], "sections": [{"heading": "Introduction", "content": "The `RETURN` clause defines the parts of a pattern (nodes, relationships, and/or properties) to be included in the query result.\n\n[[return-example-graph]]"}, {"heading": "Example graph", "content": "The following graph is used for the examples below:\n\nimage::graph-return-clause.svg[Example graph connecting a person node to a movie node via acted in and directed relationships,width=400,role=popup]\n\nTo recreate the graph, run the following query against an empty Neo4j database.\n\n[source, cypher, role=test-setup]\n----\nCREATE\n  (keanu:Person {name: 'Keanu Reeves', bornIn: 'Beirut', nationality: 'Canadian'}),\n  (taiChi:Movie {title: 'Man of Tai Chi', released: 2013}),\n  (keanu)-[:ACTED_IN]->(taiChi),\n  (keanu)-[:DIRECTED]->(taiChi)\n----\n\n\n[[return-nodes]]"}, {"heading": "Return nodes", "content": "To return a node, list it in the `RETURN` clause:\n\n.Query\n// tag::clauses_return_node[]\n[source, cypher]\n----\nMATCH (p:Person {name: 'Keanu Reeves'})\nRETURN p\n----\n// end::clauses_return_node[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| p\n| {\"bornIn\":\"Beirut\",\"nationality\":\"Canadian\",\"name\":\"Keanu Reeves\"}\nd|Rows: 1\n|===\n\n\n[[return-relationships]]"}, {"heading": "Return relationships", "content": "To return a relationship type, list it in the `RETURN` clause:\n\n.Query\n// tag::clauses_return_relationship_type[]\n[source, cypher]\n----\nMATCH (p:Person {name: 'Keanu Reeves'})-[r:ACTED_IN]->(m)\nRETURN type(r)\n----\n// end::clauses_return_relationship_type[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| type(r)\n| \"ACTED_IN\"\nd|Rows: 1\n|===\n\n\n[[return-property]]"}, {"heading": "Return property", "content": "To return a specific property, use the dot separator:\n\n.Query\n// tag::clauses_return_property[]\n[source, cypher]\n----\nMATCH (p:Person {name: 'Keanu Reeves'})\nRETURN p.bornIn\n----\n// end::clauses_return_property[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| p.bornIn\n| \"Beirut\"\nd|Rows: 1\n|===\n\n[TIP]\nIt is more performant to return properties rather than the full node or relationship.\n\n\n[[return-all-elements]]"}, {"heading": "Return all elements", "content": "To return all nodes, relationships and paths found in a query, use the `*` symbol:\n\n.Query\n// tag::clauses_return_all_elements[]\n[source, cypher]\n----\nMATCH p = (keanu:Person {name: 'Keanu Reeves'})-[r]->(m)\nRETURN *\n----\n// end::clauses_return_all_elements[]\n\nThis returns the two nodes, and the two possible paths between them.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"4*<m\"]\n|===\n| keanu | m | p | r\n| {\"bornIn\":\"Beirut\",\"nationality\":\"Canadian\",\"name\":\"Keanu Reeves\"} | {\"title\":\"Man of Tai Chi\",\"released\":2013} | (:Person {bornIn: \"Beirut\",nationality: \"Canadian\",name: \"Keanu Reeves\"})-[:ACTED_IN]->(:Movie {title: \"Man of Tai Chi\",released: 2013}) | {:ACTED_IN}\n| {\"bornIn\":\"Beirut\",\"nationality\":\"Canadian\",\"name\":\"Keanu Reeves\"} | {\"title\":\"Man of Tai Chi\",\"released\":2013} | (:Person {bornIn: \"Beirut\",nationality: \"Canadian\",name: \"Keanu Reeves\"})-[:DIRECTED]->(:Movie {title: \"Man of Tai Chi\",released: 2013}) | {:DIRECTED}\n4+d|Rows: 1\n|===\n\n\n[[return-variable-with-uncommon-characters]]"}, {"heading": "Variable with uncommon characters", "content": "To introduce a variable made up of characters not contained in the English alphabet, use ``` to enclose the variable:\n\n.Query\n[source, cypher]\n----\nMATCH (`/uncommon variable\\`)\nWHERE `/uncommon variable\\`.name = 'Keanu Reeves'\nRETURN `/uncommon variable\\`.bornIn\n----\n\nThe `bornIn` property of the node with the `name` property set to `'Keanu Reeves'` is returned:\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| `/uncommon variable\\`.bornIn\n| \"Beirut\"\nd|Rows: 1\n|===\n\n\n[[return-column-alias]]"}, {"heading": "Column alias", "content": "Names of returned columns can be renamed using the `AS` operator:\n\n.Query\n// tag::clauses_return_with_column_alias[]\n[source, cypher]\n----\nMATCH (p:Person {name: 'Keanu Reeves'})\nRETURN p.nationality AS citizenship\n----\n// end::clauses_return_with_column_alias[]\n\nReturns the `nationality` property of `'Keanu Reeves'`, but the column is renamed to `citizenship`.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| citizenship\n| \"Canadian\"\nd|Rows: 1\n|===\n\n\n[[return-optional-properties]]"}, {"heading": "Optional properties", "content": "If the existence of a property is unknown, it can still be included in a `RETURN` clause.\nIt will be treated as `null` if it is missing.\n\n.Query\n[source, cypher]\n----\nMATCH (n)\nRETURN n.bornIn\n----\n\nThis example returns the `bornIn` properties for nodes that has that property, and `null` for  those nodes missing the property.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| n.bornIn\n| \"Beirut\"\n| <null>\nd|Rows: 2\n|===\n\n\n[[return-other-expressions]]"}, {"heading": "Other expressions", "content": "Any expression can be used as a return item -- literals, predicates, properties, functions, and so on.\n\n.Query\n[source, cypher]\n----\nMATCH (m:Movie {title: 'Man of Tai Chi'})\nRETURN m.released < 2012, \"I'm a literal\",[p=(m)--() | p] AS `(m)--()`\n----\n\nReturns a predicate, a literal and function call with a pattern expression parameter:\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"3*<m\"]\n|===\n| m.released < 2012 | \"I'm a literal\" | (m)--()\n| false | \"I'm a literal\" | [(:Movie {title: \"Man of Tai Chi\",released: 2013})<-[:DIRECTED]-(:Person {bornIn: \"Beirut\",nationality: \"Canadian\",name: \"Keanu Reeves\"}), (:Movie {title: \"Man of Tai Chi\",released: 2013})<-[:ACTED_IN]-(:Person {bornIn: \"Beirut\",nationality: \"Canadian\",name: \"Keanu Reeves\"})]\n3+d|Rows: 1\n|===\n\n\n[[return-unique-results]]"}, {"heading": "Unique results", "content": "`DISTINCT` retrieves only unique rows for the columns that have been selected for output.\n\n.Query\n// tag::clauses_return_distinct[]\n[source, cypher]\n----\nMATCH (p:Person {name: 'Keanu Reeves'})-->(m)\nRETURN DISTINCT m\n----\n// end::clauses_return_distinct[]\n\nThe `Movie` node `'Man of Tai Chi'` is returned by the query, but only once (without the `DISTINCT` operator it would have been returned twice because there are two relationships going to it from `'Keanu Reeves'`):\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| m\n| {\"title\":\"Man of Tai Chi\",\"released\":2013}+\nd|Rows: 1\n|===\n\n[role=label--new-2025.06]\n[[return-all-results]]"}, {"heading": "RETURN ALL", "content": "Returning all results can also be accomplished by explicitly including `ALL` in the `RETURN`.\nThe `RETURN ALL` keyword was introduced as part of Cypher's xref:appendix/gql-conformance/index.adoc[], and using it is functionally the same as using simple `RETURN`.\n\n.Query\n[source, cypher]\n----\nMATCH (p:Person {name: 'Keanu Reeves'})-->(m)\nRETURN ALL m\n----\n\nThe same node is returned twice, as there are two relationships connecting to it from `'Keanu Reeves'`.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| m\n| {\"title\":\"Man of Tai Chi\",\"released\":2013}+\n| {\"title\":\"Man of Tai Chi\",\"released\":2013}+\nd|Rows: 1\n|==="}], "source_file": "modules\\ROOT\\pages\\clauses\\return.adoc", "authority_level": 1}
{"name": "SEARCH", "description": "The `SEARCH` clause is a subclause of a `MATCH` or `OPTIONAL MATCH` clause and is used to filter the results based on vector similarity.", "syntax_examples": ["CREATE (:Movie {title: 'Aladdin', releaseDate: date('1992-11-08'), rating: 8.0}),\n       (:Movie {title: 'Cinderella', embedding: vector([1, 3, 4], 3, INTEGER), releaseDate: date('1950-02-15'), rating: 7.3}),\n       (:Movie:Favorite {title: 'Frozen', embedding: [1, 3, 3], releaseDate: date('2013-11-10'), rating: 7.4}),\n       (:Movie {title: 'Lilo & Stitch', embedding: vector([1, 1, 3], 3, INTEGER), releaseDate: date('2002-06-16'), rating: 7.4}),\n       (:Movie:Favorite {title: 'Lion King', embedding: vector([2, 5, 2], 3, INTEGER), releaseDate: date('1994-06-12'), rating: 8.5}),\n       (:Movie:Favorite {title: 'Mulan', embedding: [2, 3, 3], releaseDate: date('1998-06-05'), rating: 7.7}),\n       (:Movie {title: 'Snow White', embedding: vector([1, 2, 3], 3, INTEGER), releaseDate: date('1937-12-21'), rating: 7.6})", "CREATE VECTOR INDEX moviePlots IF NOT EXISTS\nFOR (m:Movie) ON m.embedding\nWITH [m.releaseDate, m.rating]\nOPTIONS {\n  indexConfig: {\n    `vector.similarity_function`: 'cosine',\n    `vector.dimensions`: 3,\n    `vector.quantization.enabled`: false\n  }\n}", "MATCH (movie:Movie)\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR vector([1, 2, 3], 3, INTEGER)\n    LIMIT 4\n  )\nRETURN movie.title AS title", "MATCH (movie:Movie)\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR [1, 2, 3]\n    LIMIT 4\n  )\nRETURN movie.title AS title", "MATCH (movie:Movie)\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR $snowWhiteEmbedding\n    LIMIT 4\n  )\nRETURN movie.title AS title", "MATCH (snowWhite:Movie {title: 'Snow White'})\nMATCH (movie:Movie)\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR snowWhite.embedding\n    LIMIT 4\n  )\nRETURN movie.title AS title", "MATCH (snowWhite:Movie {title: 'Snow White'})\nMATCH (movie:Movie)\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR snowWhite.embedding\n    LIMIT 4\n  ) SCORE AS similarityScore\nRETURN movie.title AS title, similarityScore", "MATCH (movie:Movie&Favorite)\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR vector([1, 2, 3], 3, INTEGER)\n    LIMIT 4\n  )\nRETURN movie.title AS title", "MATCH (movie:Movie {releaseDate: date('2013-11-10')})\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR vector([1, 2, 3], 3, INTEGER)\n    LIMIT 4\n  )\nRETURN movie.title AS title", "MATCH (movie:Movie)\n  WHERE movie.releaseDate > date('1990')\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR vector([1, 2, 3], 3, INTEGER)\n    LIMIT 4\n  )\nRETURN movie.title AS title, movie.releaseDate.year AS year"], "sections": [{"heading": "SEARCH clause syntax", "content": "The `SEARCH` clause has the following syntax\n[source, syntax]\n----\n[OPTIONAL] MATCH pattern\n  SEARCH binding_variable IN (\n    VECTOR INDEX index_name\n    FOR query_vector\n    [WHERE ...]\n    LIMIT top_k\n  ) [SCORE AS score_alias]\n----\n\nThe `SEARCH` clause constrains the `pattern` from the enclosing `MATCH` or `OPTIONAL MATCH`, by only returning nodes or relationships included in the results of the ANN vector search as described by the `SEARCH` clause.\nBelow follows a short description of the different parts of the syntax:\n\n- The `binding_variable` must be a node or relationship variable from the `pattern` of the enclosing `MATCH` or `OPTIONAL MATCH` clause.\n\n- The `index_name` must be an identifier that matches the name of an existing vector index in the Neo4j database.\nThe vector index must be a node vector index if the `binding_variable` refers to a node and a relationship vector index if the `binding_variable` refers to a relationship.\n\n- The `query_vector` can be any expression that evaluates to a `VECTOR` or `LIST<INTEGER NOT NULL | FLOAT NOT NULL>`, for example a literal, a parameter or a property.\nThe `SEARCH` clause returns a neighborhood of nodes or relationships based on the similarity between the `query_vector` the corresponding property of those nodes or relationships.\n\n- The optional `WHERE` subclause applies a filter to the vector index, and is a restricted version of the normal Cypher xref::clauses/where.adoc[`WHERE` clause].\nFor more information, see xref::clauses/search.adoc#vector-search-filtering-predicates[Predicates for vector search with filters].\n\n- The `LIMIT` clause sets the number of approximate nearest neighbor nodes or relationships returned by the `SEARCH` clause.\nThe `top_k` must be of type `INTEGER NOT NULL` and in the interval `0 \\<= top_k \\<= 2147483647` footnote:[2147483647 is the `Integer.MAX_VALUE` from Java].\n\n- The optional `SCORE` subclause makes the `SEARCH` clause return the similarity score for each node or relationship in addition to the node or relationship itself.\nIn the result, the column for the similarity scores will be called `score_alias`.\n\n- The `SEARCH` clause puts some restrictions on which `pattern` the enclosing `MATCH` or `OPTIONAL MATCH` clause is allowed to have.\nFor more information, see xref::clauses/search.adoc#limitations[Limitations of the `SEARCH` clause].\n\n\n[[search-example-graph]]"}, {"heading": "Example graph and vector index", "content": "The following graph is used for the examples below:\n\nimage::graph-search-clause.svg[Example graph with Movie nodes with title, release date and rating,width=700,role=popup]\n\nTo recreate the graph, run the following query in an empty Neo4j database:\n\n[source, cypher, role=test-setup]\n----\nCREATE (:Movie {title: 'Aladdin', releaseDate: date('1992-11-08'), rating: 8.0}),\n       (:Movie {title: 'Cinderella', embedding: vector([1, 3, 4], 3, INTEGER), releaseDate: date('1950-02-15'), rating: 7.3}),\n       (:Movie:Favorite {title: 'Frozen', embedding: [1, 3, 3], releaseDate: date('2013-11-10'), rating: 7.4}),\n       (:Movie {title: 'Lilo & Stitch', embedding: vector([1, 1, 3], 3, INTEGER), releaseDate: date('2002-06-16'), rating: 7.4}),\n       (:Movie:Favorite {title: 'Lion King', embedding: vector([2, 5, 2], 3, INTEGER), releaseDate: date('1994-06-12'), rating: 8.5}),\n       (:Movie:Favorite {title: 'Mulan', embedding: [2, 3, 3], releaseDate: date('1998-06-05'), rating: 7.7}),\n       (:Movie {title: 'Snow White', embedding: vector([1, 2, 3], 3, INTEGER), releaseDate: date('1937-12-21'), rating: 7.6})\n----\n\nEach node in the example graph represents a movie with properties for its title, release date and rating.\nThe majority of the nodes also have a `VECTOR` property called `embedding`, which is a vector representation of the plot of the movie.\nIn a real-world example, these vector embeddings would typically be generated by a proprietary or open source embedding generator and have a dimension of for example 768 or 1536, but for simplicity this example dataset uses vector embeddings of dimension 3.\n\nThe examples use a vector index named `moviePlots` on the `embedding` property and `releaseDate` and `rating` as additional properties for filtering.\nSuch a vector index can be created with the following Cypher query:\n\n[source, cypher, role=test-setup]\n----\nCREATE VECTOR INDEX moviePlots IF NOT EXISTS\nFOR (m:Movie) ON m.embedding\nWITH [m.releaseDate, m.rating]\nOPTIONS {\n  indexConfig: {\n    `vector.similarity_function`: 'cosine',\n    `vector.dimensions`: 3,\n    `vector.quantization.enabled`: false\n  }\n}\n----\n\nFor more information about the creation of vector indexes, see xref::indexes/semantic-indexes/vector-indexes.adoc#create-vector-index[Create vector indexes]."}, {"heading": "Basic vector search", "content": ""}, {"heading": "Find the most similar nodes", "content": "In our example dataset, the movie with the title `Snow White` has the embedding `vector([1, 2, 3], 3, INTEGER)`.\nTo find the 4 most similar movies to `Snow White`, you can run several different Cypher queries with the `SEARCH` clause.\n\n.Using a vector literal as the query vector\n====\n.Query\n// tag::clauses_search_vector_literal[]\n[source, cypher]\n----\nMATCH (movie:Movie)\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR vector([1, 2, 3], 3, INTEGER)\n    LIMIT 4\n  )\nRETURN movie.title AS title\n----\n// end::clauses_search_vector_literal[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| title\n\n| \"Snow White\"\n| \"Cinderella\"\n| \"Frozen\"\n| \"Mulan\"\n\n1+|Rows: 4\n|===\n====\n\n.Using a list literal as the query vector\n====\n.Query\n// tag::clauses_search_list_literal[]\n[source, cypher]\n----\nMATCH (movie:Movie)\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR [1, 2, 3]\n    LIMIT 4\n  )\nRETURN movie.title AS title\n----\n// end::clauses_search_list_literal[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| title\n\n| \"Snow White\"\n| \"Cinderella\"\n| \"Frozen\"\n| \"Mulan\"\n\n1+|Rows: 4\n|===\n====\n\n.Using a vector parameter as the query vector\n====\n.Parameters\n[source, parameters]\n----\n{\n  snowWhiteEmbedding: vector([1, 2, 3], 3, INTEGER)\n}\n----\n\n.Query\n// tag::clauses_search_vector_parameter[]\n[source, cypher]\n----\nMATCH (movie:Movie)\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR $snowWhiteEmbedding\n    LIMIT 4\n  )\nRETURN movie.title AS title\n----\n// end::clauses_search_vector_parameter[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| title\n\n| \"Snow White\"\n| \"Cinderella\"\n| \"Frozen\"\n| \"Mulan\"\n\n1+|Rows: 4\n|===\n====\n\n.Using a property as the query vector\n====\n.Query\n// tag::clauses_search_vector_from_graph[]\n[source, cypher]\n----\nMATCH (snowWhite:Movie {title: 'Snow White'})\nMATCH (movie:Movie)\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR snowWhite.embedding\n    LIMIT 4\n  )\nRETURN movie.title AS title\n----\n// end::clauses_search_vector_from_graph[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| title\n\n| \"Snow White\"\n| \"Cinderella\"\n| \"Frozen\"\n| \"Mulan\"\n\n1+|Rows: 4\n|===\n====\n\nAll four queries above return the same result.\nThe movie nodes are returned in decreasing similarity order.\n`Snow White` is the most similar movie to itself, while `Mulan` is the fourth most similar movie to `Snow White`.\nThe movies `Lilo & Stitch` and `Lion King` are not returned as they are not among the top 4 most similar movies, while the movie `Aladdin` does not have an `embedding` property and is therefore not considered by the vector index at all.\n\n[NOTE]\n====\nThe label predicate `:Movie` in the `MATCH` patterns above is not strictly required.\nAs the vector index only contains nodes with label `:Movie`, the `SEARCH` clause adds this predicate implicitly.\n===="}, {"heading": "Find the most similar nodes with score", "content": "To return the four most similar movies to `Snow White` together with their similarity score, you can include the optional `SCORE` subclause in the `SEARCH` clause.\n\n.Adding the similarity score to the output\n====\n.Query\n// tag::clauses_search_score[]\n[source, cypher]\n----\nMATCH (snowWhite:Movie {title: 'Snow White'})\nMATCH (movie:Movie)\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR snowWhite.embedding\n    LIMIT 4\n  ) SCORE AS similarityScore\nRETURN movie.title AS title, similarityScore\n----\n// end::clauses_search_score[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| title | similarityScore\n\n| \"Snow White\" | 1.0\n| \"Cinderella\" | 0.9979352951049805\n| \"Frozen\" | 0.9905114769935608\n| \"Mulan\" | 0.9843324422836304\n\n2+|Rows: 4\n|===\n====\n\nSimilarity scores have type `FLOAT NOT NULL` and are bounded between `0.0` and `1.0`.\nThe closer to `1.0` the score is, the more similar the indexed `embedding` property is to the query vector.\nThe movie `Snow White` has a similarity score of `1.0` as its `embedding` property is identical to the query vector.\n\nSimilarity scores are calculated using the similarity function that was chosen when the vector index was created, the default is cosine similarity.\nFor more information on similarity functions, see xref::indexes/semantic-indexes/vector-indexes.adoc#similarity-functions[Cosine and Euclidean similarity functions]."}, {"heading": "Additional predicates in the MATCH pattern", "content": "The pattern in the `MATCH` or `OPTIONAL MATCH` can have label and property predicates on the node or relationship with the binding variable.\n\n.Finding the most similar movies with an extra label predicate\n====\n.Query\n// tag::clauses_search_label_predicate[]\n[source, cypher]\n----\nMATCH (movie:Movie&Favorite)\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR vector([1, 2, 3], 3, INTEGER)\n    LIMIT 4\n  )\nRETURN movie.title AS title\n----\n// end::clauses_label_predicate[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| title\n\n| \"Frozen\"\n| \"Mulan\"\n\n1+|Rows: 2\n|===\n====\n\n[NOTE]\n====\nThe label predicate acts as a post-filtering step to the vector search.\nEven if the movie node with the title `Lion King` also has the label `Favorite`, it is not returned as it is not among the four most similar nodes to the query vector.\n====\n\n.Finding the most similar movies with an extra property predicate\n====\n.Query\n// tag::clauses_search_property_predicate[]\n[source, cypher]\n----\nMATCH (movie:Movie {releaseDate: date('2013-11-10')})\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR vector([1, 2, 3], 3, INTEGER)\n    LIMIT 4\n  )\nRETURN movie.title AS title\n----\n// end::clauses_property_predicate[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| title\n\n| \"Frozen\"\n\n1+|Rows: 2\n|===\n====\n\n[[vector-search-filtering]]"}, {"heading": "Vector search with filters", "content": "A `MATCH` or `OPTIONAL MATCH` clause can have both a `WHERE` subclause and `SEARCH` subclause.\nRegardless of their order, the `WHERE` clause will act as a post-filtering step to the vector search, further filtering down the results.\n\nEither of the queries below find the four most similar movies to `Snow White` and then filter down the result to only movies which were released after 1990.\n\n.The order of WHERE and SEARCH does not affect the result\n====\n.WHERE followed by SEARCH\n// tag::clauses_search_where_search[]\n[source, cypher]\n----\nMATCH (movie:Movie)\n  WHERE movie.releaseDate > date('1990')\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR vector([1, 2, 3], 3, INTEGER)\n    LIMIT 4\n  )\nRETURN movie.title AS title, movie.releaseDate.year AS year\n----\n// end::clauses_search_where_search[]\n\n.SEARCH followed by WHERE\n// tag::clauses_search_search_where[]\n[source, cypher]\n----\nMATCH (movie:Movie)\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR vector([1, 2, 3], 3, INTEGER)\n    LIMIT 4\n  )\n  WHERE movie.releaseDate > date('1990')\nRETURN movie.title AS title, movie.releaseDate.year AS year\n----\n// end::clauses_search_search_where[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| title | year\n\n| \"Frozen\" | 2013\n| \"Mulan\"  | 1998\n\n2+|Rows: 2\n|===\n====\n\nOften, it is preferable to do the filtering _while_ performing the vector search, so called in-index filtering, instead of as a post-filtering step.\nThis can be achieved with _vector search with filters_, where the `WHERE` is a subclause to the `SEARCH` clause instead of a subclause to the enclosing `MATCH` or `OPTIONAL MATCH` clause.\n\nTo find the four most similar movies to `Snow White` which were released after 1990 with a vector search with filters, use the following query.\n\n.Vector search with filter\n====\n.Query\n// tag::clauses_search_filter[]\n[source, cypher]\n----\nMATCH (movie:Movie)\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR vector([1, 2, 3], 3, INTEGER)\n    WHERE movie.releaseDate > date('1990')\n    LIMIT 4\n  )\nRETURN movie.title AS title, movie.releaseDate.year AS year\n----\n// end::clauses_search_filter[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| title | year\n\n| \"Frozen\"         | 2013\n| \"Mulan\"          | 1998\n| \"Lilo & Stitch\"  | 2002\n| \"Lion King\"      | 1994\n\n2+|Rows: 4\n|===\n====\n\n[NOTE]\n====\nWhen using vector search with filters, the vector search continues until it has found the requested number of result that also fulfills the other predicates.\nBy contrast, using a normal `WHERE` clause in the `MATCH` can lead to significantly fewer results.\nBecause of this, you might want to set a higher `LIMIT` in the `SEARCH` clause and complement it with a lower `LIMIT` in the `RETURN`.\nThis approach is called over-fetching.\n===="}, {"heading": "Combining vector search with filters and post-filtering", "content": "Vector search with filters and a normal `WHERE` clause can be combined.\nThe following query finds the four most similar movies to `Snow White` which were released after 1990, and then does post-filtering to discard any result with a rating worse than 7.5.\n\n.Vector search with filter and `WHERE` clause\n====\n.Query\n// tag::clauses_search_filtering_where[]\n[source, cypher]\n----\nMATCH (movie:Movie)\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR vector([1, 2, 3], 3, INTEGER)\n    WHERE movie.releaseDate > date('1990')\n    LIMIT 4\n  )\n  WHERE movie.rating > 7.5\nRETURN movie.title AS title, movie.releaseDate.year AS year, movie.rating AS rating\n----\n// end::clauses_search_filtering_where[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"3*<m\"]\n|===\n| title | year | rating\n\n| \"Mulan\"      | 1998 | 7.7\n| \"Lion King\"  | 1994 | 8.5\n\n3+|Rows: 2\n|===\n====\n\n[[vector-search-filtering-predicates]]"}, {"heading": "Predicates for vector search with filters", "content": "The optional `WHERE` subclause used to do _vector search with filters_ is a restricted version of the normal Cypher xref::clauses/where.adoc[`WHERE` clause] and only allows certain types of predicates.\nThe predicate must be a property predicate or several property predicates with `AND` between them.\n\n.Vector search with filter with an AND predicate on the same property\n====\n.Query\n// tag::clauses_search_filter_and_same[]\n[source, cypher]\n----\nMATCH (movie:Movie)\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR vector([1, 2, 3], 3, INTEGER)\n    WHERE movie.releaseDate > date('1948') AND date('2010') > movie.releaseDate\n    LIMIT 4\n  )\nRETURN movie.title AS title, movie.releaseDate.year AS year\n----\n// end::clauses_search_filter_and_same[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| title | year\n\n| \"Cinderella\"    | 1950\n| \"Mulan\"         | 1998\n| \"Lilo & Stitch\" | 2002\n| \"Lion King\"     | 1994\n\n2+|Rows: 4\n|===\n====\n\n[TIP]\n====\nThe `WHERE` subclause in the query above can also be written as `WHERE date('1948') <  movie.releaseDate < date('2010')` .\n====\n\n.Vector search with filter with an AND predicate on separate properties\n====\n.Query\n// tag::clauses_search_filter_and[]\n[source, cypher]\n----\nMATCH (snowWhite:Movie {title:\"Snow White\"})\nMATCH (movie:Movie)\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR snowWhite.embedding\n    WHERE movie.releaseDate < date('2000') AND movie.rating >= snowWhite.rating\n    LIMIT 4\n  )\nRETURN movie.title AS title, movie.releaseDate.year AS year, movie.rating AS rating\n----\n// end::clauses_search_filter_and[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"3*<m\"]\n|===\n| title | year | rating\n\n| \"Snow White\" | 1937 | 7.6\n| \"Mulan\"      | 1998 | 7.7\n| \"Lion King\"  | 1994 | 8.5\n\n3+|Rows: 4\n|===\n====\n\n[NOTE]\n====\nIf the `LIMIT` in the `SEARCH` clause is larger than the total number of indexed vectors fulfilling the predicate, the vector search will return fewer results.\nIn the example above, only three nodes are returned despite the `LIMIT` being four.\nDue to the approximate nature of vector search, this can also happen if the `LIMIT` is smaller than but close to the total number of indexed vectors fulfilling the predicate.\n====\n\nThe variable in the property predicate must be the same as the binding variable in the `SEARCH` clause.\n\n.Not allowed -- Mismatch of a property predicate variable and a binding variable in the SEARCH clause\n====\n.Query\n[source, cypher, role=test-fail]\n----\nMATCH (m: Movie {name: \"Snow White\"})\nMATCH (movie:Movie)\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR vector([1, 2, 3], 3, INTEGER)\n    WHERE m.rating > 8\n    LIMIT 4\n  )\nRETURN movie.title AS title\n----\n\n.GQLSTATUS error chain\n[role=\"queryresult\",stripes=\"all\",cols=\"1\"]\n|===\n| link:https://neo4j.com/docs/status-codes/current/errors/gql-errors/42I74/[42I74]: error: syntax error or access rule violation - wrong variable for vector search with filters. The variable `m` in a vector search filter property predicate must be the same as the search clause binding variable `movie`.\n\nlink:https://neo4j.com/docs/status-codes/current/errors/gql-errors/42001/[42001]: error: syntax error or access rule violation - invalid syntax\n|===\n\n====\n\nAll properties in the property predicate must have been added as additional properties for filtering when xref:#search-example-graph[creating the vector index].\n\n.Not allowed -- A property of the property predicate wasn't defined as an additional property in the vector index\n====\n.Query \n[source, cypher, role=test-fail]\n----\nMATCH (movie:Movie)\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR vector([1, 2, 3], 3, INTEGER)\n    WHERE movie.rating > 8 AND movie.title > \"L\"\n    LIMIT 4\n  )\nRETURN movie.title AS title, movie.rating AS rating\n----\n\n.GQLSTATUS error chain\n[role=\"queryresult\",stripes=\"all\",cols=\"1\"]\n|===\n| link:https://neo4j.com/docs/status-codes/current/errors/gql-errors/22ND3/[22ND3]: error: data exception - wrong property for vector search with filters. The property `title` is not an additional property for vector search with filters on the vector index `moviePlots`.\n|===\n\n====\n\nFor further limitations on the `WHERE` predicate, see xref::clauses/search.adoc#limitations-where[Limitations of the `WHERE` predicate]."}, {"heading": "More on vector search", "content": ""}, {"heading": "Using a query vector with different dimensions", "content": "If the query vector has a different dimension than the configured dimension of the vector index, the query will fail.\n\n.Not allowed -- Query vector with only two dimensions when three are being used\n====\n.Query\n[source, cypher, role=test-fail]\n----\nMATCH (movie:Movie)\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR vector([1, 2], 2, INTEGER)\n    LIMIT 4\n  )\nRETURN movie.title AS title\n----\n\n.GQLSTATUS error chain\n[role=\"queryresult\",stripes=\"all\",cols=\"1\"]\n|===\n| link:https://neo4j.com/docs/status-codes/current/errors/gql-errors/51N65/[51N65]: error: system configuration or operation exception - vector index dimensionality mismatch. Vector index `moviePlots` has a configured dimensionality of 3, but the provided vector has a dimension 2.\n|===\n====\n\n[NOTE]\n====\nIf the vector index has no configured dimension, the query succeeds.\nHowever, if there are no vectors in the index of the same dimension as the query vector, the result of the query will be empty.\n===="}, {"heading": "Using a query vector which evaluates to null", "content": "If the query vector evaluates to `null`, for example because it refers to a non-existing property, a `SEARCH` clause inside a `MATCH` returns no results.\n\n.A query vector which evaluates to null\n====\n.Query\n// tag::clauses_search_null_match[]\n[source, cypher]\n----\nMATCH (snowWhite:Movie {title: 'Snow White'})\nMATCH (movie:Movie)\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR snowWhite.prop\n    LIMIT 4\n  )\nRETURN movie.title AS title\n----\n// end::clauses_search_null_match[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| title\n1+|Rows: 0\n|===\n====\n\nIf the `SEARCH` clause with a query vector evaluating to `null` is instead in an `OPTIONAL MATCH` clause, it returns `null` as per regular `OPTIONAL MATCH` semantics.\n\n.A query vector which evaluates to null as per regular OPTIONAL MATCH semantics\n====\n.Query\n// tag::clauses_search_null_optional_match[]\n[source, cypher]\n----\nMATCH (snowWhite:Movie {title: 'Snow White'})\nOPTIONAL MATCH (movie:Movie)\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR snowWhite.prop\n    LIMIT 4\n  )\nRETURN movie.title AS title\n----\n// end::clauses_search_null_optional_match[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| title\n|null\n1+|Rows: 1\n|===\n===="}, {"heading": "Using a binding variable which is not from the enclosing clause", "content": "The binding variable in a `SEARCH` clause must be a node or relationship variable from the pattern of the enclosing `MATCH` or `OPTIONAL MATCH` clause.\nTrying to refer to a variable from an earlier clause in the query or introducing a new variable will cause the query to fail.\n\n.Not allowed -- Binding variable from earlier clause\n====\n.Query\n[source, cypher, role=test-fail]\n----\nMATCH (movie:Movie)\nMATCH (m: Movie {name: 'Snow White'})\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR m.embedding\n    LIMIT 4\n  )\nRETURN movie.title AS title\n----\n\n.GQLSTATUS error chain\n[role=\"queryresult\",stripes=\"all\",cols=\"1\"]\n|===\n| link:https://neo4j.com/docs/status-codes/current/errors/gql-errors/42I69/[42I69]: error: syntax error or access rule violation - invalid search variable reference. `movie` must reference a variable from the same MATCH statement.\n\nlink:https://neo4j.com/docs/status-codes/current/errors/gql-errors/42001/[42001]: error: syntax error or access rule violation - invalid syntax\n|===\n\n====\n\n.Not allowed -- Binding variable not previously defined\n====\n.Query\n[source, cypher, role=test-fail]\n----\nMATCH (movie:Movie)\n  SEARCH node IN (\n    VECTOR INDEX moviePlots\n    FOR vector([1, 2, 3], 3, INTEGER)\n    LIMIT 4\n  )\nRETURN movie.title AS title\n----\n\n.GQLSTATUS error chain\n[role=\"queryresult\",stripes=\"all\",cols=\"1\"]\n|===\n| link:https://neo4j.com/docs/status-codes/current/errors/gql-errors/42N62/[42N62]: error: syntax error or access rule violation - variable not defined. Variable `node` not defined.\n\nlink:https://neo4j.com/docs/status-codes/current/errors/gql-errors/42001/[42001]: error: syntax error or access rule violation - invalid syntax\n|===\n\n====\n\n[[limitations]]"}, {"heading": "Limitations of the SEARCH clause", "content": "The tables below list some past and current limitations of the `SEARCH` clause.\nIf applicable, the version which lifted the limitation is also listed.\n\nThe `SEARCH` clause puts restrictions on the pattern of the enclosing `MATCH` or `OPTIONAL MATCH` clause.\n\n.Limitations of the `MATCH` or `OPTIONAL MATCH` pattern\n[%header,cols=\"3a,4a,a\"]\n|===\n| Limitation | Disallowed example |  Lifted in\n| The pattern cannot have more than one bound variable.\n|`MATCH (movie:Movie)-[r]\\->()`\n|\n\n| The pattern cannot have predicates on other elements than the bound variable.\n| `MATCH (:Actor)-[]\\->(m:Movie)`\n|\n\n| The pattern cannot have a length longer than one relationship hop.\n| `MATCH ()-[r: KNOWS]\\->()-[]\\->()`\n\n`MATCH (movie:Movie)-[*1..3]\\->()`\n|\n\n| The pattern cannot have multiple pattern parts.\n| `MATCH (movie:Movie), ()`\n|\n\n| The pattern cannot have a path selector other than `ALL`.\n| `MATCH ANY 2 (movie: Movie)`\n|\n|===\n\nThe optional `WHERE` subclause used to do _vector search with filters_ is a restricted version of the normal Cypher xref::clauses/where.adoc[`WHERE` clause] and only allows certain types of property predicates.\n\n[[limitations-where]]\n.Limitations of the `WHERE` predicate\n[%header,cols=\"3a,3a,a\"]\n|===\n| Limitation | Disallowed example |  Lifted in\n|The xref:expressions/predicates/comparison-operators.adoc[comparison operator] in the predicate cannot be `<>`.\n| `WHERE movie.rating <> 7.5`\n|\n\n| The predicate cannot include other xref::expressions/predicates/boolean-operators.adoc[boolean operators] than `AND`.\n| `WHERE NOT movie.rating > 8`\nfootnote:[`NOT` is allowed for boolean properties.\nFor example, given that `seen` has been added as an additional property for filtering when the vector index was created, `WHERE NOT movie.seen` is allowed and will be rewritten to `WHERE movie.seen = false` internally.]\n\n`WHERE movie.rating > 8 OR movie.releaseDate \\<= date(\"2000\")`\n|\n\n| The predicate cannot include a xref::expressions/predicates/list-operators.adoc[list operator].\n| `WHERE movie.rating IN [7, 7.5, 8]`\n|\n\n\n| The predicate cannot include a xref::expressions/predicates/string-operators.adoc[string operator].\n| `WHERE movie.rating STARTS WITH '8'`\n|\n\n| The predicate cannot include a xref::expressions/predicates/type-predicate-expressions.adoc[type predicate expression].\n| `WHERE movie.rating IS +::+ FLOAT`\n|\n\n| The expression in the predicate cannot be of type `POINT`.\n| `WHERE movie.rating < point({x:2.3, y:4.5})`\n|\n\n| The expression in the predicate cannot be of type `VECTOR`.\n| `WHERE movie.rating < vector([8.2, 8.5], 2, FLOAT)`\n|\n\n| The expression in the predicate cannot be of type `LIST`.\n| `WHERE movie.rating < [8, 8.5]`\n|\n\n| The expression in the predicate is not allowed to reference the binding variable.\n| `WHERE movie.rating > movie.title`\n|\n\n| The predicate cannot contain multiple property predicates on the same property in the same direction.\n| `WHERE movie.rating > 8.2 AND movie.rating >= 8.5`\n|\n\n| The predicate cannot contain multiple property predicates on the same property where one is an equality and one is a range predicate.\n| `WHERE movie.rating > 8.2 AND movie.rating = 8.5`\n|\n|===\n\n.Other limitations of the SEARCH clause\n[%header,cols=\"4a,d\"]\n|===\n| Limitation | Lifted in\n\n| Unlike in other index commands such as `CREATE VECTOR INDEX` and `DROP INDEX`, the index name is not allowed to be a parameter in the `VECTOR INDEX` subclause of `SEARCH`.\n|\n\n|The query vector is not allowed to reference the binding variable.\n\n.Not allowed\n[source, cypher, role=test-fail]\n----\nMATCH (movie:Movie)\n  SEARCH movie IN (\n    VECTOR INDEX moviePlots\n    FOR movie.embedding\n    LIMIT 4\n  )\nRETURN movie.title AS title\n----\n\n.GQLSTATUS error chain\n[role=\"queryresult\",stripes=\"all\",cols=\"1\"]\n!===\n!link:https://neo4j.com/docs/status-codes/current/errors/gql-errors/42I75/[42I75]: error: syntax error or access rule violation - self-referencing in vector search. The expression 'movie.embedding' in the search clause may not depend on the search clause binding variable `movie`.\n\nlink:https://neo4j.com/docs/status-codes/current/errors/gql-errors/42001/[42001]: error: syntax error or access rule violation - invalid syntax\n!===\n|\n\n|==="}], "source_file": "modules\\ROOT\\pages\\clauses\\search.adoc", "authority_level": 1}
{"name": "SET", "description": "The `SET` clause is used to update labels on nodes and properties on nodes and relationships.", "syntax_examples": ["CREATE\n  (a:Swedish {name: 'Andy', age: 36, hungry: true}),\n  (b {name: 'Stefan'}),\n  (c {name: 'Peter', age: 34}),\n  (d {name: 'George'}),\n  (a)-[:KNOWS]->(c),\n  (b)-[:KNOWS]->(a),\n  (d)-[:KNOWS]->(c)", "MATCH (n {name: 'Andy'})\nSET n.surname = 'Taylor'\nRETURN n.name, n.surname", "MATCH (n:Swedish {name: 'Andy'})-[r:KNOWS]->(m)\nSET r.since = 1999\nRETURN r, m.name AS friend", "MATCH (n {name: 'Andy'})\nSET (CASE WHEN n.age = 36 THEN n END).worksIn = 'Malmo'\nRETURN n.name, n.worksIn", "MATCH(n) DETACH DELETE n;\nCREATE\n  (a:Swedish {name: 'Andy', age: 36, hungry: true}),\n  (b {name: 'Stefan'}),\n  (c {name: 'Peter', age: 34}),\n  (d {name: 'George'}),\n  (a)-[:KNOWS]->(c),\n  (b)-[:KNOWS]->(a),\n  (d)-[:KNOWS]->(c)", "MATCH (n {name: 'Andy'})\nSET (CASE WHEN n.age = 55 THEN n END).worksIn = 'Malmo'\nRETURN n.name, n.worksIn", "MATCH (n {name: 'Andy'})\nSET n.age = toString(n.age)\nRETURN n.name, n.age", "MATCH (n)\nFOREACH (k IN keys(n) | SET n[k + \"Copy\"] = n[k]) // <1>\nRETURN n.name, keys(n);", "MATCH (n {name: 'Andy'})\nSET n.name = null\nRETURN n.name, n.age", "MATCH(n) DETACH DELETE n;\nCREATE\n  (a:Swedish {name: 'Andy', age: 36, hungry: true}),\n  (b {name: 'Stefan'}),\n  (c {name: 'Peter', age: 34}),\n  (d {name: 'George'}),\n  (a)-[:KNOWS]->(c),\n  (b)-[:KNOWS]->(a),\n  (d)-[:KNOWS]->(c)"], "sections": [{"heading": "Example graph", "content": "The following graph is used for the examples below:\n\nimage::graph-set-clause.svg[Example graph connecting people through know relationships,width=300,role=popup]\n\nTo recreate it, run the following query against an empty Neo4j database:\n\n[source, cypher, role=test-setup]\n----\nCREATE\n  (a:Swedish {name: 'Andy', age: 36, hungry: true}),\n  (b {name: 'Stefan'}),\n  (c {name: 'Peter', age: 34}),\n  (d {name: 'George'}),\n  (a)-[:KNOWS]->(c),\n  (b)-[:KNOWS]->(a),\n  (d)-[:KNOWS]->(c)\n----\n\n[[set-set-a-property]]"}, {"heading": "Set a property", "content": "Update a node property:\n\n.Query\n[source, cypher]\n----\nMATCH (n {name: 'Andy'})\nSET n.surname = 'Taylor'\nRETURN n.name, n.surname\n----\n\nThe newly-changed node is returned by the query.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| n.name | n.surname\n| \"Andy\" | \"Taylor\"\n2+d|Rows: 1 +\nProperties set: 1\n|===\n\nUpdate a relationship property:\n\n.Query\n[source, cypher]\n----\nMATCH (n:Swedish {name: 'Andy'})-[r:KNOWS]->(m)\nSET r.since = 1999\nRETURN r, m.name AS friend\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| r | friend\n| [:KNOWS {since: 1999}] | \"Peter\"\n2+d|Rows: 1 +\nProperties set: 1\n|===\n\n\nIt is possible to set a property on a node or relationship using more complex expressions.\nFor instance, in contrast to specifying the node directly, the following query shows how to set a property for a node selected by an expression:\n\n.Query\n[source, cypher]\n----\nMATCH (n {name: 'Andy'})\nSET (CASE WHEN n.age = 36 THEN n END).worksIn = 'Malmo'\nRETURN n.name, n.worksIn\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| n.name | n.worksIn\n| \"Andy\" | \"Malmo\"\n2+d|Rows: 1 +\nProperties set: 1\n|===\n\nNo action will be taken if the node expression evaluates to `null`, as shown in this example:\n\n////\n[source, cypher, role=test-setup]\n----\nMATCH(n) DETACH DELETE n;\nCREATE\n  (a:Swedish {name: 'Andy', age: 36, hungry: true}),\n  (b {name: 'Stefan'}),\n  (c {name: 'Peter', age: 34}),\n  (d {name: 'George'}),\n  (a)-[:KNOWS]->(c),\n  (b)-[:KNOWS]->(a),\n  (d)-[:KNOWS]->(c)\n----\n////\n\n\n.Query\n[source, cypher]\n----\nMATCH (n {name: 'Andy'})\nSET (CASE WHEN n.age = 55 THEN n END).worksIn = 'Malmo'\nRETURN n.name, n.worksIn\n----\n\nAs no node matches the `CASE` expression, the expression returns a `null`.\nAs a consequence, no updates occur, and therefore no `worksIn` property is set.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| n.name | n.worksIn\n| \"Andy\" | <null>\n2+d|Rows: 1\n|===\n\n\n[[set-update-a-property]]"}, {"heading": "Update a property", "content": "`SET` can be used to update a property on a node or relationship.\nThis query forces a change of type in the `age` property:\n\n.Query\n[source, cypher]\n----\nMATCH (n {name: 'Andy'})\nSET n.age = toString(n.age)\nRETURN n.name, n.age\n----\n\nThe `age` property has been converted to the `STRING` `'36'`.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| n.name | n.age\n| \"Andy\" | \"36\"\n2+d|Rows: 1 +\nProperties set: 1\n|===\n\n\n[[dynamic-set-property]]"}, {"heading": "Dynamically set or update a property", "content": "`SET` can be used to set or update a property on a node or relationship even when the property key name is not statically known.\nThis allows for more flexible queries and mitigates the risk of Cypher injection.\n(For more information about Cypher injection, see link:https://neo4j.com/developer/kb/protecting-against-cypher-injection/[Neo4j Knowledge Base -> Protecting against Cypher injection]).\n\n[source, syntax]\n----\nSET n[key] = expression\n----\n\nThe dynamically calculated key must evaluate to a `STRING` value.\nThis query creates a copy of every property on the nodes:\n\n.Query\n[source, cypher]\n----\nMATCH (n)\nFOREACH (k IN keys(n) | SET n[k + \"Copy\"] = n[k]) // <1>\nRETURN n.name, keys(n);\n----\n\n\n<1> The xref:clauses/foreach.adoc[`FOREACH`] clause iterates over each property key `k` obtained from the xref::functions/list.adoc#functions-keys[`keys()`] function.\nFor each key, it sets a new property on the nodes with a key name of `k` + \"Copy\" and copies the value from the original property.\n\nThe nodes now have copies of all their properties.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| n.name   | keys(n)\n| \"Andy\"   | [\"name\", \"nameCopy\", \"age\", \"ageCopy\", \"hungry\", \"hungryCopy\"]\n| \"Stefan\" | [\"name\", \"nameCopy\"]\n| \"Peter\"  | [\"name\", \"nameCopy\", \"age\", \"ageCopy\"]\n| \"George\" | [\"name\", \"nameCopy\"]\n2+d|Rows: 4 +\nProperties set: 6\n|===\n\n\n[[set-remove-a-property]]"}, {"heading": "Remove a property", "content": "Although xref::clauses/remove.adoc[`REMOVE`] is normally used to remove a property, it is sometimes convenient to do it using the `SET` command.\nA case in point is if the property is provided by a parameter.\n\n.Query\n[source, cypher]\n----\nMATCH (n {name: 'Andy'})\nSET n.name = null\nRETURN n.name, n.age\n----\n\nThe `name` property is now missing.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| n.name | n.age\n| <null> | \"36\"\n2+d|Rows: 1 +\nProperties set: 1\n|===\n\n////\n[source, cypher, role=test-setup]\n----\nMATCH(n) DETACH DELETE n;\nCREATE\n  (a:Swedish {name: 'Andy', age: 36, hungry: true}),\n  (b {name: 'Stefan'}),\n  (c {name: 'Peter', age: 34}),\n  (d {name: 'George'}),\n  (a)-[:KNOWS]->(c),\n  (b)-[:KNOWS]->(a),\n  (d)-[:KNOWS]->(c)\n----\n////\n\n[[set-copying-properties-between-nodes-and-relationships]]"}, {"heading": "Copy properties between nodes and relationships", "content": "`SET` can be used to copy all properties from one node or relationship to another using the `properties()` function.\nThis will remove _all_ other properties on the node or relationship being copied to.\n\n.Query\n[source, cypher]\n----\nMATCH\n  (at {name: 'Andy'}),\n  (pn {name: 'Peter'})\nSET at = properties(pn)\nRETURN at.name, at.age, at.hungry, pn.name, pn.age\n----\n\nThe `'Andy'` node has had all its properties replaced by the properties of the `'Peter'` node.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"5*<m\"]\n|===\n| at.name | at.age | at.hungry | pn.name | pn.age\n| \"Peter\" | 34 | <null> | \"Peter\" | 34\n5+d|Rows: 1 +\nProperties set: 3\n|===\n\n////\n[source, cypher, role=test-setup]\n----\nMATCH (n) DETACH DELETE n;\nCREATE\n  (a:Swedish {name: 'Andy', age: 36, hungry: true}),\n  (b {name: 'Stefan'}),\n  (c {name: 'Peter', age: 34}),\n  (d {name: 'George'}),\n  (a)-[:KNOWS]->(c),\n  (b)-[:KNOWS]->(a),\n  (d)-[:KNOWS]->(c)\n----\n////\n\n[[set-replace-properties-using-map]]"}, {"heading": "Replace all properties using a map and `=`", "content": "The property replacement operator `=` can be used with `SET` to replace all existing properties on a node or relationship with those provided by a map:\n\n.Query\n[source, cypher]\n----\nMATCH (p {name: 'Peter'})\nSET p = {name: 'Peter Smith', position: 'Entrepreneur'}\nRETURN p.name, p.age, p.position\n----\n\nThis query updated the `name` property from `Peter` to `Peter Smith`, deleted the `age` property, and added the `position` property to the `'Peter'` node.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"3*<m\"]\n|===\n| p.name | p.age | p.position\n| \"Peter Smith\" | <null> | \"Entrepreneur\"\n3+d|Rows: 1 +\nProperties set: 3\n|===\n\n////\n[source, cypher, role=test-setup]\n----\nMATCH (n) DETACH DELETE n;\nCREATE\n  (a:Swedish {name: 'Andy', age: 36, hungry: true}),\n  (b {name: 'Stefan'}),\n  (c {name: 'Peter', age: 34}),\n  (d {name: 'George'}),\n  (a)-[:KNOWS]->(c),\n  (b)-[:KNOWS]->(a),\n  (d)-[:KNOWS]->(c)\n----\n////\n\n[[set-remove-properties-using-empty-map]]"}, {"heading": "Remove all properties using an empty map and `=`", "content": "All existing properties can be removed from a node or relationship by using `SET` with `=` and an empty map as the right operand:\n\n.Query\n[source, cypher]\n----\nMATCH (p {name: 'Peter'})\nSET p = {}\nRETURN p.name, p.age\n----\n\nThis query removed all the existing properties -- namely, `name` and `age` -- from the `'Peter'` node.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| p.name | p.age\n| <null> | <null>\n2+d|Rows: 1 +\nProperties set: 2\n|===\n\n////\n[source, cypher, role=test-setup]\n----\nMATCH (n) DETACH DELETE n;\nCREATE\n  (a:Swedish {name: 'Andy', age: 36, hungry: true}),\n  (b {name: 'Stefan'}),\n  (c {name: 'Peter', age: 34}),\n  (d {name: 'George'}),\n  (a)-[:KNOWS]->(c),\n  (b)-[:KNOWS]->(a),\n  (d)-[:KNOWS]->(c)\n----\n////\n\n[[set-setting-properties-using-map]]"}, {"heading": "Mutate specific properties using a map and `+=`", "content": "The property mutation operator `+=` can be used with `SET` to mutate properties from a map in a fine-grained fashion:\n\n* Any properties in the map that are not on the node or relationship will be _added_.\n* Any properties not in the map that are on the node or relationship will be left as is.\n* Any properties that are in both the map and the node or relationship will be _replaced_ in the node or relationship.\nHowever, if any property in the map is `null`, it will be _removed_ from the node or relationship.\n\n.Query\n[source, cypher]\n----\nMATCH (p {name: 'Peter'})\nSET p += {age: 38, hungry: true, position: 'Entrepreneur'}\nRETURN p.name, p.age, p.hungry, p.position\n----\n\nThis query left the `name` property unchanged, updated the `age` property from `34` to `38`, and added the `hungry` and `position` properties to the `'Peter'` node.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"4*<m\"]\n|===\n| p.name | p.age | p.hungry | p.position\n| \"Peter\" | 38 | true | \"Entrepreneur\"\n4+d|Rows: 1 +\nProperties set: 3\n|===\n\n////\n[source, cypher, role=test-setup]\n----\nMATCH (n) DETACH DELETE n;\nCREATE\n  (a:Swedish {name: 'Andy', age: 36, hungry: true}),\n  (b {name: 'Stefan'}),\n  (c {name: 'Peter', age: 34}),\n  (d {name: 'George'}),\n  (a)-[:KNOWS]->(c),\n  (b)-[:KNOWS]->(a),\n  (d)-[:KNOWS]->(c)\n----\n////\n\nxref:clauses/set.adoc#set-remove-properties-using-empty-map[In contrast to the property replacement operator `=`], providing an empty map as the right operand to `+=` will not remove any existing properties from a node or relationship.\nIn line with the semantics detailed above, passing in an empty map with `+=` will have no effect:\n\n.Query\n[source, cypher]\n----\nMATCH (p {name: 'Peter'})\nSET p += {}\nRETURN p.name, p.age\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| p.name | p.age\n| \"Peter\" | 34\n2+d|Rows: 1\n|===\n\n\n[[set-set-multiple-properties-using-one-set-clause]]"}, {"heading": "Set multiple properties using one `SET` clause", "content": "Set multiple properties at once by separating them with a comma:\n\n.Query\n[source, cypher]\n----\nMATCH (n {name: 'Andy'})\nSET n.position = 'Developer', n.surname = 'Taylor'\n----\n\n.Result\n[role=\"queryresult\",options=\"footer\",cols=\"1*<m\"]\n|===\n|(empty result)\nd|Rows: 0 +\nProperties set: 2\n|===\n\n\n[[set-set-a-property-using-a-parameter]]"}, {"heading": "Set a property using a parameter", "content": "Use a parameter to set the value of a property:\n\n.Parameters\n[source, parameters]\n----\n{\n  \"surname\": \"Taylor\"\n}\n----\n\n.Query\n[source, cypher]\n----\nMATCH (n {name: 'Andy'})\nSET n.surname = $surname\nRETURN n.name, n.surname\n----\n\nA `surname` property has been added to the `'Andy'` node.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| n.name | n.surname\n| \"Andy\" | \"Taylor\"\n2+d|Rows: 1 +\nProperties set: 1\n|===\n\n\n[[set-set-all-properties-using-a-parameter]]"}, {"heading": "Set all properties using a parameter", "content": "This will replace all existing properties on the node with the new set provided by the parameter.\n\n.Parameters\n[source, parameters]\n----\n{\n  \"props\" : {\n    \"name\": \"Andy\",\n    \"position\": \"Developer\"\n  }\n}\n----\n\n.Query\n[source, cypher]\n----\nMATCH (n {name: 'Andy'})\nSET n = $props\nRETURN n.name, n.position, n.age, n.hungry\n----\n\nThe `'Andy'` node has had all its properties replaced by the properties in the `props` parameter.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"4*<m\"]\n|===\n| n.name | n.position | n.age | n.hungry\n| \"Andy\" | \"Developer\" | <null> | <null>\n4+d|Rows: 1 +\nProperties set: 4\n|===\n\n\n[[set-set-a-label-on-a-node]]"}, {"heading": "Set a label on a node", "content": "Use `SET` to set a label on a node:\n\n.Query\n[source, cypher]\n----\nMATCH (n {name: 'Stefan'})\nSET n:German\nRETURN n.name, labels(n) AS labels\n----\n\nThe newly-labeled node is returned by the query.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| n.name | labels\n| \"Stefan\" | [\"German\"]\n2+d|Rows: 1 +\nLabels added: 1\n|===\n\n[[dynamic-set-node-label]]"}, {"heading": "Dynamically set a node label", "content": "`SET` can be used to set a label on a node even when the label is not statically known.\n\n[source, syntax]\n----\nMATCH (n)\nSET n:$(<expr>)\n----\n\n.Query\n[source, cypher]\n----\nMATCH (n:Swedish)\nSET n:$(n.name)\nRETURN n.name, labels(n) AS labels\n----\n\nThe newly-labeled node is returned by the query.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| n.name | labels\n| \"Andy\" | [\"Swedish\", \"Andy\"]\n2+d|Rows: 1 +\nLabels added: 1\n|===\n\n\n[[set-set-a-label-using-a-parameter]]"}, {"heading": "Set a label using a parameter", "content": "Use a parameter to set the value of a label:\n\n.Parameters\n[source, parameters]\n----\n{\n  \"label\": \"Danish\"\n}\n----\n\n.Query\n[source, cypher]\n----\nMATCH (n {name: 'Stefan'})\nSET n:$($label)\nRETURN labels(n) AS labels\n----\n\nA `Danish` label has been added to the `'Stefan'` node.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| labels \n| ['German', 'Danish']\n1+d|Rows: 1 +\nLabels added: 1\n|===\n\n[[set-set-multiple-labels-on-a-node]]"}, {"heading": "Set multiple labels on a node", "content": "Set multiple labels on a node with `SET` and use `:` to separate the different labels:\n\n.Query\n[source, cypher]\n----\nMATCH (n {name: 'George'})\nSET n:Swedish:Bossman\nRETURN n.name, labels(n) AS labels\n----\n\nThe newly-labeled node is returned by the query.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| n.name | labels\n| \"George\" | [\"Swedish\",\"Bossman\"]\n2+d|Rows: 1 +\nLabels added: 2\n|===\n\n[[dynamic-set-multiple-node-labels]]"}, {"heading": "Set multiple labels dynamically on a node", "content": "It is possible to set multiple labels dynamically using a `LIST<STRING>` and/or by chaining them separately with a `:`:\n\n.Query\n[source, cypher]\n----\nWITH COLLECT { UNWIND range(0,3) AS id RETURN \"Label\" + id } as labels // <1>\nMATCH (n {name: 'George'})\nSET n:$(labels)\nRETURN n.name, labels(n) AS labels\n----\n\n<1> A xref:subqueries/collect.adoc[`COLLECT`] subquery aggregates the results of `UNWIND range(0,3) AS id RETURN \"Label\" + id`, which generates a `LIST<STRING>` strings (\"Label0\", \"Label1\", \"Label2\", \"Label3\"), and assigns it to the variable `labels`.\n\nThe newly-labeled node is returned by the query.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| n.name | labels\n| \"George\" | [\"Swedish\",\"Bossman\", \"Label0\", \"Label1\", \"Label2\", \"Label3\"]\n2+d|Rows: 1 +\nLabels added: 4\n|===\n\n\n\n[[set-set-multiple-labels-using-a-parameter]]"}, {"heading": "Set multiple labels using parameters", "content": "Use a parameter to set multiple labels:\n\n.Parameters\n[source, parameters]\n----\n{\n  \"labels\": [\"Swedish\", \"German\"]\n}\n----\n\n.Query\n[source, cypher]\n----\nMATCH (n {name: 'Peter'})\nSET n:$($labels)\nRETURN labels(n) AS labels\n----\n\nA `Swedish` and a `German` label has been added to the `'Peter'` node.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| labels\n| ['Swedish', 'German']\n1+d|Rows: 1 +\nLabels added: 2\n|==="}], "source_file": "modules\\ROOT\\pages\\clauses\\set.adoc", "authority_level": 1}
{"name": "SKIP", "description": "`SKIP` (and its synonym `OFFSET) defines from which row to start including the rows in the output.", "syntax_examples": ["CREATE\n  (andy: Person {name: 'Andy'}),\n  (bernard: Person {name: 'Bernard'}),\n  (charlotte: Person {name: 'Charlotte'}),\n  (david: Person {name: 'David'}),\n  (erika: Person {name: 'Erika'}),\n  (andy)-[:KNOWS]->(bernard),\n  (andy)-[:KNOWS]->(charlotte),\n  (andy)-[:KNOWS]->(david),\n  (andy)-[:KNOWS]->(erika)", "MATCH (n)\nRETURN n.name\nORDER BY n.name\nSKIP 3", "MATCH (n)\nRETURN n.name\nORDER BY n.name\nSKIP 1\nLIMIT 2", "MATCH (n)\nRETURN n.name\nORDER BY n.name\nSKIP 1 + toInteger(3 * rand())", "MATCH (n)\nSKIP 2\nRETURN collect(n.name) AS names", "MATCH (n)\nORDER BY n.name\nSKIP 2\nLIMIT 2\nRETURN collect(n.name) AS names", "MATCH (n)\nORDER BY n.name\nOFFSET 2\nLIMIT 2\nRETURN collect(n.name) AS names"], "sections": [{"heading": "Example graph", "content": "The following graph is used for the examples below:\n\nimage::graph-skip-clause.svg[Example graph with Person nodes connecting via knows relationships,width=600,role=popup]\n\nTo recreate it, run the following query against an empty Neo4j database:\n\n[source, cypher, role=test-setup]\n----\nCREATE\n  (andy: Person {name: 'Andy'}),\n  (bernard: Person {name: 'Bernard'}),\n  (charlotte: Person {name: 'Charlotte'}),\n  (david: Person {name: 'David'}),\n  (erika: Person {name: 'Erika'}),\n  (andy)-[:KNOWS]->(bernard),\n  (andy)-[:KNOWS]->(charlotte),\n  (andy)-[:KNOWS]->(david),\n  (andy)-[:KNOWS]->(erika)\n----\n\n[[examples]]"}, {"heading": "Examples", "content": ".Skip the first three rows\n====\n\nThe following query returns a subset of the result, starting from the fourth result.\n\n.Query\n[source, cypher]\n----\nMATCH (n)\nRETURN n.name\nORDER BY n.name\nSKIP 3\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| n.name\n| \"David\"\n| \"Erika\"\nd|Rows: 2\n|===\n\n====\n\n.Return the middle two rows\n====\n\nThe following query returns the middle two rows, with `SKIP` skipping the first and xref:clauses/limit.adoc[`LIMIT`] removing the final two.\n\n.Query\n// tag::clauses_skip[]\n[source, cypher]\n----\nMATCH (n)\nRETURN n.name\nORDER BY n.name\nSKIP 1\nLIMIT 2\n----\n// end::clauses_skip[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| n.name\n| \"Bernard\"\n| \"Charlotte\"\nd|Rows: 2\n|===\n\n====\n\n.Using an expression with `SKIP` to return a subset of the rows\n====\n\n`SKIP` accepts any expression that evaluates to a positive `INTEGER`, as long as it can be statically calculated (i.e. calculated before the query is run).\n\nThis query skips the first row and then xref:functions/mathematical-numeric.adoc#functions-rand[randomly] skips an additional 0, 1, or 2 rows, resulting in skipping a total of 1, 2, or 3 rows before returning the remaining names.\n\n.Query\n[source, cypher]\n----\nMATCH (n)\nRETURN n.name\nORDER BY n.name\nSKIP 1 + toInteger(3 * rand())\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| n.name\n| \"Bernard\"\n| \"Charlotte\"\n| \"David\"\n| \"Erika\"\nd|Rows: 4\n|===\n\n====\n\n\n\n[[skip-standalone-clause]]"}, {"heading": "Using `SKIP` as a standalone clause", "content": "`SKIP` can be used as a standalone clause, or in conjunction with xref:clauses/order-by.adoc[`ORDER BY`] or xref:clauses/limit.adoc[`LIMIT`].\n\n.Standalone use of `SKIP`\n// tag::clauses_skip_standalone[]\n[source, cypher]\n----\nMATCH (n)\nSKIP 2\nRETURN collect(n.name) AS names\n----\n// end::clauses_skip_standalone[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| names\n| [\"Charlotte\", \"David\", \"Erika\"]\n|Rows: 1\n|===\n\nThe following query orders all nodes by `name`, skips the two first rows and limits the results to two rows.\nIt then xref:functions/aggregating.adoc#functions-collect[collects] the results in a list.\n\n.`SKIP` used in conjunction with `ORDER BY` and `LIMIT`\n[source, cypher]\n----\nMATCH (n)\nORDER BY n.name\nSKIP 2\nLIMIT 2\nRETURN collect(n.name) AS names\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| names\n| [\"Charlotte\", \"David\"]\n|Rows: 1\n|===\n\n\n[[offset-synonym]]"}, {"heading": "`OFFSET` as a synonym to `SKIP`", "content": "`OFFSET` was introduced as part of Cypher's xref:appendix/gql-conformance/index.adoc[] and can be used as a synonym to `SKIP`.\n\n.Query\n// tag::clauses_skip_offset[]\n[source, cypher]\n----\nMATCH (n)\nORDER BY n.name\nOFFSET 2\nLIMIT 2\nRETURN collect(n.name) AS names\n----\n// end::clauses_skip_offset[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| names\n| [\"Charlotte\", \"David\"]\n|Rows: 1\n|==="}], "source_file": "modules\\ROOT\\pages\\clauses\\skip.adoc", "authority_level": 1}
{"name": "Transaction commands", "description": "This section explains the `SHOW TRANSACTIONS` and `TERMINATE TRANSACTIONS` commands.", "syntax_examples": ["SHOW TRANSACTIONS", "SHOW TRANSACTIONS YIELD database, currentQuery WHERE currentQuery contains 'Mark'", "SHOW TRANSACTIONS\nYIELD transactionId, elapsedTime, cpuTime, waitTime, idleTime,\n  currentQueryElapsedTime, currentQueryCpuTime, currentQueryWaitTime, currentQueryIdleTime\nRETURN\n  transactionId AS txId,\n  elapsedTime.milliseconds AS elapsedTimeMillis,\n  cpuTime.milliseconds AS cpuTimeMillis,\n  waitTime.milliseconds AS waitTimeMillis,\n  idleTime.seconds AS idleTimeSeconds,\n  currentQueryElapsedTime.milliseconds AS currentQueryElapsedTimeMillis,\n  currentQueryCpuTime.milliseconds AS currentQueryCpuTimeMillis,\n  currentQueryWaitTime.microseconds AS currentQueryWaitTimeMicros,\n  currentQueryIdleTime.seconds AS currentQueryIdleTimeSeconds", "SHOW TRANSACTIONS \"neo4j-transaction-3\"", "TERMINATE TRANSACTIONS \"neo4j-transaction-1\",\"neo4j-transaction-2\"", "TERMINATE TRANSACTIONS \"neo4j-transaction-1\",\"neo4j-transaction-2\"\nYIELD transactionId, message\nWHERE message <> \"Transaction terminated.\"", "TERMINATE TRANSACTIONS \"neo4j-transaction-1\",\"neo4j-transaction-2\"\nWHERE message <> \"Transaction terminated.\"", "SHOW TRANSACTIONS\nYIELD transactionId AS txId, username AS user\nWHERE user = \"Alice\"\nTERMINATE TRANSACTIONS txId\nYIELD message\nRETURN txId, message", "SHOW TRANSACTIONS\nYIELD transactionId, waitTime\nWHERE waitTime > duration({minutes: 30})\nTERMINATE TRANSACTIONS transactionId\nYIELD username, message\nRETURN *", "TERMINATE TRANSACTION 'neo4j-transaction-1', 'neo4j-transaction-2'\nYIELD username AS terminatedUser\nSHOW TRANSACTIONS\nYIELD username AS showUser, transactionId AS txId, database, currentQuery, status\nWHERE showUser = terminatedUser AND NOT status STARTS WITH 'Terminated'\nRETURN txId, showUser AS user, database, currentQuery"], "sections": [{"heading": "SHOW TRANSACTIONS", "content": "The `SHOW TRANSACTIONS` command is used to display running transactions within the instance.\nThis also includes fabric transactions.\nFor remote database aliases, transactions can be tracked by running `SHOW TRANSACTIONS` when connected to the remote database alias.\n\n[NOTE]\n====\nThe command `SHOW TRANSACTIONS` returns only the default output. For a full output use the optional `YIELD` command.\nFull output: `SHOW TRANSACTIONS YIELD *`.\n====\n\nThis command returns the following outputs:\n\n.List transactions output\n[options=\"header\", cols=\"4,6,2\"]\n|===\n| Column | Description | Type\n\nm| database\na| The name of the database the transaction is executing against. label:default-output[]\nm| STRING\n\nm| transactionId\na| The transaction ID. label:default-output[]\nm| STRING\n\nm| currentQueryId\na| The ID of the query currently executing in this transaction, or `null` if no query is currently executing. label:default-output[]\nm| STRING\n\nm| connectionId\na| The ID of the database connection attached to the transaction or an empty `STRING` for embedded connections. label:default-output[]\nm| STRING\n\nm| clientAddress\na| The client address of the connection issuing the transaction or `null` if unavailable. label:default-output[]\nm| STRING\n\nm| username\na| The username of the user executing the transaction. label:default-output[]\nm| STRING\n\nm| currentQuery\na| The query text of the query currently executing in this transaction, or `null` if no query is currently executing. label:default-output[]\nm| STRING\n\nm| startTime\na| The time at which the transaction was started. label:default-output[]\nm| ZONED DATETIME\n\nm| status\na| The current status of the transaction (`Terminated`, `Blocked`, `Closing`, or `Running`). label:default-output[]\nm| STRING\n\nm| elapsedTime\na| The time that has elapsed since the transaction was started. label:default-output[]\nm| DURATION\n\nm| outerTransactionId\na|\nThe ID of this transaction's outer transaction, if such exists, otherwise `null`.\nFor details, see xref:subqueries/subqueries-in-transactions.adoc[`CALL { ... } IN TRANSACTIONS`].\nm| STRING\n\nm| metaData\na| Any metadata associated with the transaction, or an empty map if there is none.\nm| MAP\n\nm| parameters\na| A map containing all the parameters used by the query currently executing in this transaction, or `null` if no query is currently executing.\nm| MAP\n\nm| planner\na|\nThe name of the Cypher planner used to plan the query currently executing in this transaction, or `null` if no query is currently executing.\nFor details, see xref::planning-and-tuning/query-tuning.adoc#cypher-planner[Cypher planner].\nm| STRING\n\nm| runtime\na| The name of the Cypher runtime used by the query currently executing in this transaction, or `null` if no query is currently executing.\nFor details, see xref::planning-and-tuning/runtimes/index.adoc[Cypher runtime].\nm| STRING\n\nm| indexes\na| The indexes utilized by the query currently executing in this transaction, or `null` if no query is currently executing.\nOnly indexes evaluating static node labels and relationship types are shown in this column.\nm| LIST<MAP>\n\n\nm| currentQueryStartTime\na| The time at which the query currently executing in this transaction was started, or `null` if no query is currently executing.\nm| ZONED DATETIME\n\nm| protocol\na|\nThe protocol used by the connection issuing the transaction.\nThis is not necessarily an internet protocol, such as _http_, etc., although it could be.\nIt might also be \"embedded\", for example, if this connection represents an embedded session.\nm| STRING\n\nm| requestUri\na| The request URI used by the client connection issuing the transaction, or `null` if the URI is not available.\nm| STRING\n\n\nm| currentQueryStatus\na| The current status of the query currently executing in this transaction (`parsing`, `planning`, `planned`, `running`, or `waiting`), or `null` if no query is currently executing.\nm| STRING\n\nm| statusDetails\na| Provide additional status details from the underlying transaction or an empty `STRING` if none is available.\nm| STRING\n\nm| resourceInformation\na| Information about any blocked transactions, or an empty map if there is none.\nm| MAP\n\nm| activeLockCount\na| Count of active locks held by the transaction.\nm| INTEGER\n\n\nm| currentQueryActiveLockCount\na| Count of active locks held by the query currently executing in this transaction.\nm| INTEGER\n\nm| cpuTime\na| CPU time that has been actively spent executing the transaction or `null` if unavailable.\nm| DURATION\n\nm| waitTime\na| Wait time that has been spent waiting to acquire locks.\nm| DURATION\n\nm| idleTime\na| Idle time for this transaction, or `null` if unavailable.\nm| DURATION\n\n\nm| currentQueryElapsedTime\na| The time that has elapsed since the query currently executing in this transaction was started, or `null` if no query is currently executing.\nm| DURATION\n\n\nm| currentQueryCpuTime\na| CPU time that has been actively spent executing the query currently executing in this transaction, or `null` if unavailable or no query is currently executing.\nm| DURATION\n\n\nm| currentQueryWaitTime\na| Wait time that has been spent waiting to acquire locks for the query currently executing in this transaction, or `null` if no query is currently executing.\nm| DURATION\n\n\nm| currentQueryIdleTime\na| Idle time for the query currently executing in this transaction, or `null` if unavailable or no query is currently executing.\nm| DURATION\n\n\nm| currentQueryAllocatedBytes\na| The number of bytes allocated on the heap so far by the query currently executing in this transaction, or `null` if unavailable or no query is currently executing.\nm| INTEGER\n\nm| allocatedDirectBytes\na| Amount of off-heap (native) memory allocated by the transaction in bytes or `null` if unavailable.\nm| INTEGER\n\nm| estimatedUsedHeapMemory\na| The estimated amount of used heap memory allocated by the transaction in bytes or `null` if unavailable.\nm| INTEGER\n\nm| pageHits\na| The total number of page cache hits that the transaction performed.\nm| INTEGER\n\nm| pageFaults\na| The total number of page cache faults that the transaction performed.\nm| INTEGER\n\n\nm| currentQueryPageHits\na| The total number of page cache hits that the query currently executing in this transaction performed.\nm| INTEGER\n\n\nm| currentQueryPageFaults\na| The total number of page cache faults that the query currently executing in this transaction performed.\nm| INTEGER\n\nm| initializationStackTrace\na| The initialization stacktrace for this transaction, or an empty `STRING` if unavailable.\nm| STRING\n\n|===\n\n\nThe `SHOW TRANSACTIONS` command can be combined with multiple `SHOW TRANSACTIONS` and `TERMINATE TRANSACTIONS`, see xref::clauses/transaction-clauses.adoc#query-combine-tx-commands[transaction commands combination]."}, {"heading": "Syntax", "content": "[NOTE]\n====\nMore details about the syntax descriptions can be found link:{neo4j-docs-base-uri}/operations-manual/current/database-administration/syntax/#administration-syntax-reading[here].\n====\n\nList transactions on the current server::\n\n[source, syntax, role=\"noheader\"]\n----\nSHOW TRANSACTION[S] [transaction-id[,...]]\n[YIELD { * | field[, ...] } [ORDER BY field[, ...]] [SKIP n] [LIMIT n]]\n[WHERE expression]\n[RETURN field[, ...] [ORDER BY field[, ...]] [SKIP n] [LIMIT n]]\n----\n\nThe format of `transaction-id` is `<databaseName>-transaction-<id>`.\nTransaction IDs must be supplied as one or more comma-separated quoted `STRING` values, or as an expression resolving to a `STRING` or a `LIST<STRING>`.\n\n[NOTE]\n====\nWhen using the `RETURN` clause, the `YIELD` clause is mandatory and must not be omitted.\n====\n\nA user with the link:{neo4j-docs-base-uri}/operations-manual/current/authentication-authorization/database-administration/#access-control-database-administration-transaction[`SHOW TRANSACTION`] privilege can view the currently executing transactions in accordance with the privilege grants.\nAll users may view all of their own currently executing transactions."}, {"heading": "Listing all transactions", "content": "To list all available transactions with the default outputs, use the `SHOW TRANSACTIONS` command.\nIf all outputs are required, use `SHOW TRANSACTIONS YIELD *`.\n\n.Query\n[source, cypher, role=test-result-skip]\n----\nSHOW TRANSACTIONS\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"10*<m\"]\n|===\n| database | transactionId | currentQueryId | connectionId | clientAddress | username | currentQuery | startTime | status | elapsedTime\n\n| \"neo4j\" | \"neo4j-transaction-6\" | \"query-664\" | \"\" | null | \"\" | \"SHOW TRANSACTIONS\" | \"2022-06-14T10:02:45.568Z\" | \"Running\" | PT0.038S\n| \"neo4j\" | \"neo4j-transaction-4\" | \"query-663\" | \"\" | null | \"\" | \"MATCH (n) RETURN n\" | \"2022-06-14T10:02:45.546Z\" | \"Running\" | PT0.06S\n\n10+d|Rows: 2\n|==="}, {"heading": "Listing transactions with filtering on output", "content": "The listed transactions can be filtered by using the `WHERE` clause.\nFor example, getting the databases for all transactions where the currently executing query contains `'Mark'`:\n\n.Query\n[source, cypher, role=test-result-skip]\n----\nSHOW TRANSACTIONS YIELD database, currentQuery WHERE currentQuery contains 'Mark'\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| database | currentQuery\n\n| \"neo4j\" | \"MATCH (p:Person) WHERE p.name='Mark' RETURN p\"\n| \"neo4j\" | \"SHOW TRANSACTIONS YIELD database, currentQuery WHERE currentQuery contains 'Mark'\"\n\n2+d|Rows: 2\n|===\n\nSeveral of the outputs have the `duration` type, which can be hard to read.\nThey can instead be returned in a more readable format:\n\n.Query\n[source, cypher, role=test-result-skip]\n----\nSHOW TRANSACTIONS\nYIELD transactionId, elapsedTime, cpuTime, waitTime, idleTime,\n  currentQueryElapsedTime, currentQueryCpuTime, currentQueryWaitTime, currentQueryIdleTime\nRETURN\n  transactionId AS txId,\n  elapsedTime.milliseconds AS elapsedTimeMillis,\n  cpuTime.milliseconds AS cpuTimeMillis,\n  waitTime.milliseconds AS waitTimeMillis,\n  idleTime.seconds AS idleTimeSeconds,\n  currentQueryElapsedTime.milliseconds AS currentQueryElapsedTimeMillis,\n  currentQueryCpuTime.milliseconds AS currentQueryCpuTimeMillis,\n  currentQueryWaitTime.microseconds AS currentQueryWaitTimeMicros,\n  currentQueryIdleTime.seconds AS currentQueryIdleTimeSeconds\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"9*<m\"]\n|===\n| txId | elapsedTimeMillis | cpuTimeMillis | waitTimeMillis | idleTimeSeconds | currentQueryElapsedTimeMillis | currentQueryCpuTimeMillis | currentQueryWaitTimeMicros | currentQueryIdleTimeSeconds\n| \"neo4j-transaction-5\" | 1055 | 767 | 0 | 0 | 1012 | 767 | 0 | 0\n| \"neo4j-transaction-9\" | 156 | 155 | 0 | 0 | 97 | 97 | 0 | 0\n| \"neo4j-transaction-4\" | 1082 | 17 | 0 | 1 | 1013 | 17 | 0 | 0\n9+d|Rows: 3\n|==="}, {"heading": "Listing specific transactions", "content": "It is possible to specify which transactions to return in the list by transaction ID.\n\n.Query\n[source, cypher, role=test-result-skip]\n----\nSHOW TRANSACTIONS \"neo4j-transaction-3\"\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"10*<m\"]\n|===\n| database | transactionId | currentQueryId | connectionId | clientAddress | username | currentQuery | startTime | status | elapsedTime\n\n| \"neo4j\" | \"neo4j-transaction-3\" | \"query-1\" | \"\" | null | \"\" | \"MATCH (n) RETURN n\" | \"2021-10-20T08:29:39.423Z\" | \"Running\" | PT2.603S\n\n10+d|Rows: 1\n|===\n\n\n[[query-terminate-transactions]]"}, {"heading": "TERMINATE TRANSACTIONS", "content": "The `TERMINATE TRANSACTIONS` command is used to terminate running transactions by their IDs.\n\n[NOTE]\n====\nThe outputs for the `TERMINATE TRANSACTIONS` command there is no difference between the default output and full output (`YIELD *`), all outputs are default.\n====\n\nThis command returns the following outputs:\n\n.Terminate transactions output\n[options=\"header\", cols=\"4,6,2\"]\n|===\n| Column | Description | Type\n\nm| transactionId\na| The transaction ID.\nm| STRING\n\nm| username\na| The username of the user executing the transaction.\nm| STRING\n\nm| message\na| The result of the `TERMINATE TRANSACTION` command as applied to this transaction.\nm| STRING\n\n|===\n\n\nThe `TERMINATE TRANSACTIONS` command can be combined with multiple `SHOW TRANSACTIONS` and `TERMINATE TRANSACTIONS`, see xref::clauses/transaction-clauses.adoc#query-combine-tx-commands[transaction commands combination]."}, {"heading": "Syntax", "content": "[NOTE]\n====\nMore details about the syntax descriptions can be found link:{neo4j-docs-base-uri}/operations-manual/current/database-administration/syntax/#administration-syntax-reading[here].\n====\n\nTerminate transactions by ID on the current server::\n\n[source, syntax, role=\"noheader\"]\n----\nTERMINATE TRANSACTION[S] transaction_id[, ...]\n[YIELD { * \\| field[, ...] }\n  [ORDER BY field[, ...]]\n  [SKIP n]\n  [LIMIT n]\n  [WHERE expression]\n  [RETURN field[, ...] [ORDER BY field[, ...]] [SKIP n] [LIMIT n]]\n]\n----\n\nThe format of `transaction-id` is `<databaseName>-transaction-<id>`.\nTransaction IDs must be supplied as one or more comma-separated quoted `STRING` values, or as an expression resolving to a `STRING` or a `LIST<STRING>`.\n\n[NOTE]\n====\nWhen using the `WHERE` or `RETURN` clauses, the `YIELD` clause is mandatory and must not be omitted.\n====\n\nA user with the link:{neo4j-docs-base-uri}/operations-manual/current/authentication-authorization/database-administration/#access-control-database-administration-transaction[`TERMINATE TRANSACTION`] privilege can terminate transactions in accordance with the privilege grants.\nAll users may terminate their own currently executing transactions."}, {"heading": "Terminate transactions", "content": "To end running transactions without waiting for them to complete on their own, use the `TERMINATE TRANSACTIONS` command.\n\n.Query\n[source, cypher, role=test-skip]\n----\nTERMINATE TRANSACTIONS \"neo4j-transaction-1\",\"neo4j-transaction-2\"\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"3*<m\"]\n|===\n| transactionId | username | message\n\n| \"neo4j-transaction-1\" | \"neo4j\" | \"Transaction terminated.\"\n| \"neo4j-transaction-2\" | null | \"Transaction not found.\"\n\n3+d|Rows: 2\n|==="}, {"heading": "Terminate transactions with filtering on output", "content": "The output from the `TERMINATE TRANSACTIONS` command can be filtered using the `YIELD` and `WHERE` clauses.\n\n\n.TERMINATE TRANSACTION YIELD\n======\nFor example, returning the transaction IDs and message for the transactions that did not terminate.\n\n.Query\n[source, cypher, role=test-skip]\n----\nTERMINATE TRANSACTIONS \"neo4j-transaction-1\",\"neo4j-transaction-2\"\nYIELD transactionId, message\nWHERE message <> \"Transaction terminated.\"\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| transactionId | message\n| \"neo4j-transaction-2\" | \"Transaction not found.\"\n2+d|Rows: 1\n|===\n\n======\n\n\n.TERMINATE TRANSACTION error\n======\n\nIn difference to `SHOW TRANSACTIONS`; the `TERMINATE TRANSACTIONS` does not allow `WHERE` without `YIELD`.\n\n.Query\n[source, cypher, role=test-fail]\n----\nTERMINATE TRANSACTIONS \"neo4j-transaction-1\",\"neo4j-transaction-2\"\nWHERE message <> \"Transaction terminated.\"\n----\n\n.GQLSTATUS error chain\n[role=\"queryresult\",stripes=\"all\",cols=\"1\"]\n|===\n| link:https://neo4j.com/docs/status-codes/current/errors/gql-errors/42N84/[42N84]: error: syntax error or access rule violation - TERMINATE TRANSACTION misses YIELD clause. WHERE clause without YIELD clause. Use 'TERMINATE TRANSACTION ... YIELD ... WHERE ...'.\n|===\n\n======\n\n\n[[query-combine-tx-commands]]"}, {"heading": "Combining transaction commands", "content": "In difference to other show commands, the `SHOW` and `TERMINATE TRANSACTIONS` commands can be combined in the same query.\n\n[NOTE]\n====\nWhen combining multiple commands the `YIELD` and `RETURN` clauses are mandatory and must not be omitted.\nIn addition, `YIELD *` is not permitted.\nInstead, the `YIELD` clause needs to explicitly list the yielded columns.\n====\n\n[NOTE]\n====\nAt this point in time, no other cypher clauses are allowed to be combined with the transaction commands.\n===="}, {"heading": "Terminating all transactions by a given user", "content": "To terminate all transactions by a user, first find the transactions using `SHOW TRANSACTIONS`, then pass them onto `TERMINATE TRANSACTIONS`.\n\n\n.TERMINATE TRANSACTIONS\n======\n\n.Query\n[source, cypher, role=test-result-skip]\n----\nSHOW TRANSACTIONS\nYIELD transactionId AS txId, username AS user\nWHERE user = \"Alice\"\nTERMINATE TRANSACTIONS txId\nYIELD message\nRETURN txId, message\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| txId | message\n| \"neo4j-transaction-1\" | \"Transaction terminated.\"\n| \"neo4j-transaction-2\" | \"Transaction terminated.\"\n2+d|Rows: 2\n|===\n\n======"}, {"heading": "Terminating starving transactions", "content": "To terminate transactions that have been waiting for more than `30` minutes, first find the transactions using `SHOW TRANSACTIONS`, then pass them onto `TERMINATE TRANSACTIONS`.\n\n\n.TERMINATE TRANSACTIONS\n======\n\nThe following example shows a transaction that has been waiting for `40` minutes.\n\n.Query\n[source, cypher, role=test-result-skip]\n----\nSHOW TRANSACTIONS\nYIELD transactionId, waitTime\nWHERE waitTime > duration({minutes: 30})\nTERMINATE TRANSACTIONS transactionId\nYIELD username, message\nRETURN *\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"4*<m\"]\n|===\n| transactionId | waitTime | username | message\n| \"neo4j-transaction-1\" | PT40M | \"Alice\" | \"Transaction terminated.\"\n4+d|Rows: 1\n|===\n\n======"}, {"heading": "Listing other transactions by the same user that were terminated", "content": "To list remaining transactions by users whose transactions were terminated, first terminate the transactions using `TERMINATE TRANSACTIONS`, then filter users through `SHOW TRANSACTIONS`.\n\n\n.TERMINATE TRANSACTIONS\n======\n\n.Query\n[source, cypher, role=test-result-skip]\n----\nTERMINATE TRANSACTION 'neo4j-transaction-1', 'neo4j-transaction-2'\nYIELD username AS terminatedUser\nSHOW TRANSACTIONS\nYIELD username AS showUser, transactionId AS txId, database, currentQuery, status\nWHERE showUser = terminatedUser AND NOT status STARTS WITH 'Terminated'\nRETURN txId, showUser AS user, database, currentQuery\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"4*<m\"]\n|===\n| txId | user | database | currentQuery\n| \"neo4j-transaction-3\" | \"Alice\" | \"neo4j\" | \"MATCH (n) RETURN n\"\n| \"mydb-transaction-1\" | \"Bob\" | \"mydb\" | \"MATCH (n:Label) SET n.prop=false\"\n| \"system-transaction-999\" | \"Bob\" | \"system\" | \"SHOW DATABASES\"\n4+d|Rows: 2\n|===\n\n======"}, {"heading": "Listing other transactions by the same user as a given transaction", "content": "To list other transactions by the same user as a given transaction, first find the transactions using `SHOW TRANSACTIONS`, then filter users through a second `SHOW TRANSACTIONS`.\n\n\n.SHOW TRANSACTIONS\n======\n\n.Query\n[source, cypher, role=test-result-skip]\n----\nSHOW TRANSACTION 'neo4j-transaction-1'\nYIELD username AS originalUser, transactionId AS originalTxId\nSHOW TRANSACTIONS\nYIELD username AS newUser, transactionId AS txId, database, currentQuery, status\nWHERE newUser = originalUser AND NOT txId = originalTxId\nRETURN txId, newUser AS user, database, currentQuery, status\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"5*<m\"]\n|===\n| txId | user | database | currentQuery | status\n| \"mydb-transaction-1\" | \"Bob\" | \"mydb\" | \"MATCH (n:Label) SET n.prop=false\" | \"Running\"\n| \"system-transaction-999\" | \"Bob\" | \"system\" | \"SHOW DATABASES\" | \"Running\"\n5+d|Rows: 2\n|===\n\n======"}], "source_file": "modules\\ROOT\\pages\\clauses\\transaction-clauses.adoc", "authority_level": 1}
{"name": "UNWIND", "description": "`UNWIND` expands a list into a sequence of rows.", "syntax_examples": ["UNWIND [1, 2, 3, null] AS x\nRETURN x, 'val' AS y", "WITH [1, 1, 2, 2] AS coll\nUNWIND coll AS x\nWITH DISTINCT x\nRETURN collect(x) AS setOfVals", "WITH\n  [1, 2] AS a,\n  [3, 4] AS b\nUNWIND (a + b) AS x\nRETURN x", "WITH [[1, 2], [3, 4], 5] AS nested\nUNWIND nested AS x\nUNWIND x AS y\nRETURN y", "UNWIND [] AS empty\nRETURN 'literal_that_is_not_returned'", "WITH [] AS list\nUNWIND\n  CASE\n    WHEN list = [] THEN [null]\n    ELSE list\n  END AS emptylist\nRETURN emptylist", "UNWIND null AS x\nRETURN x, 'some_literal'", "UNWIND $events AS event\nMERGE (y:Year {year: event.year})\nMERGE (y)<-[:IN]-(e:Event {id: event.id})\nRETURN e.id AS x ORDER BY x"], "sections": [{"heading": "Unwinding a list", "content": "We want to transform the literal list into rows named `x` and return them.\n\n.Query\n// tag::clauses_unwind_list[]\n[source, cypher]\n----\nUNWIND [1, 2, 3, null] AS x\nRETURN x, 'val' AS y\n----\n// end::clauses_unwind_list[]\n\nEach value of the original list -- including `null` -- is returned as an individual row.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| x | y\n| 1 | \"val\"\n| 2 | \"val\"\n| 3 | \"val\"\n| <null> | \"val\"\n2+|Rows: 4\n|===\n\n\n[[unwind-creating-a-distinct-list]]"}, {"heading": "Creating a distinct list", "content": "We want to transform a list of duplicates into a set using `DISTINCT`.\n\n.Query\n[source, cypher]\n----\nWITH [1, 1, 2, 2] AS coll\nUNWIND coll AS x\nWITH DISTINCT x\nRETURN collect(x) AS setOfVals\n----\n\nEach value of the original list is unwound and passed through `DISTINCT` to create a unique set.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| setOfVals\n| [1,2]\n|Rows: 1\n|===\n\n\n[[unwind-using-unwind-with-any-expression-returning-a-list]]"}, {"heading": "Using `UNWIND` with any expression returning a list", "content": "Any expression that returns a list may be used with `UNWIND`.\n\n.Query\n[source, cypher]\n----\nWITH\n  [1, 2] AS a,\n  [3, 4] AS b\nUNWIND (a + b) AS x\nRETURN x\n----\n\nThe two lists -- _a_ and _b_ -- are concatenated to form a new list, which is then operated upon by `UNWIND`.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| x\n| 1\n| 2\n| 3\n| 4\n|Rows: 4\n|===\n\n\n[[unwind-using-unwind-with-a-list-of-lists]]"}, {"heading": "Using `UNWIND` with a list of lists", "content": "Multiple `UNWIND` clauses can be chained to unwind nested list elements.\n\n.Query\n// tag::clauses_unwind_nested_list[]\n[source, cypher]\n----\nWITH [[1, 2], [3, 4], 5] AS nested\nUNWIND nested AS x\nUNWIND x AS y\nRETURN y\n----\n// end::clauses_unwind_nested_list[]\n\nThe first `UNWIND` results in three rows for `x`, each of which contains an element of the original list (two of which are also lists); namely, `[1, 2]`, `[3, 4]`, and `5`.\nThe second `UNWIND` then operates on each of these rows in turn, resulting in five rows for `y`.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| y\n| 1\n| 2\n| 3\n| 4\n| 5\n|Rows: 5\n|===\n\n\n[[unwind-using-unwind-with-an-empty-list]]"}, {"heading": "Using `UNWIND` with an empty list", "content": "Using an empty list with `UNWIND` will produce no rows, irrespective of whether or not any rows existed beforehand, or whether or not other values are being projected.\n\nEssentially, `UNWIND []` reduces the number of rows to zero, and thus causes the query to cease its execution, returning no results.\nThis has value in cases such as `UNWIND v`, where `v` is a variable from an earlier clause that may or may not be an empty list -- when it is an empty list, this will behave just as a `MATCH` that has no results.\n\n\n.Query\n[source, cypher]\n----\nUNWIND [] AS empty\nRETURN 'literal_that_is_not_returned'\n----\n\n.Result\n[role=\"queryresult\",options=\"footer\",cols=\"2*<m\"]\n|===\n2+|(empty result)\n2+d|Rows: 0\n|===\n\nTo avoid inadvertently using `UNWIND` on an empty list, `CASE` may be used to replace an empty list with a `null`:\n\n[source, cypher]\n----\nWITH [] AS list\nUNWIND\n  CASE\n    WHEN list = [] THEN [null]\n    ELSE list\n  END AS emptylist\nRETURN emptylist\n----\n\n\n[[unwind-using-unwind-with-an-expression-that-is-not-a-list]]"}, {"heading": "Using `UNWIND` with an expression that is not a list", "content": "Using `UNWIND` on an expression that does not return a list, will return the same result as using `UNWIND` on a list that just contains that expression.\nAs an example, `UNWIND 5` is effectively equivalent to  `UNWIND[5]`.\nThe exception to this is when the expression returns `null` -- this will reduce the number of rows to zero, causing it to cease its execution and return no results.\n\n.Query\n[source, cypher]\n----\nUNWIND null AS x\nRETURN x, 'some_literal'\n----\n\n.Result\n[role=\"queryresult\",options=\"footer\",cols=\"2*<m\"]\n|===\n2+|(empty result)\n2+|Rows: 0\n|===\n\n\n[[unwind-creating-nodes-from-a-list-parameter]]"}, {"heading": "Creating nodes from a list parameter", "content": "Create a number of nodes and relationships from a parameter-list without using `FOREACH`.\n\n.Parameters\n[source, parameters]\n----\n{\n  \"events\" : [ {\n    \"year\" : 2014,\n    \"id\" : 1\n  }, {\n    \"year\" : 2014,\n    \"id\" : 2\n  } ]\n}\n----\n\n.Query\n// tag::clauses_unwind_create_nodes[]\n[source, cypher]\n----\nUNWIND $events AS event\nMERGE (y:Year {year: event.year})\nMERGE (y)<-[:IN]-(e:Event {id: event.id})\nRETURN e.id AS x ORDER BY x\n----\n// end::clauses_unwind_create_nodes[]\n\nEach value of the original list is unwound and passed through `MERGE` to find or create the nodes and relationships.\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| x\n| 1\n| 2\nd|Rows: 2 +\nNodes created: 3 +\nRelationships created: 2 +\nProperties set: 3 +\nLabels added: 3\n|==="}], "source_file": "modules\\ROOT\\pages\\clauses\\unwind.adoc", "authority_level": 1}
{"name": "USE", "description": "The `USE` clause determines which graph a query, or query part, is executed against.", "syntax_examples": ["CREATE DATABASE myDatabase;\nCREATE COMPOSITE DATABASE myComposite;\nCREATE ALIAS myComposite.myConstituent FOR DATABASE myDatabase;", "USE myDatabase\nMATCH (n) RETURN n", "USE myComposite.myConstituent\nMATCH (n) RETURN n", "USE graph.byName('myComposite.myConstituent')\nMATCH (n) RETURN n", "USE graph.byName($graphName)\nMATCH (n) RETURN n", "USE graph.byElementId(\"4:c0a65d96-4993-4b0c-b036-e7ebd9174905:0\")\nMATCH (n) RETURN n"], "sections": [{"heading": "Syntax", "content": "[source, syntax, role=\"noheader\"]\n----\nUSE <graph reference>\n<other clauses>\n----\n\nA graph reference can be described using:\n\n* Direct graph references: `USE db1`.\n* The graph function xref:functions/graph.adoc#functions-graph-by-elementid[`graph.byElementId()`], to access a graph of a given element: `USE graph.byName(<element-id-string>)`.\n\nWhen connected to a composite database, a graph reference may additionally be passed with:\n\n* The graph function xref:functions/graph.adoc#functions-graph-byname[`graph.byName()`], which allows the graph reference to be resolved dynamically: `USE graph.byName(<string-expression>)`.\n\nA more detailed description of how and when a graph references needs to be quoted and/or escaped is defined xref::values-and-types/graph-references.adoc#rules[here]."}, {"heading": "USE clause when connected to a standard or system database", "content": "All databases and aliases are valid graph reference targets, except for link:{neo4j-docs-base-uri}/operations-manual/current/database-administration/aliases/manage-aliases-composite-databases/[composite databases and their constituents] as well as graph and property shards of a link:{neo4j-docs-base-uri}/operations-manual/current/scalability/sharded-property-databases/overview/[sharded property database].\nTargeting multiple databases is not allowed, unless connected to a composite database."}, {"heading": "Position of use clauses", "content": "When connected to a non-composite database, the `USE` clause can only appear as the prefix of schema commands, or as the first clause of queries. There may be multiple `USE` clauses as long as they target the same database."}, {"heading": "USE clause when connected to a composite database", "content": "When executing queries against a link:{neo4j-docs-base-uri}/operations-manual/current/scalability/composite-databases/concepts/[composite database], the `USE` clause must only refer to graphs that are part of the current composite database. The constituents can be listed either with `RETURN graph.names()` when connected to the composite database or `SHOW DATABASES YIELD name, constituents RETURN *`."}, {"heading": "Position of use clauses", "content": "When running queries against a composite database, the `USE` clause can appear as the first clause of:\n\n* A query (similar to how it is used when connected to a non-composite database).\n* Union parts:\n+\n[source, syntax, role=\"noheader\"]\n----\nUSE <graph>\n<other clauses>\n  UNION\nUSE <graph>\n<other clauses>\n----\n\n* Subqueries:\n+\n[source, syntax, role=\"noheader\"]\n----\nCALL () {\n  USE <graph>\n  <other clauses>\n}\n----\n+\nIn subqueries, a `USE` clause may appear directly following the xref:subqueries/call-subquery.adoc#variable-scope-clause[variable scope clause]: `CALL () { ... }`.\n\n\n[[query-use-examples]]"}, {"heading": "Examples", "content": "////\n[source, cypher, role=test-setup]\n----\nCREATE DATABASE myDatabase;\nCREATE COMPOSITE DATABASE myComposite;\nCREATE ALIAS myComposite.myConstituent FOR DATABASE myDatabase;\n----\n////\n\n[[query-use-examples-query-graph]]"}, {"heading": "Query a graph", "content": "This example assumes that the DBMS contains a database named `myDatabase`:\n\n.Query\n// tag::clauses_use[]\n[source, cypher]\n----\nUSE myDatabase\nMATCH (n) RETURN n\n----\n// end::clauses_use[]\n\n[[query-use-examples-query-composite-database-constituent-graph]]"}, {"heading": "Query a composite database constituent graph", "content": "In this example it is assumed that the DBMS contains a composite database named `myComposite`, which includes an alias named `myConstituent`:\n\n.Query\n// tag::clauses_use_composite[]\n[source, cypher]\n----\nUSE myComposite.myConstituent\nMATCH (n) RETURN n\n----\n// end::clauses_use_composite[]\n\n\n[[query-use-examples-query-composite-database-constituent-graph-dynamically]]"}, {"heading": "Query a composite database constituent graph dynamically", "content": "The xref:functions/graph.adoc#functions-graph-byname[`graph.byName()`] function can be used in the `USE` clause to resolve a constituent graph from a `STRING` value containing the qualified name of a constituent.\n\nThis example uses a composite database named `myComposite` that includes an alias named `myConstituent`:\n\n.Query\n[source, cypher]\n----\nUSE graph.byName('myComposite.myConstituent')\nMATCH (n) RETURN n\n----\n\nThe argument can be any expression that evaluates to the name of a constituent graph - for example a parameter:\n\n// can't run this through drivers, we need a value when initializing a session\n.Query\n[source, cypher, role=test-skip]\n----\nUSE graph.byName($graphName)\nMATCH (n) RETURN n\n----\n\n[[query-use-examples-query-composite-database-by-element-id]]"}, {"heading": "Query a composite database constituent using elementId", "content": "The xref:functions/graph.adoc#functions-graph-by-elementid[`graph.byElementId()`] function can be used in the `USE` clause to resolve a constituent graph to which a given xref:functions/scalar.adoc#functions-elementid[element id] belongs.\n\nIn the below example, it is assumed that the DBMS contains the database corresponding to the given element id. If you are connected to a composite database it needs to be a element id to a constituent database, which is a standard database in the DBMS.\n\n.Query\n[source, cypher, role=test-skip]\n----\nUSE graph.byElementId(\"4:c0a65d96-4993-4b0c-b036-e7ebd9174905:0\")\nMATCH (n) RETURN n\n----"}], "source_file": "modules\\ROOT\\pages\\clauses\\use.adoc", "authority_level": 1}
{"name": "WHERE", "description": "`WHERE` adds constraints to the patterns in a `MATCH` or `OPTIONAL MATCH` clause or filters the results of a `WITH` clause.", "syntax_examples": ["CREATE (andy:Swedish:Person {name: 'Andy', age: 36}),\n       (timothy:Person {name: 'Timothy', age: 38}),\n       (peter:Person {name: 'Peter', age: 35}),\n       (lisa:Person {name: 'Lisa', age: 48}),\n       (john:Person {name: 'John', age: 40}),\n       (susan:Person {name: 'Susan', age: 32}),\n       (andy)-[:KNOWS {since: 2012}]->(timothy),\n       (andy)-[:KNOWS {since: 1999}]->(peter),\n       (peter)-[:KNOWS {since: 2005}]->(lisa),\n       (lisa)-[:KNOWS {since: 2010}]->(john),\n       (john)-[:KNOWS {since: 2021}]->(susan)", "MATCH (n)\nWHERE n:Swedish\nRETURN n.name AS name", "MATCH (n:Person)\nWHERE n.age < 35\nRETURN n.name AS name, n.age AS age", "MATCH (:Person {name:'Andy'})-[k:KNOWS]->(f)\nWHERE k.since < 2000\nRETURN f.name AS oldFriend", "MATCH (n)\nWHERE n:$($label)\nRETURN labels(n) AS labels", "MATCH (n:Person)\nWHERE n[$propname] > 40\nRETURN n.name AS name, n.age AS age", "MATCH (n:Person)\nWITH n.name as name\nRETURN n", "MATCH (n:Person)\nWITH n.name as name\nWHERE n.age = 38\nRETURN name", "WITH 35 AS minAge\nMATCH (a:Person WHERE a.name = 'Andy')-[:KNOWS]->(b:Person WHERE b.age > minAge)\nRETURN b.name AS name", "MATCH (a:Person {name: 'Andy'})\nRETURN [(a)-->(b WHERE b:Person) | b.name] AS friends"], "sections": [{"heading": "Example graph", "content": "The following graph is used for the examples below:\n\nimage::graph-where-clause.svg[Example graph with Person nodes connecting via knows relationships,width=700,role=popup]\n\nTo recreate the graph, run the following query in an empty Neo4j database:\n\n[source, cypher, role=test-setup]\n----\nCREATE (andy:Swedish:Person {name: 'Andy', age: 36}),\n       (timothy:Person {name: 'Timothy', age: 38}),\n       (peter:Person {name: 'Peter', age: 35}),\n       (lisa:Person {name: 'Lisa', age: 48}),\n       (john:Person {name: 'John', age: 40}),\n       (susan:Person {name: 'Susan', age: 32}),\n       (andy)-[:KNOWS {since: 2012}]->(timothy),\n       (andy)-[:KNOWS {since: 1999}]->(peter),\n       (peter)-[:KNOWS {since: 2005}]->(lisa),\n       (lisa)-[:KNOWS {since: 2010}]->(john),\n       (john)-[:KNOWS {since: 2021}]->(susan)\n----\n\n[[basic-filtering]]"}, {"heading": "Basic filtering", "content": ".Filter on a node label\n// tag::clauses_where_node_label[]\n[source, cypher]\n----\nMATCH (n)\nWHERE n:Swedish\nRETURN n.name AS name\n----\n// end::clauses_where_node_label[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| name\n\n| \"Andy\"\n\n1+|Rows: 1\n|===\n\n.Filter on a node property\n// tag::clauses_where_node_property[]\n[source, cypher]\n----\nMATCH (n:Person)\nWHERE n.age < 35\nRETURN n.name AS name, n.age AS age\n----\n// end::clauses_where_node_property[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| name | age\n\n| \"Susan\" | 32 \n\n2+d|Rows: 1\n|===\n\n.Filter on a relationship property\n// tag::clauses_where_relationship_property[]\n[source, cypher]\n----\nMATCH (:Person {name:'Andy'})-[k:KNOWS]->(f)\nWHERE k.since < 2000\nRETURN f.name AS oldFriend\n----\n// end::clauses_where_relationship_property[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| oldFriend\n\n| \"Peter\"\n\n1+|Rows: 1\n|===\n\n\n[[filter-on-dynamic-labels-and-types]]"}, {"heading": "Filter on dynamic labels and types", "content": "To filter on a label or relationship type using a dynamically computed value, use `$(<expr>)` where <expr> is any Cypher expression:\n\n.Parameters\n[source, parameters]\n----\n{\n  \"label\": \"Swedish\"\n}\n----\n\n.Filter on a dynamically computed node label\n// tag::clauses_where_dynamic[]\n[source, cypher]\n----\nMATCH (n)\nWHERE n:$($label)\nRETURN labels(n) AS labels\n----\n// end::clauses_where_dynamic[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| labels\n| [\"Person\", \"Swedish\"]\n1+d|Rows: 1\n|===\n\n\n[[filter-on-dynamic-properties]]"}, {"heading": "Filter on dynamic properties", "content": "To filter on a property using a dynamically computed name, use square brackets `[]`:\n\n.Parameters\n[source, parameters]\n----\n{\n  \"propname\": \"age\"\n}\n----\n\n.Filter on a dynamically computed node property\n// tag::clauses_where_dynamic[]\n[source, cypher]\n----\nMATCH (n:Person)\nWHERE n[$propname] > 40\nRETURN n.name AS name, n.age AS age\n----\n// end::clauses_where_dynamic[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| name | age\n\n| \"Lisa\" | 48\n\n2+d|Rows: 1\n|===\n\n\n[[where-and-with]]"}, {"heading": "Using `WHERE` after `WITH`", "content": "xref:clauses/with.adoc[`WITH`] can be used to manipulate the output of a clause before it is passed on to subsequent query parts.\nOnce such a manipulation has occurred, the original clause output is not available to subsequent clauses.\nFor example, in the below query, `WITH` manipulates the output of the preceding `MATCH` in such a way that the succeeding `RETURN` no longer has access to the variable `n` declared in the `MATCH`.\n\n.`WITH` only retains explicitly listed variables; others become inaccessible\n[source, cypher, role=test-fail]\n----\nMATCH (n:Person)\nWITH n.name as name\nRETURN n\n----\n\nThe above query would work if the `RETURN` clause instead referenced the `name` variable produced by `WITH`.\nHowever, because `WHERE` is a subclause and not a clause, its scope is not limited by immediately preceding `WITH` clauses.\n\n.`WHERE` is not limited by an immediately preceding `WITH`\n// tag::clauses_where_with[]\n[source, cypher]\n----\nMATCH (n:Person)\nWITH n.name as name\nWHERE n.age = 38\nRETURN name\n----\n// end::clauses_where_with[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| name\n\n| \"Timothy\"\n\n1+d|Rows: 1\n|===\n\nThe name for `Timothy` is returned because the `WHERE` clause still acts as a filter on the `MATCH`.\nHowever, `WITH` still reduces the scope for the rest of the query moving forward.\nIn this case, `name` is the only variable in scope for the `RETURN` clause.\n\n[[filter-patterns]]"}, {"heading": "Filter patterns", "content": "`WHERE` clauses can be added to xref:patterns/fixed-length-patterns.adoc[fixed-length] and xref:patterns/variable-length-patterns.adoc[variable-length patterns] in order to specify additional constraints.\n\n[[fixed-length-patterns]]"}, {"heading": "Fixed-length patterns", "content": ".`WHERE` inside a node pattern\n// tag::clauses_where_node_pattern[]\n[source, cypher]\n----\nWITH 35 AS minAge\nMATCH (a:Person WHERE a.name = 'Andy')-[:KNOWS]->(b:Person WHERE b.age > minAge)\nRETURN b.name AS name\n----\n// end::clauses_where_node_pattern[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| name\n\n| \"Timothy\"\n\n1+d|Rows: 1\n|===\n\nWhen used this way, predicates in `WHERE` can reference the node variable that the `WHERE` clause belongs to, but not other elements of the `MATCH` pattern.\n\nThe same rule applies to pattern comprehensions:\n\n.`WHERE` inside a pattern comprehension\n// tag::clauses_where_pattern_comprehension[]\n[source, cypher]\n----\nMATCH (a:Person {name: 'Andy'})\nRETURN [(a)-->(b WHERE b:Person) | b.name] AS friends\n----\n// end::clauses_where_pattern_comprehension[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| friends\n| [\"Peter\",\"Timothy\"]\n|Rows: 1\n|===\n\n`WHERE` can also appear inside a relationship pattern in a `MATCH` clause:\n\n.`WHERE` inside relationship pattern\n[source, cypher]\n----\nWITH 2000 AS minYear\nMATCH (a:Person)-[r:KNOWS WHERE r.since < minYear]->(b:Person)\nRETURN a.name AS person, b.name AS friend, r.since AS knowsSince\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"3*<m\"]\n|===\n| name | friend | knowsSince\n\n| \"Andy\" | \"Peter\" | 1999\n\n3+d|Rows: 1\n|===\n\nRelationship pattern predicates can also be used inside pattern comprehensions, where the same caveats apply:\n\n.Relationship pattern predicate inside a pattern comprehension\n[source, cypher]\n----\nWITH 2000 AS minYear\nMATCH (a:Person {name: 'Andy'})\nRETURN [(a)-[r:KNOWS WHERE r.since < minYear]->(b:Person) | r.since] AS years\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| years\n\n| [1999]\n\n1+d|Rows: 1\n|===\n\n[[variable-length-patterns]]"}, {"heading": "Variable-length patterns", "content": "If matching for variable length patterns, `WHERE` can only be used together with the xref:patterns/variable-length-patterns.adoc#quantified-path-patterns[quantified path pattern] or xref:patterns/variable-length-patterns.adoc#quantified-relationships[quantified relationships] syntax.\n\n.Allowed - `WHERE` predicate inside a quantified relationship\n// tag::clauses_where_var_length[]\n[source, cypher]\n----\nMATCH p = (a:Person {name: \"Andy\"})-[r:KNOWS WHERE r.since < 2011]->{1,4}(:Person)\nRETURN [n IN nodes(p) | n.name] AS paths\n----\n// end::clauses_where_var_length[]\n\nNote that any paths including `Timothy` and `Susan` are excluded by the `WHERE` predicate, since their incoming `KNOWS` relationships both have a `since` value that is higher than `2011.`\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| paths\n\n| [\"Andy\", \"Peter\"]\n| [\"Andy\", \"Peter\", \"Lisa\"]\n| [\"Andy\", \"Peter\", \"Lisa\", \"John\"]\n\n1+d|Rows: 3\n|===\n\nFor more information about using `WHERE` predicates in quantified path patterns, see xref:patterns/variable-length-patterns.adoc#quantified-path-patterns-predicates[Predicates in quantified path patterns].\n\n`WHERE` is not allowed in variable-length patterns using the non-GQL compliant xref:patterns/reference.adoc#variable-length-relationships[variable-length relationship] syntax.\n\n.Not allowed - `WHERE` inside a variable-length relationship\n[source, cypher, role=test-fail]\n----\nMATCH p = (a:Person {name: 'Andy'})-[r:KNOWS*1..4 WHERE r.since < 2011]->(b:Person)\nRETURN [n IN nodes(p) | n.name] AS path\n----"}], "source_file": "modules\\ROOT\\pages\\clauses\\where.adoc", "authority_level": 1}
{"name": "WITH", "description": "Information about Cypher's `WITH` clause, which allows query parts to be chained together, piping the results from one part to be used as the starting point of the next.", "syntax_examples": ["CREATE (techCorp:Supplier {name: 'TechCorp', email: 'contact@techcorp.com'}),\n       (foodies:Supplier {name: 'Foodies Inc.', email: 'info@foodies.com'}),\n             \n       (laptop:Product {name: 'Laptop', price: 1000}),\n       (phone:Product {name: 'Phone', price: 500}),\n       (headphones:Product {name: 'Headphones', price: 250}),\n       (chocolate:Product {name: 'Chocolate', price: 5}),\n       (coffee:Product {name: 'Coffee', price: 10}),\n             \n       (amir:Customer {firstName: 'Amir', lastName: 'Rahman', email: 'amir.rahman@example.com', discount: 0.1}),\n       (keisha:Customer {firstName: 'Keisha', lastName: 'Nguyen', email: 'keisha.nguyen@example.com', discount: 0.2}),\n       (mateo:Customer {firstName: 'Mateo', lastName: 'Ortega', email: 'mateo.ortega@example.com', discount: 0.05}),\n       (hannah:Customer {firstName: 'Hannah', lastName: 'Connor', email: 'hannah.connor@example.com', discount: 0.15}),\n       (leila:Customer {firstName: 'Leila', lastName: 'Haddad', email: 'leila.haddad@example.com', discount: 0.1}),\n       (niko:Customer {firstName: 'Niko', lastName: 'Petrov', email: 'niko.petrov@example.com', discount: 0.25}),\n       (yusuf:Customer {firstName: 'Yusuf', lastName: 'Abdi', email: 'yusuf.abdi@example.com', discount: 0.1}),\n\n       (amir)-[:BUYS {date: date('2024-10-09')}]->(laptop),\n       (amir)-[:BUYS {date: date('2025-01-10')}]->(chocolate),\n       (keisha)-[:BUYS {date: date('2023-07-09')}]->(headphones),\n       (mateo)-[:BUYS {date: date('2025-03-05')}]->(chocolate),\n       (mateo)-[:BUYS {date: date('2025-03-05')}]->(coffee),\n       (mateo)-[:BUYS {date: date('2024-04-11')}]->(laptop),\n       (hannah)-[:BUYS {date: date('2023-12-11')}]->(coffee),\n       (hannah)-[:BUYS {date: date('2024-06-02')}]->(headphones),\n       (leila)-[:BUYS {date: date('2023-05-17')}]->(laptop),\n       (niko)-[:BUYS {date: date('2025-02-27')}]->(phone),\n       (niko)-[:BUYS {date: date('2024-08-23')}]->(headphones),\n       (niko)-[:BUYS {date: date('2024-12-24')}]->(coffee),\n       (yusuf)-[:BUYS {date: date('2024-12-24')}]->(chocolate),\n       (yusuf)-[:BUYS {date: date('2025-01-02')}]->(laptop),\n        \n       (techCorp)-[:SUPPLIES]->(laptop),\n       (techCorp)-[:SUPPLIES]->(phone),\n       (techCorp)-[:SUPPLIES]->(headphones),\n       (foodies)-[:SUPPLIES]->(chocolate),\n       (foodies)-[:SUPPLIES]->(coffee)", "WITH [1, 2, 3] AS list\nRETURN list", "MATCH (c:Customer)-[:BUYS]->(:Product {name: 'Chocolate'})\nWITH c AS customers\nRETURN customers.firstName AS chocolateCustomers", "MATCH (c:Customer)-[:BUYS]->(p:Product {name: 'Chocolate'})\nWITH c.name AS chocolateCustomers\nRETURN chocolateCustomers,\n       p.price AS chocolatePrice", "MATCH (supplier:Supplier)-[r]->(product:Product)\nWITH *\nRETURN supplier.name AS company,\n       type(r) AS relType,\n       product.name AS product", "WITH 11 AS x\nCALL (x) {\n  UNWIND [2, 3] AS y\n  WITH y\n  RETURN x*y AS a\n}\nRETURN x, a", "MATCH (customer:Customer)-[:BUYS]->(chocolate:Product {name: 'Chocolate'})\nWITH customer.firstName || ' ' || customer.lastName AS customerFullName,\n     chocolate.price * (1 - customer.discount) AS chocolateNetPrice\nRETURN customerFullName,\n       chocolateNetPrice", "MATCH (p:Product)\nWITH p, p.price >= 500 AS isExpensive\nWITH p, isExpensive, NOT isExpensive AS isAffordable\nWITH p, isExpensive, isAffordable, \n     CASE\n         WHEN isExpensive THEN 'High-end'\n         ELSE 'Budget'\n     END AS discountCategory\nRETURN p.name AS product,\n       p.price AS price,\n       isAffordable,\n       discountCategory\nORDER BY price", "MATCH (c:Customer)-[:BUYS]->(p:Product)\nWITH c.firstName AS customer,\n     sum(p.price) AS totalSpent,\n     collect(p.name) AS productsBought\nRETURN customer,\n       totalSpent,\n       productsBought\nORDER BY totalSpent DESC", "MATCH (c:Customer)\nWITH DISTINCT c.discount AS discountRates\nRETURN discountRates\nORDER BY discountRates"], "sections": [{"heading": "Example graph", "content": "A graph with the following schema is used for the examples below:\n\nimage::with-graph.svg[Example graph connecting suppliers, products, and customers,width=600,role=popup]\n\nTo recreate the graph, run the following query against an empty Neo4j database.\n\n[source, cypher, role=test-setup]\n----\nCREATE (techCorp:Supplier {name: 'TechCorp', email: 'contact@techcorp.com'}),\n       (foodies:Supplier {name: 'Foodies Inc.', email: 'info@foodies.com'}),\n             \n       (laptop:Product {name: 'Laptop', price: 1000}),\n       (phone:Product {name: 'Phone', price: 500}),\n       (headphones:Product {name: 'Headphones', price: 250}),\n       (chocolate:Product {name: 'Chocolate', price: 5}),\n       (coffee:Product {name: 'Coffee', price: 10}),\n             \n       (amir:Customer {firstName: 'Amir', lastName: 'Rahman', email: 'amir.rahman@example.com', discount: 0.1}),\n       (keisha:Customer {firstName: 'Keisha', lastName: 'Nguyen', email: 'keisha.nguyen@example.com', discount: 0.2}),\n       (mateo:Customer {firstName: 'Mateo', lastName: 'Ortega', email: 'mateo.ortega@example.com', discount: 0.05}),\n       (hannah:Customer {firstName: 'Hannah', lastName: 'Connor', email: 'hannah.connor@example.com', discount: 0.15}),\n       (leila:Customer {firstName: 'Leila', lastName: 'Haddad', email: 'leila.haddad@example.com', discount: 0.1}),\n       (niko:Customer {firstName: 'Niko', lastName: 'Petrov', email: 'niko.petrov@example.com', discount: 0.25}),\n       (yusuf:Customer {firstName: 'Yusuf', lastName: 'Abdi', email: 'yusuf.abdi@example.com', discount: 0.1}),\n\n       (amir)-[:BUYS {date: date('2024-10-09')}]->(laptop),\n       (amir)-[:BUYS {date: date('2025-01-10')}]->(chocolate),\n       (keisha)-[:BUYS {date: date('2023-07-09')}]->(headphones),\n       (mateo)-[:BUYS {date: date('2025-03-05')}]->(chocolate),\n       (mateo)-[:BUYS {date: date('2025-03-05')}]->(coffee),\n       (mateo)-[:BUYS {date: date('2024-04-11')}]->(laptop),\n       (hannah)-[:BUYS {date: date('2023-12-11')}]->(coffee),\n       (hannah)-[:BUYS {date: date('2024-06-02')}]->(headphones),\n       (leila)-[:BUYS {date: date('2023-05-17')}]->(laptop),\n       (niko)-[:BUYS {date: date('2025-02-27')}]->(phone),\n       (niko)-[:BUYS {date: date('2024-08-23')}]->(headphones),\n       (niko)-[:BUYS {date: date('2024-12-24')}]->(coffee),\n       (yusuf)-[:BUYS {date: date('2024-12-24')}]->(chocolate),\n       (yusuf)-[:BUYS {date: date('2025-01-02')}]->(laptop),\n        \n       (techCorp)-[:SUPPLIES]->(laptop),\n       (techCorp)-[:SUPPLIES]->(phone),\n       (techCorp)-[:SUPPLIES]->(headphones),\n       (foodies)-[:SUPPLIES]->(chocolate),\n       (foodies)-[:SUPPLIES]->(coffee)\n----\n\n[[create-new-variables]]"}, {"heading": "Create new variables", "content": "`WITH` can be used in combination with the `AS` keyword to bind new variables which can then be passed to subsequent clauses.\n\n.Create a new variable\n[source, cypher]\n----\nWITH [1, 2, 3] AS list\nRETURN list\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| list\n\n| [1, 2, 3]\n\n1+d|Rows: 1\n|===\n\nIn the below example, the `WITH` clause binds all matched `Customer` nodes to a new variable, `customers`.\nThe bound nodes are `MAP` values which can then be referenced from the new variable.\n\n.Create a new variable bound to matched nodes\n// tag::clauses_with_new_variable[]\n[source, cypher]\n----\nMATCH (c:Customer)-[:BUYS]->(:Product {name: 'Chocolate'})\nWITH c AS customers\nRETURN customers.firstName AS chocolateCustomers\n----\n// end::clauses_with_new_variable[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"1*<m\"]\n|===\n| chocolateCustomers\n\n| \"Amir\"\n| \"Mateo\"\n| \"Yusuf\"\n\n1+d|Rows: 3\n|===\n\n[[variable-scope]]"}, {"heading": "Control variables in scope", "content": "`WITH` can be used to control which variables remain within the scope of a query.\nAny variable that is referenced by a `WITH` clause remains with the scope of the query and is available to subsequent clauses.\nIf a variable is re-named in a `WITH` clause, it can only be referenced by its new name by subsequent clauses.\nIf a variable is not explicitly referenced in a `WITH` clause, it is dropped from the scope of the query and cannot be referenced by subsequent clauses.\nTo retain all variables in the scope of the query, use `WITH *`.\n\nIn the below query, the `WITH` clause de-scopes the `p` variable.\nAs a result, it is not available to the subsequent `RETURN` clause.\nNor would the `c` variable be available -- only `chocolateCustomers` is available due to the preceding `WITH` clause.\n\n.De-scoping a variable\n[source, cypher, role=test-fail]\n----\nMATCH (c:Customer)-[:BUYS]->(p:Product {name: 'Chocolate'})\nWITH c.name AS chocolateCustomers\nRETURN chocolateCustomers,\n       p.price AS chocolatePrice\n----\n\n.GQLSTATUS error chain\n[role=\"queryresult\",stripes=\"all\",cols=\"1\"]\n|===\n| link:https://neo4j.com/docs/status-codes/current/errors/gql-errors/42N62/[42N62]: error: syntax error or access rule violation - variable not defined. Variable `p` not defined.\n\nlink:https://neo4j.com/docs/status-codes/current/errors/gql-errors/42001/[42001]: error: syntax error or access rule violation - invalid syntax\n|===\n\n.Retain all variables with `WITH *`\n// tag::clauses_with_all_variables[]\n[source, cypher]\n----\nMATCH (supplier:Supplier)-[r]->(product:Product)\nWITH *\nRETURN supplier.name AS company,\n       type(r) AS relType,\n       product.name AS product\n----\n// end::clauses_with_all_variables[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"3*<m\"]\n|===\n| company | relType | product\n\n| \"TechCorp\" | \"SUPPLIES\" | \"Laptop\"\n| \"TechCorp\" | \"SUPPLIES\" | \"Phone\"\n| \"TechCorp\" | \"SUPPLIES\" | \"Headphones\"\n| \"Foodies Inc.\" | \"SUPPLIES\" | \"Chocolate\"\n| \"Foodies Inc.\" | \"SUPPLIES\" | \"Coffee\"\n\n3+d|Rows: 5\n|===\n\n`WITH` cannot de-scope variables imported to a xref:subqueries/call-subquery.adoc[`CALL` subquery], because variables imported to a subquery are considered global to its inner scope.\nMore specifically, a variable imported into a `CALL` subquery will be available to subsequent clauses even if a preceding `WITH` clause does not reference it.\n\nIn the below example, the `x` variable is imported to the inside scope of a `CALL` subquery, and is successfully referenced  by the `RETURN` clause even though the preceding `WITH` neglects to list it.\n\n.Variables cannot be de-scoped in the inner scope of a subquery\n// tag::clauses_with_subquery[]\n[source, cypher]\n----\nWITH 11 AS x\nCALL (x) {\n  UNWIND [2, 3] AS y\n  WITH y\n  RETURN x*y AS a\n}\nRETURN x, a\n----\n// end::clauses_with_subquery[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| x | a\n\n| 11 | 22\n| 11 | 33\n\n2+d|Rows: 2\n|===\n\nFor more information, see xref:subqueries/call-subquery.adoc#import-variables[`CALL` subqueries -> Import variables].\n\n[[bind-values-to-variables]]"}, {"heading": "Bind values to variables", "content": "`WITH` can be used to assign the values of expressions to variables.\nIn the below query, the value of the xref:expressions/string-operators.adoc[`STRING` concatenation] expression is bound to a new variable `customerFullName`, and the value from the expression `chocolate.price * (1 - customer.discount)` is bound to `chocolateNetPrice`, both of which are then available in the `RETURN` clause.\n\n.Bind values to variables\n// tag::clauses_with_bind_values[]\n[source, cypher]\n----\nMATCH (customer:Customer)-[:BUYS]->(chocolate:Product {name: 'Chocolate'})\nWITH customer.firstName || ' ' || customer.lastName AS customerFullName,\n     chocolate.price * (1 - customer.discount) AS chocolateNetPrice\nRETURN customerFullName,\n       chocolateNetPrice\n----\n// end::clauses_with_bind_values[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\",cols=\"2*<m\"]\n|===\n| customerFullName | chocolateNetPrice\n\n| \"Amir Rahman\" | 4.5\n| \"Mateo Ortega\" | 4.75\n| \"Yusuf Abdi\"  | 4.5\n\n2+d|Rows: 3\n|===\n\nBecause `WITH` can be used to assign variables to the values of expressions, it can be used to chain expressions.\n\n.Chain expressions using `WITH`\n// tag::clauses_with_chain_expressions[]\n[source, cypher]\n----\nMATCH (p:Product)\nWITH p, p.price >= 500 AS isExpensive\nWITH p, isExpensive, NOT isExpensive AS isAffordable\nWITH p, isExpensive, isAffordable, \n     CASE\n         WHEN isExpensive THEN 'High-end'\n         ELSE 'Budget'\n     END AS discountCategory\nRETURN p.name AS product,\n       p.price AS price,\n       isAffordable,\n       discountCategory\nORDER BY price\n----\n// end::clauses_with_chain_expressions[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\", cols=\"4*<m\"]\n|===\n| product | price | isAffordable | discountCategory\n\n| \"Chocolate\" | 5 | true | 'Budget'\n| \"Coffee\" | 10 | true | 'Budget'\n| \"Headphones\" | 250 | true | 'Budget'\n| \"Phone\" | 500   | false | 'High-end'\n| \"Laptop\" | 1000  | false | 'High-end'\n\n4+d|Rows: 5\n|===\n\n[NOTE]\nThe `LET` clause can be used to assign values to variables and to chain expressions more clearly and concisely than `WITH`.\nFor more information, see xref:clauses/let.adoc#chaining-expressions[`LET` -> Chaining expressions].\n\n[[aggregations]]"}, {"heading": "Aggregations", "content": "The `WITH` clause can perform aggregations and bind the results to new variables.\nIn this example, the xref:functions/aggregating.adoc#functions-sum[`sum()`] function is used to calculate the total spent by each customer, and the value for each is bound to the new variable `totalSpent`.\nThe xref:functions/aggregating.adoc#functions-collect[`collect()`] function is used to collect each product into  `LIST` values bound to the `productsBought` variable.\n\n.`WITH` performing aggregations\n// tag::clauses_with_aggregations[]\n[source, cypher]\n----\nMATCH (c:Customer)-[:BUYS]->(p:Product)\nWITH c.firstName AS customer,\n     sum(p.price) AS totalSpent,\n     collect(p.name) AS productsBought\nRETURN customer,\n       totalSpent,\n       productsBought\nORDER BY totalSpent DESC\n----\n// end::clauses_with_aggregations[]\n\n\n.Result\n[role=\"queryresult\",options=\"header,footer\", cols=\"3*<m\"]\n|===\n| customer | totalSpent | productsBought\n\n| \"Mateo\" | 1015 | [\"Laptop\", \"Chocolate\", \"Coffee\"]\n| \"Amir\" | 1005 | [\"Laptop\", \"Chocolate\"]\n| \"Yusuf\" | 1005 | [\"Laptop\", \"Chocolate\"]\n| \"Leila\" | 1000 | [\"Laptop\"]\n| \"Niko\" | 760 | [\"Phone\", \"Headphones\", \"Coffee\"]\n| \"Hannah\" | 260 | [\"Headphones\", \"Coffee\"]\n| \"Keisha\" | 250 | [\"Headphones\"]\n\n3+d|Rows: 7\n|===\n\n[[remove-duplicate-values]]"}, {"heading": "Remove duplicate values", "content": "`WITH` can be used to remove duplicate values from the result set if appended with the modifier `DISTINCT`.\n\nIn the below query, `WITH DISTINCT` is used to remove any duplicate `discount` property values from `Customer` nodes.\n\n.`WITH DISTINCT` to remove duplicate values\n// tag::clauses_with_remove_duplicates[]\n[source, cypher]\n----\nMATCH (c:Customer)\nWITH DISTINCT c.discount AS discountRates\nRETURN discountRates\nORDER BY discountRates\n----\n// end::clauses_with_remove_duplicates[]\n\n.Result\n[role=\"queryresult\",options=\"header,footer\", cols=\"1*<m\"]\n|===\n| discountRates\n\n| 0.05\n| 0.1\n| 0.15\n| 0.2\n| 0.25\n\n1+d|Rows: 5\n|===\n\n[role=label--new-Neo4j-2025.06 label--cypher-25-only]\n[[with-all-results]]"}, {"heading": "Explicitly project values", "content": "`WITH ALL` can be used to explicitly project all values bound to a variable.\nUsing it is functionally the same as using simple `WITH`.\n\n.Explicit result projection using `WITH ALL`\n[source, cypher]\n----\nMATCH (c:Customer)\nWITH ALL c.discount AS discountRates\nRETURN discountRates\nORDER BY discountRates\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\", cols=\"1*<m\"]\n|===\n| discountRates\n\n| 0.05\n| 0.1\n| 0.1\n| 0.1\n| 0.15\n| 0.2\n| 0.25\n\n1+d|Rows: 7\n|===\n\n[[ordering-pagination]]"}, {"heading": "Ordering and pagination", "content": "`WITH` can order and paginate results if used together with the xref:clauses/order-by.adoc[`ORDER BY`], xref:clauses/limit.adoc[`LIMIT`], and xref:clauses/skip.adoc[`SKIP`] subclauses.\nIf so, these subclauses should be understood as part of the result manipulation performed by `WITH` -- not as standalone clauses -- before results are passed on to subsequent clauses. \n\nIn the below query, the results are ordered in a descending order by which `Customer` has spent the most using `ORDER BY` before they are passed on to the final `RETURN` clause.\n\n.Order results with `ORDER BY`\n[source, cypher]\n----\nMATCH (c:Customer)-[:BUYS]->(p:Product)\nWITH c,\n     sum(p.price) AS totalSpent\n  ORDER BY totalSpent DESC\nRETURN c.firstName AS customer, totalSpent\n----\n\n.Result\n[role=\"queryresult\",options=\"header,footer\", cols=\"2*<m\"]\n|===\n| customer | totalSpent\n\n| \"Mateo\" | 1015\n| \"Amir\" | 1005\n| \"Yusuf\" | 1005\n| \"Leila\" | 1000\n| \"Niko\" | 760\n| \"Hannah\" | 260\n| \"Keisha\" | 250\n\n2+d|Rows: 7\n|===\n\nIn the next example, `LIMIT` is used to only retain the top 3 customers with the highest `totalSpent` values in the result set after ordering.\nThen, the xref:clauses/set.adoc[`SET`] assigns a new property (`topSpender = true`) to those customers who have spent the most.\n\n.Limit results with `LIMIT`\n// tag::clauses_with_ordering_pagination[]\n[source, cypher]\n----\nMATCH (c:Customer)-[:BUYS]->(p:Product)\nWITH c,\n     sum(p.price) AS totalSpent\n  ORDER BY totalSpent DESC\n  LIMIT 3\nSET c.topSpender = true\nRETURN c.firstName AS customer,\n       totalSpent,\n       c.topSpender AS topSpender\n----\n// end::clauses_with_ordering_pagination[]\n\n[role=\"queryresult\",options=\"header,footer\", cols=\"3*<m\"]\n|===\n| customer | totalSpent | topSpender\n\n| \"Mateo\" | 1015 | true\n| \"Amir\"  | 1005 | true\n| \"Yusuf\" | 1005 | true\n\n3+d|Rows: 3\n|===\n\n`SKIP` can be used after a `WITH` clause to discard rows from the result set.\nBelow, `SKIP` excludes the first 3 rows in the ordered result set (i.e. the 3 `Customer` nodes with highest `totalSpent` value) and assigns a `false` value to the new `topSpender` property of the remaining `Customer` nodes.\n\n.Exclude results with `SKIP`\n[source, cypher]\n----\nMATCH (c:Customer)-[:BUYS]->(p:Product)\nWITH c,\n     sum(p.price) AS totalSpent\n  ORDER BY totalSpent DESC\n  SKIP 3\nSET c.topSpender = false\nRETURN c.firstName AS customer,\n       totalSpent,\n       c.topSpender AS topSpender\n----\n\n[role=\"queryresult\",options=\"header,footer\", cols=\"3*<m\"]\n|===\n| customer | totalSpent | topSpender\n\n| \"Leila\" | 1000 | false\n| \"Niko\" | 760 | false\n| \"Hannah\" | 260 | false\n| \"Keisha\" | 250 | false\n\n3+d|Rows: 4\n|===\n\n`ORDER BY`, `LIMIT`, and `SKIP` can also be used after a `WITH` clause to narrow down the set of rows before continuing with further pattern matching.\nIn the query below, all products supplied by `Foodies Inc.` are matched first. \n`WITH` passes those products forward, `ORDER BY` sorts them by descending `price`, and `LIMIT` retains only the most expensive one.\nThe second `MATCH` clause then matches only from that single product to find all customers who bought it.\n\n.Control pattern matching scope with ordering and pagination\n[source, cypher]\n----\nMATCH (:Supplier {name: 'Foodies Inc.'})-[:SUPPLIES]->(p:Product)\nWITH p\n  ORDER BY p.price DESC\n  LIMIT 1\nMATCH (p)<-[:BUYS]-(c:Customer)\nRETURN p.name AS product,\n       p.price AS price,\n       collect(c.firstName) AS customers\n----\n\n\n[role=\"queryresult\",options=\"header,footer\", cols=\"3*<m\"]\n|===\n| product | price | customers\n\n| \"Coffee\" | 10 | [\"Mateo\", \"Hannah\", \"Niko\"]\n\n3+d|Rows: 1\n|===\n\n\n[[filter-results]]"}, {"heading": "Filter results", "content": "`WITH` can be followed by the xref:clauses/where.adoc[`WHERE`] subclause to filter results.\nSimilar to the subclauses used for xref:clauses/with.adoc#ordering-pagination[ordering and pagination], `WHERE` should be understood as part of the result manipulation performed by `WITH` -- not as a standalone clause -- before the results are passed on to subsequent clauses.\nFor more information, see xref:clauses/where.adoc#where-and-with[Using `WHERE` after `WITH`].\n\n.Filter using `WITH` and `WHERE`\n[source, cypher]\n----\nUNWIND [1, 2, 3, 4, 5, 6] AS x\nWITH x\n  WHERE x > 2\nRETURN x\n----\n\n[role=\"queryresult\",options=\"header,footer\", cols=\"1*<m\"]\n|===\n| x\n\n| 3\n| 4\n| 5\n| 6\n\n1+d|Rows: 4\n|===\n\nIn the below query, `WITH` and `WHERE` are used to filter out any `Supplier` nodes whose `totalSales` is less than `1000`.\nNote the use of `DISTINCT` inside `collect()` to remove any duplicate `Customer` nodes.\n\n.Filter property values using `WITH` and `WHERE`\n// tag::clauses_with_filtering[]\n[source, cypher]\n----\nMATCH (s:Supplier)-[:SUPPLIES]->(p:Product)<-[:BUYS]-(c:Customer)\nWITH s,\n     sum(p.price) AS totalSales,\n     count(DISTINCT c) AS uniqueCustomers\n  WHERE totalSales > 1000\nRETURN s.name AS supplier,\n       totalSales,\n       uniqueCustomers\n----\n// end::clauses_with_filtering[]\n\n[role=\"queryresult\",options=\"header,footer\", cols=\"3*<m\"]\n|===\n\n| supplier | totalSales | uniqueCustomers\n\n| \"TechCorp\" | 5250 | 7\n\n3+d|Rows: 1\n|===\n\n[NOTE]\nThe `FILTER` clause can be used as a more concise alternative to `WITH * WHERE <predicate>` constructs.\nFor more information, see xref:clauses/filter.adoc#filter-with-where[`FILTER` as a substitute for `WITH * WHERE`]."}], "source_file": "modules\\ROOT\\pages\\clauses\\with.adoc", "authority_level": 1}
{"name": "YIELD", "description": "The YIELD sub-clause specifies which fields of a procedure or SHOW command result to return. Used with CALL to select specific return columns from stored procedures.", "syntax_examples": ["CALL db.labels() YIELD label RETURN label", "CALL db.propertyKeys() YIELD propertyKey AS prop RETURN prop", "SHOW INDEXES YIELD name, type WHERE type = \"FULLTEXT\" RETURN name"], "sections": [], "source_file": "modules/ROOT/pages/clauses/call.adoc", "authority_level": 1}
{"name": "DISTINCT", "description": "The DISTINCT keyword removes duplicate rows from the result set. Can be used with RETURN, WITH, and aggregating functions like collect(DISTINCT x) and count(DISTINCT x).", "syntax_examples": ["MATCH (n) RETURN DISTINCT labels(n)", "MATCH (a)-->(b) RETURN DISTINCT b", "MATCH (p:Person)-[:ACTED_IN]->(m) RETURN collect(DISTINCT m.title)"], "sections": [], "source_file": "modules/ROOT/pages/clauses/return.adoc", "authority_level": 1}
{"name": "UNION", "description": "The UNION clause combines the results of two or more queries. UNION removes duplicate rows from the combined result. All queries must return the same column names.", "syntax_examples": ["MATCH (a:Actor) RETURN a.name AS name UNION MATCH (d:Director) RETURN d.name AS name", "MATCH (n:Swedish) RETURN n.name UNION MATCH (n:London) RETURN n.name"], "sections": [], "source_file": "modules/ROOT/pages/clauses/union.adoc", "authority_level": 1}
{"name": "UNION ALL", "description": "UNION ALL combines query results like UNION but retains all rows including duplicates. Faster than UNION when deduplication is not needed.", "syntax_examples": ["MATCH (a:Actor) RETURN a.name AS name UNION ALL MATCH (d:Director) RETURN d.name AS name"], "sections": [], "source_file": "modules/ROOT/pages/clauses/union.adoc", "authority_level": 1}
{"name": "CASE", "description": "The CASE expression evaluates conditions and returns a value. Supports simple form (CASE expr WHEN value THEN result) and generic form (CASE WHEN condition THEN result). Always used with WHEN, THEN, and optionally ELSE and END.", "syntax_examples": ["MATCH (n:Person) RETURN n.name, CASE n.age WHEN 0 THEN \"baby\" WHEN 18 THEN \"adult\" ELSE \"other\" END AS category", "MATCH (n) RETURN CASE WHEN n.eyes = \"blue\" THEN 1 WHEN n.age < 40 THEN 2 ELSE 3 END AS result"], "sections": [], "source_file": "modules/ROOT/pages/syntax/expressions.adoc", "authority_level": 1}
{"name": "WHEN", "description": "The WHEN keyword is used inside CASE expressions to specify conditions or values to match against. Each WHEN clause is followed by a THEN clause specifying the result value.", "syntax_examples": ["CASE n.type WHEN \"A\" THEN 1 WHEN \"B\" THEN 2 END", "CASE WHEN n.age >= 18 THEN \"adult\" WHEN n.age >= 13 THEN \"teen\" ELSE \"child\" END"], "sections": [], "source_file": "modules/ROOT/pages/syntax/expressions.adoc", "authority_level": 1}
{"name": "THEN", "description": "The THEN keyword specifies the return value when a WHEN condition matches in a CASE expression.", "syntax_examples": ["CASE WHEN n.age > 0 THEN n.age ELSE 0 END"], "sections": [], "source_file": "modules/ROOT/pages/syntax/expressions.adoc", "authority_level": 1}
{"name": "ELSE", "description": "The ELSE keyword in a CASE expression specifies the default value returned when no WHEN condition matches. If ELSE is omitted and no match is found, null is returned.", "syntax_examples": ["CASE n.status WHEN \"active\" THEN true ELSE false END", "RETURN CASE WHEN n IS NOT NULL THEN n.name ELSE \"unknown\" END"], "sections": [], "source_file": "modules/ROOT/pages/syntax/expressions.adoc", "authority_level": 1}
{"name": "SHOW", "description": "The SHOW command family provides metadata about the database: indexes, constraints, procedures, functions, transactions, databases, and settings. Commonly combined with YIELD and WHERE for filtering.", "syntax_examples": ["SHOW INDEXES", "SHOW CONSTRAINTS", "SHOW DATABASES", "SHOW TRANSACTIONS YIELD transactionId, elapsedTime", "SHOW INDEXES YIELD name, type WHERE type = \"RANGE\" RETURN name"], "sections": [], "source_file": "modules/ROOT/pages/clauses/show.adoc", "authority_level": 1}
